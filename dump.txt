============================= test session starts ==============================
platform linux -- Python 3.10.6, pytest-7.3.1, pluggy-1.0.0 -- /home/czaloom/velour-env/bin/python3
cachedir: .pytest_cache
rootdir: /home/czaloom/velour
plugins: anyio-3.6.2
collecting ... collected 16 items

integration_tests/test_client.py::test_create_dataset_with_href_and_description FAILED [  6%]
integration_tests/test_client.py::test_create_dataset_with_href_and_description ERROR [  6%]
integration_tests/test_client.py::test_create_model_with_href_and_description FAILED [ 12%]
integration_tests/test_client.py::test_create_model_with_href_and_description ERROR [ 12%]
integration_tests/test_client.py::test_create_dataset_with_detections PASSED [ 18%]
integration_tests/test_client.py::test_create_model_with_predicted_detections FAILED [ 25%]
integration_tests/test_client.py::test_create_gt_detections_as_bbox_or_poly PASSED [ 31%]
integration_tests/test_client.py::test_create_pred_detections_as_bbox_or_poly PASSED [ 37%]
integration_tests/test_client.py::test_create_dataset_with_segmentations PASSED [ 43%]
integration_tests/test_client.py::test_create_gt_segs_as_polys_or_masks PASSED [ 50%]
integration_tests/test_client.py::test_create_model_with_predicted_segmentations FAILED [ 56%]
integration_tests/test_client.py::test_create_dataset_with_classifications PASSED [ 62%]
integration_tests/test_client.py::test_create_model_with_predicted_classifications FAILED [ 68%]
integration_tests/test_client.py::test_boundary PASSED                   [ 75%]
integration_tests/test_client.py::test_iou PASSED                        [ 81%]
integration_tests/test_client.py::test_delete_dataset_exception FAILED   [ 87%]
integration_tests/test_client.py::test_evaluate_ap FAILED                [ 93%]
integration_tests/test_client.py::test_evaluate_clf FAILED               [100%]

==================================== ERRORS ====================================
______ ERROR at teardown of test_create_dataset_with_href_and_description ______

self = <sqlalchemy.engine.base.Connection object at 0x7f57657cec80>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57657cee30>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f576354f430>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7f576354fd90>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:

            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57657cee30>
cursor = <cursor object at 0x7f57653be890; closed: -1>
statement = 'SELECT label.id, label.key, label.value \nFROM label'
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f576354f430>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.InFailedSqlTransaction: current transaction is aborted, commands ignored until end of transaction block

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: InFailedSqlTransaction

The above exception was the direct cause of the following exception:

client = <velour.client.Client object at 0x7f57657ce0e0>

    @pytest.fixture
    def db(client: Client) -> Session:
        """This fixture makes sure there's not datasets, models, or labels in the backend
        (raising a RuntimeError if there are). It returns a db session and as cleanup
        clears out all datasets, models, and labels from the backend.
        """
        if len(client.get_datasets()) > 0:
            raise RuntimeError(
                "Tests should be run on an empty velour backend but found existing datasets."
            )

        if len(client.get_models()) > 0:
            raise RuntimeError(
                "Tests should be run on an empty velour backend but found existing models."
            )

        if len(client.get_all_labels()) > 0:
            raise RuntimeError(
                "Tests should be run on an empty velour backend but found existing labels."
            )

        engine = create_engine("postgresql://postgres:password@localhost/postgres")
        sess = Session(engine)
        sess.execute(text("SET postgis.gdal_enabled_drivers = 'ENABLE_ALL';"))
        sess.execute(text("SET postgis.enable_outdb_rasters = True;"))

        yield sess

        # cleanup by deleting all datasets, models, and labels
        for dataset in client.get_datasets():
            client.delete_dataset(name=dataset["name"])

        for model in client.get_models():
            client.delete_model(name=model["name"])

>       labels = sess.scalars(select(models.Label))

integration_tests/test_client.py:168:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2343: in scalars
    return self._execute_internal(
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2126: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
../velour-env/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57657cee30>
cursor = <cursor object at 0x7f57653be890; closed: -1>
statement = 'SELECT label.id, label.key, label.value \nFROM label'
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f576354f430>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.InternalError: (psycopg2.errors.InFailedSqlTransaction) current transaction is aborted, commands ignored until end of transaction block
E
E       [SQL: SELECT label.id, label.key, label.value
E       FROM label]
E       (Background on this error at: https://sqlalche.me/e/20/2j85)

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: InternalError
---------------------------- Captured stdout setup -----------------------------
Succesfully connected to http://localhost:8000/.
_______ ERROR at teardown of test_create_model_with_href_and_description _______

self = <sqlalchemy.engine.base.Connection object at 0x7f57639e7550>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57639e6380>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f5764b739d0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7f5764b73c40>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:

            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57639e6380>
cursor = <cursor object at 0x7f57653bea70; closed: -1>
statement = 'SELECT label.id, label.key, label.value \nFROM label'
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f5764b739d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.InFailedSqlTransaction: current transaction is aborted, commands ignored until end of transaction block

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: InFailedSqlTransaction

The above exception was the direct cause of the following exception:

client = <velour.client.Client object at 0x7f57639e76d0>

    @pytest.fixture
    def db(client: Client) -> Session:
        """This fixture makes sure there's not datasets, models, or labels in the backend
        (raising a RuntimeError if there are). It returns a db session and as cleanup
        clears out all datasets, models, and labels from the backend.
        """
        if len(client.get_datasets()) > 0:
            raise RuntimeError(
                "Tests should be run on an empty velour backend but found existing datasets."
            )

        if len(client.get_models()) > 0:
            raise RuntimeError(
                "Tests should be run on an empty velour backend but found existing models."
            )

        if len(client.get_all_labels()) > 0:
            raise RuntimeError(
                "Tests should be run on an empty velour backend but found existing labels."
            )

        engine = create_engine("postgresql://postgres:password@localhost/postgres")
        sess = Session(engine)
        sess.execute(text("SET postgis.gdal_enabled_drivers = 'ENABLE_ALL';"))
        sess.execute(text("SET postgis.enable_outdb_rasters = True;"))

        yield sess

        # cleanup by deleting all datasets, models, and labels
        for dataset in client.get_datasets():
            client.delete_dataset(name=dataset["name"])

        for model in client.get_models():
            client.delete_model(name=model["name"])

>       labels = sess.scalars(select(models.Label))

integration_tests/test_client.py:168:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2343: in scalars
    return self._execute_internal(
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2126: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
../velour-env/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57639e6380>
cursor = <cursor object at 0x7f57653bea70; closed: -1>
statement = 'SELECT label.id, label.key, label.value \nFROM label'
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f5764b739d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.InternalError: (psycopg2.errors.InFailedSqlTransaction) current transaction is aborted, commands ignored until end of transaction block
E
E       [SQL: SELECT label.id, label.key, label.value
E       FROM label]
E       (Background on this error at: https://sqlalche.me/e/20/2j85)

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: InternalError
---------------------------- Captured stdout setup -----------------------------
Succesfully connected to http://localhost:8000/.
=================================== FAILURES ===================================
________________ test_create_dataset_with_href_and_description _________________

self = <sqlalchemy.engine.base.Connection object at 0x7f57657cec80>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57657cee30>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f57657cf8e0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7f57657cfdf0>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:

            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57657cee30>
cursor = <cursor object at 0x7f57653bdf30; closed: -1>
statement = 'SELECT dataset.id, dataset.name, dataset.href, dataset.description, dataset.draft, dataset.from_video \nFROM dataset'
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f57657cf8e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedColumn: column dataset.href does not exist
E       LINE 1: SELECT dataset.id, dataset.name, dataset.href, dataset.descr...
E                                                ^

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: UndefinedColumn

The above exception was the direct cause of the following exception:

client = <velour.client.Client object at 0x7f57657ce0e0>
db = <sqlalchemy.orm.session.Session object at 0x7f57657cee00>

    def test_create_dataset_with_href_and_description(client: Client, db: Session):
        href = "http://a.com/b"
        description = "a description"
        client.create_dataset(dset_name, href=href, description=description)
>       db_dataset = db.scalar(select(models.Dataset))

integration_tests/test_client.py:552:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2281: in scalar
    return self._execute_internal(
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2126: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
../velour-env/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57657cee30>
cursor = <cursor object at 0x7f57653bdf30; closed: -1>
statement = 'SELECT dataset.id, dataset.name, dataset.href, dataset.description, dataset.draft, dataset.from_video \nFROM dataset'
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f57657cf8e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedColumn) column dataset.href does not exist
E       LINE 1: SELECT dataset.id, dataset.name, dataset.href, dataset.descr...
E                                                ^
E
E       [SQL: SELECT dataset.id, dataset.name, dataset.href, dataset.description, dataset.draft, dataset.from_video
E       FROM dataset]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: ProgrammingError
---------------------------- Captured stdout setup -----------------------------
Succesfully connected to http://localhost:8000/.
_________________ test_create_model_with_href_and_description __________________

self = <sqlalchemy.engine.base.Connection object at 0x7f57639e7550>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57639e6380>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f57639e4730>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7f57639e7f10>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:

            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57639e6380>
cursor = <cursor object at 0x7f57653be2f0; closed: -1>
statement = 'SELECT model.id, model.name, model.href, model.description \nFROM model'
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f57639e4730>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedColumn: column model.href does not exist
E       LINE 1: SELECT model.id, model.name, model.href, model.description
E                                            ^

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: UndefinedColumn

The above exception was the direct cause of the following exception:

client = <velour.client.Client object at 0x7f57639e76d0>
db = <sqlalchemy.orm.session.Session object at 0x7f57639e64d0>

    def test_create_model_with_href_and_description(client: Client, db: Session):
        href = "http://a.com/b"
        description = "a description"
        client.create_model(model_name, href=href, description=description)
>       db_model = db.scalar(select(models.Model))

integration_tests/test_client.py:561:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2281: in scalar
    return self._execute_internal(
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2126: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
../velour-env/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
../velour-env/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7f57639e6380>
cursor = <cursor object at 0x7f57653be2f0; closed: -1>
statement = 'SELECT model.id, model.name, model.href, model.description \nFROM model'
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7f57639e4730>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedColumn) column model.href does not exist
E       LINE 1: SELECT model.id, model.name, model.href, model.description
E                                            ^
E
E       [SQL: SELECT model.id, model.name, model.href, model.description
E       FROM model]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

../velour-env/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: ProgrammingError
---------------------------- Captured stdout setup -----------------------------
Succesfully connected to http://localhost:8000/.
_________________ test_create_model_with_predicted_detections __________________

client = <velour.client.Client object at 0x7f5764b77f40>
gt_poly_dets1 = [GroundTruthDetection(image=Image(uid='uid1', height=900, width=300, frame=None), labels=[Label(key='k1', value='v1')]...oundary=BoundingPolygon(points=[Point(x=15, y=0), Point(x=15, y=20), Point(x=70, y=20), Point(x=70, y=0)]), bbox=None)]
pred_poly_dets = [PredictedDetection(scored_labels=[ScoredLabel(label=Label(key='k1', value='v1'), score=0.3)], image=Image(uid='uid1',...oundary=BoundingPolygon(points=[Point(x=15, y=0), Point(x=15, y=20), Point(x=70, y=20), Point(x=70, y=0)]), bbox=None)]
db = <sqlalchemy.orm.session.Session object at 0x7f5764f21960>

    def test_create_model_with_predicted_detections(
        client: Client,
        gt_poly_dets1: list[GroundTruthDetection],
        pred_poly_dets: list[PredictedDetection],
        db: Session,
    ):
>       labeled_pred_dets = _test_create_model_with_preds(
            client=client,
            gts=gt_poly_dets1,
            preds=pred_poly_dets,
            add_preds_method_name="add_predicted_detections",
            preds_model_class=models.LabeledPredictedDetection,
            preds_expected_number=2,
            expected_labels_tuples={("k1", "v1"), ("k2", "v2")},
            expected_scores={0.3, 0.98},
            db=db,
        )
E       TypeError: _test_create_model_with_preds() missing 1 required positional argument: 'add_gts_method_name'

integration_tests/test_client.py:606: TypeError
---------------------------- Captured stdout setup -----------------------------
Succesfully connected to http://localhost:8000/.
________________ test_create_model_with_predicted_segmentations ________________

client = <velour.client.Client object at 0x7f576437fe50>
gt_segs1 = [GroundTruthInstanceSegmentation(shape=[PolygonWithHole(polygon=BoundingPolygon(points=[Point(x=10, y=10), Point(x=10,..., labels=[Label(key='k1', value='v1')], image=Image(uid='uid2', height=400, width=300, frame=None), _is_instance=True)]
pred_segs = [PredictedInstanceSegmentation(mask=array([[False, False,  True, ...,  True, False, False],
       [ True,  True, Fals...el(key='k2', value='v2'), score=0.92)], image=Image(uid='uid2', height=400, width=300, frame=None), _is_instance=True)]
db = <sqlalchemy.orm.session.Session object at 0x7f576354d480>

    def test_create_model_with_predicted_segmentations(
        client: Client,
        gt_segs1: list[GroundTruthInstanceSegmentation],
        pred_segs: list[PredictedInstanceSegmentation],
        db: Session,
    ):
        """Tests that we can create a predicted segmentation from a mask array"""
>       labeled_pred_segs = _test_create_model_with_preds(
            client=client,
            gts=gt_segs1,
            preds=pred_segs,
            add_preds_method_name="add_predicted_segmentations",
            preds_model_class=models.LabeledPredictedSegmentation,
            preds_expected_number=2,
            expected_labels_tuples={("k1", "v1"), ("k2", "v2")},
            expected_scores={0.87, 0.92},
            db=db,
        )
E       TypeError: _test_create_model_with_preds() missing 1 required positional argument: 'add_gts_method_name'

integration_tests/test_client.py:823: TypeError
---------------------------- Captured stdout setup -----------------------------
Succesfully connected to http://localhost:8000/.
_______________ test_create_model_with_predicted_classifications _______________

client = <velour.client.Client object at 0x7f5764ff98d0>
gt_clfs1 = [GroundTruthImageClassification(image=Image(uid='uid5', height=400, width=300, frame=None), labels=[Label(key='k5', va...hImageClassification(image=Image(uid='uid6', height=400, width=300, frame=None), labels=[Label(key='k4', value='v4')])]
pred_clfs = [PredictedImageClassification(image=Image(uid='uid5', height=400, width=300, frame=None), scored_labels=[ScoredLabel(l...oredLabel(label=Label(key='k4', value='v4'), score=0.71), ScoredLabel(label=Label(key='k4', value='v5'), score=0.29)])]
db = <sqlalchemy.orm.session.Session object at 0x7f5764ffb0d0>

    def test_create_model_with_predicted_classifications(
        client: Client,
        gt_clfs1: list[GroundTruthDetection],
        pred_clfs: list[PredictedDetection],
        db: Session,
    ):
>       _test_create_model_with_preds(
            client=client,
            gts=gt_clfs1,
            preds=pred_clfs,
            add_preds_method_name="add_predicted_classifications",
            preds_model_class=models.PredictedImageClassification,
            preds_expected_number=5,
            expected_labels_tuples={
                ("k12", "v12"),
                ("k12", "v16"),
                ("k13", "v13"),
                ("k4", "v4"),
                ("k4", "v5"),
            },
            expected_scores={0.47, 0.53, 1.0, 0.71, 0.29},
            db=db,
        )
E       TypeError: _test_create_model_with_preds() missing 1 required positional argument: 'add_gts_method_name'

integration_tests/test_client.py:873: TypeError
---------------------------- Captured stdout setup -----------------------------
Succesfully connected to http://localhost:8000/.
________________________ test_delete_dataset_exception _________________________

client = <velour.client.Client object at 0x7f576354d4b0>

    def test_delete_dataset_exception(client: Client):
        with pytest.raises(ClientException) as exc_info:
>           client.delete_dataset("non-existent dataset")

integration_tests/test_client.py:956:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../velour-env/lib/python3.10/site-packages/velour/client.py:187: in delete_dataset
    self._requests_delete_rel_host(f"datasets/{name}")
../velour-env/lib/python3.10/site-packages/velour/client.py:172: in _requests_delete_rel_host
    return self._requests_wrapper(
../velour-env/lib/python3.10/site-packages/velour/client.py:151: in _requests_wrapper
    resp.raise_for_status()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Response [500]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""

        http_error_msg = ""
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode("utf-8")
            except UnicodeDecodeError:
                reason = self.reason.decode("iso-8859-1")
        else:
            reason = self.reason

        if 400 <= self.status_code < 500:
            http_error_msg = (
                f"{self.status_code} Client Error: {reason} for url: {self.url}"
            )

        elif 500 <= self.status_code < 600:
            http_error_msg = (
                f"{self.status_code} Server Error: {reason} for url: {self.url}"
            )

        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:8000/datasets/non-existent%20dataset

../velour-env/lib/python3.10/site-packages/requests/models.py:1021: HTTPError
---------------------------- Captured stdout setup -----------------------------
Succesfully connected to http://localhost:8000/.
_______________________________ test_evaluate_ap _______________________________

client = <velour.client.Client object at 0x7f5764f21960>
gt_dets1 = [GroundTruthDetection(image=Image(uid='uid1', height=900, width=300, frame=None), labels=[Label(key='k1', value='v1')]...frame=None), labels=[Label(key='k1', value='v1')], boundary=None, bbox=BoundingBox(xmin=15, ymin=0, xmax=70, ymax=20))]
pred_dets = [PredictedDetection(scored_labels=[ScoredLabel(label=Label(key='k1', value='v1'), score=0.3)], image=Image(uid='uid1',...ge(uid='uid2', height=400, width=300, frame=None), boundary=None, bbox=BoundingBox(xmin=15, ymin=0, xmax=70, ymax=20))]
db = <sqlalchemy.orm.session.Session object at 0x7f5764f23b20>

    def test_evaluate_ap(
        client: Client,
        gt_dets1: list[GroundTruthDetection],
        pred_dets: list[PredictedDetection],
        db: Session,
    ):
        dataset = client.create_dataset(dset_name)
        dataset.add_groundtruth(gt_dets1)
        dataset.finalize()

        model = client.create_model(model_name)
        model.add_predicted_detections(dataset, pred_dets)
        model.finalize_inferences(dataset)

        eval_job = model.evaluate_ap(
            dataset=dataset,
            iou_thresholds=[0.1, 0.6],
            ious_to_keep=[0.1, 0.6],
        )

        assert eval_job.ignored_pred_labels == [Label(key="k2", value="v2")]
        assert eval_job.missing_pred_labels == []
        assert isinstance(eval_job._id, str)

        # sleep to give the backend time to compute
        time.sleep(1)
        assert eval_job.status() == "Done"

        settings = eval_job.settings()
        settings.pop("id")
        assert settings == {
            "model_name": "test model",
            "dataset_name": "test dataset",
            "model_pred_task_type": "Bounding Box Object Detection",
            "dataset_gt_task_type": "Bounding Box Object Detection",
            "min_area": None,
            "max_area": None,
        }

        expected_metrics = [
            {
                "type": "AP",
                "value": 0.504950495049505,
                "label": {"key": "k1", "value": "v1"},
                "parameters": {
                    "iou": 0.1,
                },
            },
            {
                "type": "AP",
                "value": 0.504950495049505,
                "label": {"key": "k1", "value": "v1"},
                "parameters": {
                    "iou": 0.6,
                },
            },
            {
                "type": "mAP",
                "parameters": {"iou": 0.1},
                "value": 0.504950495049505,
            },
            {
                "type": "mAP",
                "parameters": {"iou": 0.6},
                "value": 0.504950495049505,
            },
            {
                "type": "APAveragedOverIOUs",
                "parameters": {"ious": [0.1, 0.6]},
                "value": 0.504950495049505,
                "label": {"key": "k1", "value": "v1"},
            },
            {
                "type": "mAPAveragedOverIOUs",
                "parameters": {"ious": [0.1, 0.6]},
                "value": 0.504950495049505,
            },
        ]

>       assert eval_job.metrics() == expected_metrics
E       AssertionError: assert [{'label': {'...950495049505}] == [{'label': {'...950495049505}]
E         At index 2 diff: {'type': 'mAP', 'parameters': {'iou': 0.1}, 'value': 0.504950495049505, 'label': None} != {'type': 'mAP', 'parameters': {'iou': 0.1}, 'value': 0.504950495049505}
E         Full diff:
E           [
E            {'label': {'key': 'k1',
E                       'value': 'v1'},
E             'parameters': {'iou': 0.1},
E             'type': 'AP',...
E
E         ...Full output truncated (35 lines hidden), use '-vv' to show

integration_tests/test_client.py:1039: AssertionError
---------------------------- Captured stdout setup -----------------------------
Succesfully connected to http://localhost:8000/.
----------------------------- Captured stderr call -----------------------------
Chunking (test dataset):   0%|          | 0.00/2.00 [00:00<?, ?samples/s]Chunking (test dataset): 100%|██████████| 2.00/2.00 [00:00<00:00, 112samples/s]
______________________________ test_evaluate_clf _______________________________

client = <velour.client.Client object at 0x7f5764f23370>
gt_clfs1 = [GroundTruthImageClassification(image=Image(uid='uid5', height=400, width=300, frame=None), labels=[Label(key='k5', va...hImageClassification(image=Image(uid='uid6', height=400, width=300, frame=None), labels=[Label(key='k4', value='v4')])]
pred_clfs = [PredictedImageClassification(image=Image(uid='uid5', height=400, width=300, frame=None), scored_labels=[ScoredLabel(l...oredLabel(label=Label(key='k4', value='v4'), score=0.71), ScoredLabel(label=Label(key='k4', value='v5'), score=0.29)])]
db = <sqlalchemy.orm.session.Session object at 0x7f576398d9c0>

    def test_evaluate_clf(
        client: Client,
        gt_clfs1: list[GroundTruthImageClassification],
        pred_clfs: list[PredictedImageClassification],
        db: Session,  # this is unused but putting it here since the teardown of the fixture does cleanup
    ):
        dataset = client.create_dataset(dset_name)
        dataset.add_groundtruth(gt_clfs1)
        dataset.finalize()

        model = client.create_model(model_name)
        model.add_predicted_classifications(dataset, pred_clfs)
        model.finalize_inferences(dataset)

>       eval_job = model.evaluate_classification(dataset=dataset)

integration_tests/test_client.py:1151:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../velour-env/lib/python3.10/site-packages/velour/client.py:584: in evaluate_classification
    resp = self.client._requests_post_rel_host(
../velour-env/lib/python3.10/site-packages/velour/client.py:157: in _requests_post_rel_host
    return self._requests_wrapper(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <velour.client.Client object at 0x7f5764f23370>, method_name = 'post'
endpoint = '/clf-metrics', args = ()
kwargs = {'json': {'settings': {'dataset_name': 'test dataset', 'model_name': 'test model'}}}
url = 'http://localhost:8000/clf-metrics'
requests_method = <function post at 0x7f5766a97ac0>, headers = None
resp = <Response [404]>

    def _requests_wrapper(
        self, method_name: str, endpoint: str, *args, **kwargs
    ):
        assert method_name in ["get", "post", "put", "delete"]

        url = urljoin(self.host, endpoint)
        requests_method = getattr(requests, method_name)

        if self.access_token is not None:
            headers = {"Authorization": f"Bearer {self.access_token}"}
        else:
            headers = None
        resp = requests_method(url, headers=headers, *args, **kwargs)
        if not resp.ok:
            if resp.status_code == 500:
                resp.raise_for_status()
>           raise ClientException(resp.json()["detail"])
E           velour.client.ClientException: Not Found

../velour-env/lib/python3.10/site-packages/velour/client.py:152: ClientException
---------------------------- Captured stdout setup -----------------------------
Succesfully connected to http://localhost:8000/.
----------------------------- Captured stderr call -----------------------------
Chunking (test dataset):   0%|          | 0.00/2.00 [00:00<?, ?samples/s]Chunking (test dataset): 100%|██████████| 2.00/2.00 [00:00<00:00, 87.1samples/s]
=========================== short test summary info ============================
FAILED integration_tests/test_client.py::test_create_dataset_with_href_and_description
FAILED integration_tests/test_client.py::test_create_model_with_href_and_description
FAILED integration_tests/test_client.py::test_create_model_with_predicted_detections
FAILED integration_tests/test_client.py::test_create_model_with_predicted_segmentations
FAILED integration_tests/test_client.py::test_create_model_with_predicted_classifications
FAILED integration_tests/test_client.py::test_delete_dataset_exception - requ...
FAILED integration_tests/test_client.py::test_evaluate_ap - AssertionError: a...
FAILED integration_tests/test_client.py::test_evaluate_clf - velour.client.Cl...
ERROR integration_tests/test_client.py::test_create_dataset_with_href_and_description
ERROR integration_tests/test_client.py::test_create_model_with_href_and_description
==================== 8 failed, 8 passed, 2 errors in 4.04s =====================
