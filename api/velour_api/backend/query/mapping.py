from typing import Any

from sqlalchemy import Function
from sqlalchemy.orm.attributes import InstrumentedAttribute
from sqlalchemy.orm.decl_api import DeclarativeMeta
from sqlalchemy.sql.elements import (
    Case,
    ClauseElement,
    ColumnClause,
    UnaryExpression,
)
from sqlalchemy.sql.expression import Label
from sqlalchemy.sql.schema import Table

from velour_api.backend import models


def _map_name_to_table(table_name: str) -> DeclarativeMeta | None:
    match table_name:
        case models.Dataset.__tablename__:
            return models.Dataset
        case models.Model.__tablename__:
            return models.Model
        case models.Datum.__tablename__:
            return models.Datum
        case models.Annotation.__tablename__:
            return models.Annotation
        case models.GroundTruth.__tablename__:
            return models.GroundTruth
        case models.Prediction.__tablename__:
            return models.Prediction
        case models.Label.__tablename__:
            return models.Label
        case _:
            raise ValueError(f"Unsupported table name '{table_name}'.")


def _recursive_select_to_table_names(
    argument: DeclarativeMeta
    | InstrumentedAttribute
    | UnaryExpression
    | Function
    | ColumnClause
    | ClauseElement
    | Label
    | Case
    | Table,
) -> list[str]:
    """
    Arguments are generated by select statements.
    """
    if isinstance(argument, Table):
        return [argument.name]
    if isinstance(argument, DeclarativeMeta):
        return [argument.__tablename__]  # type: ignore - sqlalchemy typing issue
    elif isinstance(argument, InstrumentedAttribute):
        return _recursive_select_to_table_names(argument.table)
    elif isinstance(argument, UnaryExpression):
        return _recursive_select_to_table_names(argument.element)
    elif isinstance(argument, ColumnClause):
        if argument.table is None:
            return []
        return _recursive_select_to_table_names(argument.table)
    elif isinstance(argument, Case):
        if argument.value is None:
            return []
        return _recursive_select_to_table_names(argument.value)
    elif isinstance(argument, Label):
        return _recursive_select_to_table_names(argument._element)
    elif isinstance(argument, Function):
        if not argument._has_args:
            return []
        table_names = []
        for clause in argument.clause_expr.element.clauses:  # type: ignore - sqlalchemy typing issue
            table_names.extend(_recursive_select_to_table_names(clause))
        return table_names
    else:
        raise NotImplementedError(
            f"Unsupported table type '{type(argument)}'."
        )


def map_arguments_to_tables(args: tuple[Any]) -> set[DeclarativeMeta]:
    tables = set()
    for argument in args:
        table_names = _recursive_select_to_table_names(argument)
        tables.update(
            [
                _map_name_to_table(name)
                for name in table_names
                if name is not None
            ]
        )
    return tables
