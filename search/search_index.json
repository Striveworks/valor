{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Velour is a centralized evaluation store which makes it easy to measure, explore, and rank model performance. Velour empowers data scientists and engineers to evaluate the performance of their machine learning pipelines and use those evaluations to make better modeling decisions in the future.</p> <p>Velour is maintained by Striveworks, a cutting-edge MLOps studio based out of Austin, Texas. We'd love to learn more about your interest in Velour and answer any questions you may have; please don't hesitate to reach out to us on Slack or GitHub.</p> <p>These docs are organized as follows:</p> <ul> <li>Overview (this page): Provides an overview of what Velour is, why it's important, and how it works.</li> <li>Getting Started: Details everything you need to get up-and-running with Velour.</li> <li>Technical Concepts: Describes the technical concepts that underpin Velour.</li> <li>Contributing &amp; Development: Explains how you can build on and contribute to Velour.</li> <li>References: Shares reference documentation for our API and Python client.</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>In this section, we'll explore what Velour is, why it's important, and provide a high-level description of how it works. This overview is also available in the following five-minute video:</p>  Your browser does not support the video tag."},{"location":"#use-cases-for-a-containterized-evaluation-store","title":"Use Cases for a Containterized Evaluation Store","text":"<p>As we've worked with dozens of data scientists and engineers on their MLOps pipelines, we identified three important questions that an effective evaluation store could help them answer. First, they wanted to understand \"Of the various models I tested for a given dataset, which one performs best?\". This is a very common and important use case, and one that is often solved in a local Jupyter notebook. Jupyter works well for this use case up until the point where a user needs to compare a new model evaluation with a very old evaluation, in which case they'll often experience traceability issues that lead to apples-to-oranges comparisons.</p> <p>Second, our users wanted to understand \"How does the performance of a particular model vary across datasets?\". We found that many practitioners use the same computer vision model (e.g., YOLOv8) for a variety of supervised learning tasks, and they needed a way to identify patterns where that particular model didn't meet expectations.</p> <p>Finally, our users wanted to understand \"How can I use my prior evaluations to pick the best model for a future ML pipeline?\". This last question requires the ability to filter previous evaluations on granular metadata (e.g., time of day, geospatial coordinates, etc.) in order to provide tailored recommendations regarding which model to pick in the future.</p> <p>With these three use cases in mind, we set out to build a centralized evaluation store that we later named Velour.</p>"},{"location":"#introducing-velour","title":"Introducing Velour","text":"<p>Velour is a centralized evaluation store which makes it easy to measure, explore, and rank model performance. Our ultimate goal with Velour is to help data scientists and engineers pick the right ML model for their specific needs. To that end, we built Velour with three design principles in mind:</p> <ul> <li>Velour works with any dataset or model: We believe Velour should be able to handle any supervised learning task that you want to throw at it. Just pass in your groundtruth annotations and predictions, describe your learning task (i.e., object detection), and Velour will do the rest. (Note: at launch, Velour will only support computer vision tasks such as image segmentation and object detection. We're confident this framework will abstract well to other supervised learning tasks, and plan to support them in later releases).</li> <li>Velour can handle any type of image, model, or dataset metadata you throw at it: Metadata is a critical component of any evaluation store as it enables the system to offer tailored model recommendations based on a user's specific needs. To that end, we built Velour to handle any metadata under the sun. Dates, geospatial coordinates, and even JSONs filled with config details are all on the table. This means you can slice-and-dice your evaluations any way you want: just pass in the right labels for your use case, define your filter (say a geographic bounding box) and you\u2019ll get back results for your specific needs.</li> <li>Velour standardizes the evaluation process: The trickiest part of comparing two different model runs is avoiding apples-to-oranges comparisons. Velour helps you audit your metrics and avoid false comparisons by versioning your uploads, storing them in a centralized location, and ensuring that you only compare runs that used the exact same filters and metrics.</li> </ul>"},{"location":"#how-it-works-an-illustrative-example","title":"How It Works: An Illustrative Example","text":"<p>Let\u2019s walk through a quick example to bring Velour to life.</p> <p>Say that you're interested in using computer vision models to detect forest fires around the world using satellite imagery. You've just been tasked with building a new ML pipeline to detect fires in an unfamiliar region of interest. How might you leverage your evaluation metrics from prior ML pipelines to understand which model will perform best for this particular use case?</p> <p></p> <p>To answer this question, we'll start by passing-in three pieces of information from each of our prior modeling runs:</p> <ul> <li>GroundTruths: First, we'll pass-in human-annotated bounding boxes to tell Velour exactly where forest fires can be found across all of the satellite images used in prior runs.</li> <li>Predictions: Next, we'll pass machine-generated predictions for each image (also in the form of bounding boxes) so that Velour can evaluate how well each model did at predicting forest fires.</li> <li>Labels: Finally, we'll pass metadata to Velour describing each of our various images (e.g., the time of day the photo was taken, the geospatial coordinates of the forest in the photo, etc.). We'll use this metadata later on in order to identify the right model for our new use case.</li> </ul> <p>Once we pass-in these three ingredients, Velour will compare all of our <code>GroundTruths</code> and <code>Predictions</code> in order to calculate various evaluation metrics (i.e., mean average precision, or mAP). These metrics, <code>Labels</code>, <code>GroundTruths</code>, and <code>Predictions</code> will all be stored in Postgres, with PostGIS support for fast geospatial lookups and geometric comparisons at a later date.</p> <p>Finally, once all of our previous pipeline runs and evaluations are stored in Velour, we can use Velour\u2019s API to specify our exact filter criteria and get back its model rankings. In this case, we can ask Velour to find us the best model for detecting forest fires at night in a 50 mile radius around (42.36, -71.03), sorted by mAP. Velour will then filter all of our stored evaluation metrics, rank each model with evaluations that meet our criteria, and send back all relevant evaluation metrics to help us determine which model to use for our new modeling pipeline.</p> <p></p>"},{"location":"#next-steps","title":"Next Steps","text":"<p>To get started with Velour, we'd recommend reviewing our sample notebooks or reading our Getting Started docs. For more detailed explainations of Velour's technical underpinnings, see our technical concepts guide.</p>"},{"location":"contributing/","title":"Contributing &amp; Development","text":"<p>We welcome all contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas aimed at improving Velour. This doc describes the high-level process for how to contribute to this repo. If you have any questions or comments on this process, please feel free to reach out to us on Slack.</p>"},{"location":"contributing/#on-github","title":"On GitHub","text":"<p>We use Git on GitHub to manage this repo, which means you will need to sign up for a free GitHub account to submit issues, ideas, and pull requests. We use Git for version control to allow contributors from all over the world to work together on this project.</p> <p>If you are new to Git, these official resources can help bring you up-to-speed:</p> <ul> <li>the GitHub documentation for forking a repo.</li> <li>the GitHub documentation for collaborating with pull requests.</li> <li>the GitHub documentation for working with forks.</li> </ul>"},{"location":"contributing/#contribution-workflow","title":"Contribution Workflow","text":"<p>Generally, the high-level workflow for contributing to this repo includes:</p> <ol> <li>Submitting an issue or enhancement request using the appropriate template on GitHub Issues</li> <li>Gathering feedback from devs and the broader community in your issue before starting to code</li> <li>Forking the Velour repo, making your proposed changes, and submitting a pull request (PR). When submitting a pull request, please be sure to:<ol> <li>Update the README.md and/or any relevant docstrings with details your change.</li> <li>Add tests where necessary.</li> <li>Run <code>pre-commit install</code> on your local repo before your last commit to ensure your changes follow our formatting guidelines.</li> <li>Double-check that your code passes all of the tests that are automated via GitHub Actions.</li> <li>Ping us on Slack to ensure timely review.</li> </ol> </li> <li>Working with repo maintainers to review and improve your PR before it is merged into the official repo.</li> </ol> <p>For questions or comments on this process, please reach out to us at any time on Slack.</p>"},{"location":"contributing/#development-tips-tricks","title":"Development Tips &amp; Tricks","text":""},{"location":"contributing/#setting-up-your-environment","title":"Setting-Up Your Environment","text":"<p>Creating a Velour-specific Python environment at the start of development can help you avoid dependency and versioning issues later on. To start, we'd recommend activating a new Python environment:</p> <pre><code># venv\npython3 -m venv .env-velour\nsource .env-velour/bin/activate\n\n# conda\nconda create --name velour python=3.11\nconda activate velour\n</code></pre> <p>Next, install pre-commit to ensure formatting consistency throughout your repo:</p> <pre><code>pip install pre-commit\npre-commit install\n</code></pre> <p>Finally, you're ready to install your client and API modules:</p> <pre><code># Install the Client module\npython -m pip install -e client/.[test]\n\n# Install the API module\npython -m pip install -e api/.[test]\n</code></pre>"},{"location":"contributing/#use-pgadmin-to-debug-postgis","title":"Use pgAdmin to Debug PostGIS","text":"<p>You can use the pgAdmin utility to debug your postgis tables as you code. Start by installing pgAdmin, then select <code>Object &gt; Register &gt; Server</code> to connect to your PostGIS container. The default connection details are listed below for convenience:</p> <pre><code>- *Host name/address*: 0.0.0.0\n- *Port*: 5432\n- *Maintenance database*: postgres\n- *Username*: postgres\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>All of our tests are run automatically via GitHub Actions on every push, so it's important to double-check that your code passes all local tests before committing your code. All of the tests below require <code>pytest</code>:</p> <pre><code>pip install pytest\n</code></pre>"},{"location":"contributing/#running-integration-tests","title":"Running integration tests","text":"<pre><code>pytest integration_tests\n</code></pre>"},{"location":"contributing/#running-bacend-unit-tests","title":"Running bacend unit tests","text":"<pre><code>pytest api/tests/unit-tests\n</code></pre>"},{"location":"contributing/#running-backkend-functional-tests","title":"Running backkend functional tests","text":"<p>Note: Functional tests require a running instance of PostgreSQL, which you can start using <code>make start-postgis-docker</code>.</p> <pre><code>POSTGRES_PASSWORD=password \\\nPOSTGRES_HOST=localhost \\\npytest api/tests/functional-tests/\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Velour is a centralized evaluation store which makes it easy to measure, explore, and rank model performance. For an overview of what Velour is and why it's important, please refer to our high-level overview.</p> <p>On this page, we'll describe how to get up and running with Velour.</p>"},{"location":"getting_started/#1-install-docker","title":"1. Install Docker","text":"<p>As a first step, be sure your machine has Docker installed. Click here for basic installation instructions.</p>"},{"location":"getting_started/#2-clone-the-repo-and-open-the-directory","title":"2. Clone the repo and open the directory","text":"<p>Choose a file in which to store Velour, then run:</p> <pre><code>git clone https://github.com/striveworks/velour\ncd velour\n</code></pre>"},{"location":"getting_started/#3-start-services","title":"3. Start services","text":"<p>Start by setting the environment variable <code>POSTGRES_PASSWORD</code> to your liking, then start Docker and build the container:</p> <pre><code>export POSTGRES_PASSWORD=\"my_password\"\ndocker compose up\n</code></pre> <p>Alternatively, you may want to run the API service locally when debugging or developing Velour. To start the service in your Terminal, you can run:</p> <pre><code>pip install api # Install the API in your python environment\n\nexport POSTGRES_PASSWORD=password \nexport POSTGRES_HOST=localhost \nmake start-postgis # Start the postgis service in Docker\nmake start-redis # Start the redis service in Docker\nmake start-server # Start the API service locally\n</code></pre>"},{"location":"getting_started/#4-use-velour","title":"4. Use Velour","text":"<p>There's two ways to access Velour: by leveraging our Python client, or by calling our REST endpoints directly.</p>"},{"location":"getting_started/#4a-using-the-python-client","title":"4a. Using the Python client","text":"<p>Let's walk-through a hypothetical example where we're trying to classify dogs and cats in a series of images. Note that all of the code below is pseudo-code for clarity; please see our \"Getting Started\" notebook for a working example.</p>"},{"location":"getting_started/#install-the-client","title":"Install the client","text":"<p>To install the Python client, you can run:</p> <pre><code>pip install velour-client\n</code></pre>"},{"location":"getting_started/#import-dependencies","title":"Import dependencies","text":"<p>Import dependencies directly from the client module using:</p> <pre><code>from velour import Dataset, Model, Datum, Annotation, GroundTruth, Prediction, Label\nfrom velour.client import Client\nfrom velour.enums import TaskType\n</code></pre>"},{"location":"getting_started/#connect-to-the-client","title":"Connect to the Client","text":"<p>The <code>velour.Client</code> class gives an object that is used to communicate with the <code>velour</code> backend.</p> <pre><code>client = Client(HOST_URL)\n</code></pre> <p>In the event that the host uses authentication, the argument <code>access_token</code> should also be passed to <code>Client</code>.</p>"},{"location":"getting_started/#pass-your-groundtruths-into-velour","title":"Pass your groundtruths into Velour","text":"<p>First, we define our <code>Dataset</code> object using <code>Dataset.create()</code>.</p> <pre><code>dataset = Dataset.create(client, \"my_dog_dataset\")\n</code></pre> <p>Next, we add one or more <code>GroundTruths</code> to our <code>Dataset</code>. These objects help Velour understand \"What is the correct classification for this particular image?\".</p> <pre><code># create a groundtruth for a set of images that we know all depict a dog\nfor image in dog_images:\n\n    # each image will have its own Datum. this object will help us connect groundtruths and predictions when it's time for evaluation\n    image.datum = Datum(\n            uid=image.name # a unique ID for each image\n            metadata=[ # the metadata we want to use to describe our image\n                schemas.MetaDatum(\n                    name=\"type\",\n                    value=\"image\",\n                ),\n                schemas.MetaDatum(\n                    name=\"height\",\n                    value=image.height,\n                ),\n                schemas.MetaDatum(\n                    name=\"width\",\n                    value=image.width,\n                ),\n            ],\n    )\n\n    groundtruth = GroundTruth(\n        datum=datum,\n        annotations=[ # a list of annotations to add to the image\n            Annotation(\n                task_type = TaskType.CLASSIFICATION,\n                labels = [\n                    schemas.Label(key=\"class\", value=\"dog\"),\n                    schemas.Label(key=\"category\", value=\"animal\"),\n                ]\n            )\n        ],\n    )\n\n    # add it to your dataset\n    dataset.add_groundtruth(groundtruth)\n\n# now that we've added all our groundtruths, we can finalize our dataset for evaluation\ndataset.finalize()\n</code></pre>"},{"location":"getting_started/#pass-your-prediction-into-velour","title":"Pass your prediction into Velour","text":"<p>Now that we've passed several images of dogs into Velour, we need to pass in model predictions before we can evaluate whether those predictions were correct or not. To accomplish this task, we start by defining our <code>Model</code>:</p> <pre><code># create model\nmodel = Model.create(client, \"my_model\")\n</code></pre> <p>Next, we tell Velour what our model predicted for each image by attaching <code>Predictions</code> to our <code>Model</code>:</p> <pre><code># pass a prediction for each image into Velour\nfor image in dog_images:\n    prediction = Prediction(\n        model=model.name,\n        datum=image.datum, # note that we use the same datums we created before\n        annoations=[\n            Annotation(\n                task_type = TaskType.CLASSIFICATION,\n                labels = [\n                    schemas.Label(key=\"class\", value=\"dog\", score=image.dog_score),\n                    schemas.Label(key=\"class\", value=\"cat\", score=image.cat_score,\n                    schemas.Label(key=\"category\", value=\"animal\", score=image.animal_score),\n                    schemas.Label(key=\"category\", value=\"vehicle\", score=image.vehicle_score),\n                ]\n            )\n        ],\n    )\n\n# prepare model for evaluation over dataset\nmodel.finalize(dataset)\n</code></pre>"},{"location":"getting_started/#run-your-evaluation-and-print-metrics","title":"Run your evaluation and print metrics","text":"<p>Now that both our <code>Dataset</code> and <code>Model</code> are finalized, we can evaluate how well our hypothetical model did at predicting whether or not each image contained a dog.</p> <pre><code># run evaluation\nevaluation = model.evaluate_classification(\n    dataset=dataset,\n    filters=[\n        Label.value = \"dog\" # with this filter, we're asking Velour to only evaluate how well our model predicted dogs in each image\n    ]\n    timeout=30, # use this argument to wait up to thirty seconds for the evaluation to complete\n)\n\n# print our classification metrics\nprint(evaluation.metrics)\n</code></pre> <p>For more examples, please see our sample notebooks.</p>"},{"location":"getting_started/#4b-using-api-endpoints","title":"4b. Using API endpoints","text":"<p>You can also leverage Velour's API without using the Python client. Click here to read up on all of our API endpoints.</p>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>For more examples, we'd recommend reviewing our sample notebooks on GitHub. For more detailed explainations of Velour's technical underpinnings, see our technical concepts guide.</p>"},{"location":"technical_concepts/","title":"Technical Concepts","text":"<p>On this page, we'll describe many of the technical concepts underpinning Velour.</p>"},{"location":"technical_concepts/#high-level-workflow","title":"High-Level Workflow","text":"<p>The typical Velour workflow involves POSTing groundtruth annotations (e.g., class labels, bounding boxes, segmentation masks, etc.) and model predictions to our API service. The service leverages these groundtruths and predictions to compute evaluation metrics, and then stores the groundtruths, predictions, and evaluation metrics centrally in Postgres. Users can also attach metadata to their <code>Datasets</code>, <code>Models</code>, <code>GroundTruths</code>, and <code>Annotations</code>; this metadata makes it easy to query for specific subsets of evaluations at a later date. Once an evaluation is stored in Velour, users can query those evaluations from Postgres via <code>GET</code> requests to the Velour API.</p> <p>Note that Velour does not store raw data (such as underlying images) or facilitate model inference. Only the following items are stored in Postgres:</p> <ul> <li>GroundTruth annotations</li> <li>Predictions outputted from a model</li> <li>Metadata from any of Velour's various classes</li> <li>Evaluation metrics computed by Velour</li> <li>State related to any of the above</li> </ul>"},{"location":"technical_concepts/#supported-task-types","title":"Supported Task Types","text":"<p>As of January 2024, Velour supports the following types of computer vision tasks and associated metrics:</p> <ul> <li>Image classification (including multi-label classification)<ul> <li>F1</li> <li>AUCROC</li> <li>Accuracy</li> <li>Precision</li> <li>Recall</li> </ul> </li> <li>Object detection<ul> <li>AP</li> <li>mAP</li> <li>AP Averaged Over IOU's</li> <li>mAP Averaged Over IOU's</li> </ul> </li> <li>Segmentation (including both instance and semantic segmentation)<ul> <li>IOU</li> <li>mIOU</li> </ul> </li> </ul> <p>We expect the Velour framework to extend well to other types of supervised learning tasks, and plan to expand our supported task types in future releases.</p>"},{"location":"technical_concepts/#components","title":"Components","text":"<p>We can think of Velour in terms of four orthogonal components:</p>"},{"location":"technical_concepts/#api","title":"API","text":"<p>The core of Velour is a backend REST API service. Users can call the API's endpoints directly (e.g., <code>POST /datasets</code>), or they can use our Python client to handle the API calls in their Python environment.  All of Velour's state is stored in Postgres and/or Redis; the API itself is completely stateless.</p> <p>Note that, after you start the API service in Dockers, you'll be able to view FastAPI's automatically generated API documentation at <code>https://&lt;your host&gt;/docs</code>.</p>"},{"location":"technical_concepts/#redis","title":"Redis","text":"<p>Redis is an open source, in-memory data store commonly used for caching. We use Redis to cache state and speed-up our evaluation calculations.</p>"},{"location":"technical_concepts/#postgresql","title":"PostgreSQL","text":"<p>PostgreSQL (a.k.a., Postgres or psql) is an open-source relational database management system. We use Postgres to store all of Velour's various objects and states.</p> <p>One of the most important reasons we chose Postgres was because of its PostGIS extension, which adds support for storing, indexing and querying geographic data. PostGIS enables Velour to quickly filter prior evaluations using geographic coordinates, which is a critically important feature for any computer vision tasks involving satellite data.</p>"},{"location":"technical_concepts/#python-client","title":"Python Client","text":"<p>Finally, we created a client to make it easier for our users to play with Velour from their Python environment. All of Velour's validations and computations are handled by our API: the Python client simply provides convenient methods to call the API's endpoints.</p>"},{"location":"technical_concepts/#classes","title":"Classes","text":"<p>The Velour API and Python client both make use of six core classes. Click here for technical references on each of these classes in our API reference docs.</p>"},{"location":"technical_concepts/#dataset","title":"<code>Dataset</code>","text":"<p>The highest-level class is a <code>Dataset</code>, which stores metadata and annotations associated with a particular set of data. Note that <code>Dataset</code> is an abstraction: you can have multiple <code>Datasets</code> which reference the exact same input data, which is useful if you need to update or version your data over time.</p> <p><code>Datasets</code> require a name at instantation, and can optionally take in various types of metadata that you want to associate with your data.</p>"},{"location":"technical_concepts/#model","title":"<code>Model</code>","text":"<p><code>Models</code> describe a particular instantiation of a machine learning model. We use the <code>Model</code> object to delineate between different models runs, or between the same model run over time. Note that <code>Models</code> aren't children of <code>Datasets</code>; you can have one <code>Model</code> contain predictions for multiple <code>Datasets</code>.</p> <p><code>Models</code> require a name at instantation, and can optionally take in various types of metadata that you want to associate with your model.</p>"},{"location":"technical_concepts/#groundtruth","title":"<code>GroundTruth</code>","text":"<p>A <code>GroundTruth</code> object clarifies what the correct prediction should be for a given piece of data (e.g., an image). For an object detection task, for example, the <code>GroundTruth</code> would store a human-drawn bounding box that, when overlayed over an object, would correctly enclose the object that we're trying to predict.</p> <p><code>GroundTruths</code> take one <code>Datum</code> and a list of <code>Annotations</code> as arguments.</p>"},{"location":"technical_concepts/#prediction","title":"<code>Prediction</code>","text":"<p>A <code>Prediction</code> object describes the output of a machine learning model. For an object detection task, for example, the <code>Prediction</code> would describe a machine-generated bounding box enclosing the area where a computer vision model believes a certain class of object can be found.</p> <p><code>Predictions</code> take one <code>Datum</code> and a list of <code>Annotations</code> as arguments.</p>"},{"location":"technical_concepts/#datum","title":"<code>Datum</code>","text":"<p><code>Datums</code> are used to store metadata about <code>GroundTruths</code> or <code>Predictions</code>. This metadata can include user-supplied metadata (e.g., JSONs filled with config details) or geospatial coordinates (via the <code>geospatial</code> argument). <code>Datums</code> provide the vital link between <code>GroundTruths</code> / <code>Predictions</code> and <code>Datasets</code>, and are useful when filtering your evaluations on specific conditions.</p> <p>A <code>Datum</code> requires a universal ID (UID) and dataset name at instantiation, along with any <code>metadata</code> or <code>geospatial</code> dictionaries that you want to associate with your <code>GroundTruth</code> or <code>Prediction</code>.</p>"},{"location":"technical_concepts/#annotation","title":"<code>Annotation</code>","text":"<p><code>Annotations</code> attach to both <code>GroundTruths</code> and <code>Predictions</code>, enabling users to add textual labels to these objects. If a <code>GroundTruth</code> depicts a bounding box around a cat, for example, the <code>Annotation</code> would be passed into the <code>GroundTruth</code> to clarify the correct label for the <code>GroundTruth</code> (e.g., <code>class=cat</code>) and any other labels the user wants to specify for that bounding box (e.g., <code>breed=tabby</code>).</p> <p><code>Annotations</code> require the user to specify their task type, labels, and metadata at instantition. Users can also pass-in various visual representations tailored to their specific task, such as bounding boxes, segmentations, or image rasters.</p>"},{"location":"technical_concepts/#authentication","title":"Authentication","text":"<p>The API can be run without authentication (by default), or with authentication provided by auth0. To enable authentication, you can either:</p> <ul> <li>Set the environment variables <code>AUTH_DOMAIN</code>, <code>AUTH_AUDIENCE</code>, and <code>AUTH_ALGORITHMS</code> manually (e.g., <code>export AUTH_DOMAIN=&lt;your domain&gt;</code>)</li> <li>Set these env variables in a file named <code>.env.auth</code>, and place that file in the <code>api</code> directory. An example of such a file would look like:</li> </ul> <pre><code>AUTH0_DOMAIN=\"velour.us.auth0.com\"\nAUTH0_AUDIENCE=\***REMOVED***\nAUTH0_ALGORITHMS=\"RS256\"\n</code></pre> <p>You can use the tests in <code>integration_tests/test_client_auth.py</code> to check whether your authenticator is running correctly.</p>"},{"location":"technical_concepts/#deployment-settings","title":"Deployment Settings","text":"<p>When deploying behind a proxy or with external routing, the environment variable <code>API_ROOT_PATH</code> environmental variable should be used to set the <code>root_path</code> arguement to <code>fastapi.FastAPI</code> (see https://fastapi.tiangolo.com/advanced/behind-a-proxy/#setting-the-root_path-in-the-fastapi-app).</p>"},{"location":"technical_concepts/#release-process","title":"Release Process","text":"<p>A release is made by publishing a tag of the form <code>vX.Y.Z</code> (e.g. <code>v0.1.0</code>). This will trigger a GitHub action that will build and publish the python client to PyPI. These releases should be created using the GitHub UI.</p>"},{"location":"references/API/Auth/","title":"Auth","text":""},{"location":"references/API/Auth/#velour_api.auth-classes","title":"Classes","text":""},{"location":"references/API/Auth/#velour_api.auth.OptionalHTTPBearer","title":"<code>velour_api.auth.OptionalHTTPBearer</code>","text":"<p>             Bases: <code>HTTPBearer</code></p> <p>Wraps HTTPBearer to allow no-auth (e.g. for testing). See https://github.com/tiangolo/fastapi/discussions/8445.</p> Source code in <code>api/velour_api/auth.py</code> <pre><code>class OptionalHTTPBearer(HTTPBearer):\n    \"\"\"Wraps HTTPBearer to allow no-auth (e.g. for testing).\n    See https://github.com/tiangolo/fastapi/discussions/8445.\n    \"\"\"\n\n    async def __call__(self, request: Request):\n        if auth_settings.no_auth:\n            return None\n        ret = await super().__call__(request)\n        verify_token(ret)\n        return ret\n</code></pre>"},{"location":"references/API/Auth/#velour_api.auth-functions","title":"Functions","text":""},{"location":"references/API/Auth/#velour_api.auth.verify_token","title":"<code>velour_api.auth.verify_token(token)</code>","text":"<p>Verifies a token. See https://auth0.com/blog/build-and-secure-fastapi-server-with-auth0/.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>HTTPAuthorizationCredentials</code> <p>The bearer token or None. If this is None and we're in a no auth setting, then an empty dictionary is returned.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The data contained in the token.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raises an HTTPException with status code 401 if there's any error in verifying or decoding the token.</p> Source code in <code>api/velour_api/auth.py</code> <pre><code>def verify_token(token: HTTPAuthorizationCredentials | None) -&gt; dict:\n    \"\"\"\n    Verifies a token. See https://auth0.com/blog/build-and-secure-fastapi-server-with-auth0/.\n\n    Parameters\n    ----------\n    token : HTTPAuthorizationCredentials\n        The bearer token or None. If this is None and we're in a no auth setting, then\n        an empty dictionary is returned.\n\n    Returns\n    -------\n    dict\n        The data contained in the token.\n\n    Raises\n    ------\n    HTTPException\n        Raises an HTTPException with status code 401 if there's any error in verifying\n        or decoding the token.\n    \"\"\"\n    if auth_settings.no_auth:\n        if token is not None:\n            logger.debug(\n                f\"`auth_settings.no_auth is true but got a token: {token}\"\n            )\n        return {}\n\n    def _handle_error(msg):\n        logger.debug(f\"error in `verify_token` with `token={token}`: {msg}\")\n        raise HTTPException(status_code=401)\n\n    try:\n        signing_key = jwks_client.get_signing_key_from_jwt(\n            token.credentials\n        ).key\n    except (\n        jwt.exceptions.PyJWKClientError,\n        jwt.exceptions.DecodeError,\n    ) as error:\n        _handle_error(error.__str__())\n\n    try:\n        payload = jwt.decode(\n            token.credentials,\n            signing_key,\n            algorithms=auth_settings.algorithms,\n            audience=auth_settings.audience,\n            issuer=auth_settings.issuer,\n        )\n    except Exception as e:\n        return _handle_error(str(e))\n\n    return payload\n</code></pre>"},{"location":"references/API/Endpoints/","title":"Endpoints","text":""},{"location":"references/API/Endpoints/#velour_api.main-functions","title":"Functions","text":""},{"location":"references/API/Endpoints/#velour_api.main.create_dataset","title":"<code>velour_api.main.create_dataset(dataset, db=Depends(get_db))</code>","text":"<p>Create a dataset in the database.</p> <p>POST Endpoint: <code>/datasets</code></p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>The dataset to add to the database.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Raises:</p> Type Description <code>HTTPException(409)</code> <p>If the dataset already exists.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.post(\n    \"/datasets\",\n    status_code=201,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Datasets\"],\n)\ndef create_dataset(dataset: schemas.Dataset, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a dataset in the database.\n\n    POST Endpoint: `/datasets`\n\n    Parameters\n    ----------\n    dataset : schemas.Dataset\n        The dataset to add to the database.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Raises\n    ------\n    HTTPException (409)\n        If the dataset already exists.\n    \"\"\"\n    try:\n        crud.create_dataset(db=db, dataset=dataset)\n    except (exceptions.DatasetAlreadyExistsError,) as e:\n        raise HTTPException(status_code=409, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.create_evaluation","title":"<code>velour_api.main.create_evaluation(job_request, background_tasks, db=Depends(get_db))</code>","text":"<p>Create a new evaluation.</p> <p>POST Endpoint: <code>/evaluations</code></p> <p>Parameters:</p> Name Type Description Default <code>job_request</code> <code>EvaluationJob</code> <p>The job request for the evaluation.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>A FastAPI <code>BackgroundTasks</code> object to process the creation asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>CreateClfMetricsResponse | CreateDetectionMetricsResponse | CreateSemanticSegmentationMetricsResponse</code> <p>An evaluation response object.</p> <p>Raises:</p> Type Description <code>HTTPException(400)</code> <p>If the task type of the evaluation job doesn't exist, or if another ValueError is thrown.</p> <code>HTTPException(405)</code> <p>If the dataset or model hasn't been finalized.</p> <code>HTTPException(409)</code> <p>If there is a state exception when creating the evaluation.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.post(\n    \"/evaluations\",\n    status_code=202,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Evaluations\"],\n)\ndef create_evaluation(\n    job_request: schemas.EvaluationJob,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(get_db),\n) -&gt; (\n    schemas.CreateClfMetricsResponse\n    | schemas.CreateDetectionMetricsResponse\n    | schemas.CreateSemanticSegmentationMetricsResponse\n):\n    \"\"\"\n    Create a new evaluation.\n\n    POST Endpoint: `/evaluations`\n\n    Parameters\n    ----------\n    job_request: schemas.EvaluationJob\n        The job request for the evaluation.\n    background_tasks: BackgroundTasks\n        A FastAPI `BackgroundTasks` object to process the creation asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    schemas.CreateClfMetricsResponse | schemas.CreateDetectionMetricsResponse | schemas.CreateSemanticSegmentationMetricsResponse\n        An evaluation response object.\n\n    Raises\n    ------\n    HTTPException (400)\n        If the task type of the evaluation job doesn't exist, or if another ValueError is thrown.\n    HTTPException (405)\n        If the dataset or model hasn't been finalized.\n    HTTPException (409)\n        If there is a state exception when creating the evaluation.\n    \"\"\"\n    try:\n        # create evaluation\n        # add metric computation to background tasks\n        if job_request.task_type == enums.TaskType.CLASSIFICATION:\n            resp = crud.create_clf_evaluation(db=db, job_request=job_request)\n            background_tasks.add_task(\n                crud.compute_clf_metrics,\n                db=db,\n                job_request=job_request,\n                job_id=resp.job_id,\n            )\n        elif job_request.task_type == enums.TaskType.DETECTION:\n            resp = crud.create_detection_evaluation(\n                db=db, job_request=job_request\n            )\n            background_tasks.add_task(\n                crud.compute_detection_metrics,\n                db=db,\n                job_request=job_request,\n                job_id=resp.job_id,\n            )\n        elif job_request.task_type == enums.TaskType.SEGMENTATION:\n            resp = crud.create_semantic_segmentation_evaluation(\n                db=db, job_request=job_request\n            )\n            background_tasks.add_task(\n                crud.compute_semantic_segmentation_metrics,\n                db=db,\n                job_request=job_request,\n                job_id=resp.job_id,\n            )\n        else:\n            raise ValueError(\n                f\"Evaluation method for task type `{str(job_request.task_type)}` does not exist.\"\n            )\n        return resp\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except (\n        exceptions.DatasetNotFinalizedError,\n        exceptions.ModelNotFinalizedError,\n    ) as e:\n        raise HTTPException(status_code=405, detail=str(e))\n    except exceptions.StateflowError as e:\n        raise HTTPException(status_code=409, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.create_groundtruths","title":"<code>velour_api.main.create_groundtruths(gt, db=Depends(get_db))</code>","text":"<p>Create a groundtruth in the database.</p> <p>POST Endpoint: <code>/groundtruths</code></p> <p>Parameters:</p> Name Type Description Default <code>gt</code> <code>GroundTruth</code> <p>The groundtruth to add to the database.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the dataset or datum doesn't exist.</p> <code>HTTPException(409)</code> <p>If the dataset has been finalized, or if the datum already exists.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.post(\n    \"/groundtruths\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"GroundTruths\"],\n)\ndef create_groundtruths(\n    gt: schemas.GroundTruth, db: Session = Depends(get_db)\n):\n    \"\"\"\n    Create a groundtruth in the database.\n\n    POST Endpoint: `/groundtruths`\n\n    Parameters\n    ----------\n    gt : schemas.GroundTruth\n        The groundtruth to add to the database.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the dataset or datum doesn't exist.\n    HTTPException (409)\n        If the dataset has been finalized, or if the datum already exists.\n    \"\"\"\n    try:\n        crud.create_groundtruth(db=db, groundtruth=gt)\n    except (\n        exceptions.DatasetDoesNotExistError,\n        exceptions.DatumDoesNotExistError,\n    ) as e:\n        raise HTTPException(status_code=404, detail=str(e))\n    except (\n        exceptions.DatasetFinalizedError,\n        exceptions.DatumAlreadyExistsError,\n    ) as e:\n        raise HTTPException(status_code=409, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.create_model","title":"<code>velour_api.main.create_model(model, db=Depends(get_db))</code>","text":"<p>Create a model in the database.</p> <p>POST Endpoint: <code>/models</code></p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to add to the database.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the dataset or datum doesn't exist.</p> <code>HTTPException(409)</code> <p>If the dataset has been finalized, or if the datum already exists.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.post(\n    \"/models\",\n    status_code=201,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Models\"],\n)\ndef create_model(model: schemas.Model, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a model in the database.\n\n    POST Endpoint: `/models`\n\n    Parameters\n    ----------\n    model : schemas.Model\n        The model to add to the database.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the dataset or datum doesn't exist.\n    HTTPException (409)\n        If the dataset has been finalized, or if the datum already exists.\n    \"\"\"\n    try:\n        crud.create_model(db=db, model=model)\n    except (\n        exceptions.DatumDoesNotExistError,\n        exceptions.DatasetDoesNotExistError,\n    ) as e:\n        raise HTTPException(status_code=404, detail=str(e))\n    except (exceptions.ModelAlreadyExistsError,) as e:\n        raise HTTPException(status_code=409, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.create_predictions","title":"<code>velour_api.main.create_predictions(pd, db=Depends(get_db))</code>","text":"<p>Create a prediction in the database.</p> <p>POST Endpoint: <code>/predictions</code></p> <p>Parameters:</p> Name Type Description Default <code>pd</code> <code>Prediction</code> <p>The prediction to add to the database.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the dataset, model, or datum doesn't exist.</p> <code>HTTPException(409)</code> <p>If the model has been finalized, or if the dataset has not been finalized.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.post(\n    \"/predictions\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Predictions\"],\n)\ndef create_predictions(\n    pd: schemas.Prediction,\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Create a prediction in the database.\n\n    POST Endpoint: `/predictions`\n\n    Parameters\n    ----------\n    pd : schemas.Prediction\n        The prediction to add to the database.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the dataset, model, or datum doesn't exist.\n    HTTPException (409)\n        If the model has been finalized, or if the dataset has not been finalized.\n    \"\"\"\n    try:\n        crud.create_prediction(db=db, prediction=pd)\n    except (\n        exceptions.DatasetDoesNotExistError,\n        exceptions.ModelDoesNotExistError,\n        exceptions.DatumDoesNotExistError,\n    ) as e:\n        raise HTTPException(status_code=404, detail=str(e))\n    except (\n        exceptions.DatasetNotFinalizedError,\n        exceptions.ModelFinalizedError,\n    ) as e:\n        raise HTTPException(status_code=409, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.delete_dataset","title":"<code>velour_api.main.delete_dataset(dataset_name, background_tasks, db=Depends(get_db))</code>","text":"<p>Delete a dataset from the database.</p> <p>DELETE Endpoint: <code>/datasets/{dataset_name}</code></p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>A FastAPI <code>BackgroundTasks</code> object to process the deletion asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the dataset doesn't exist.</p> <code>HTTPException(409)</code> <p>If the dataset isn't in the correct state to be deleted.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.delete(\n    \"/datasets/{dataset_name}\",\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Datasets\"],\n)\ndef delete_dataset(\n    dataset_name: str,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Delete a dataset from the database.\n\n    DELETE Endpoint: `/datasets/{dataset_name}`\n\n    Parameters\n    ----------\n    dataset_name : str\n        The name of the dataset.\n    background_tasks: BackgroundTasks\n        A FastAPI `BackgroundTasks` object to process the deletion asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the dataset doesn't exist.\n    HTTPException (409)\n        If the dataset isn't in the correct state to be deleted.\n    \"\"\"\n    logger.debug(f\"request to delete dataset {dataset_name}\")\n    try:\n        background_tasks.add_task(\n            crud.delete,\n            db=db,\n            dataset_name=dataset_name,\n        )\n    except exceptions.DatasetDoesNotExistError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n    except exceptions.StateflowError as e:\n        raise HTTPException(status_code=409, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.delete_model","title":"<code>velour_api.main.delete_model(model_name, db=Depends(get_db))</code>","text":"<p>Delete a model from the database.</p> <p>DELETE Endpoint: <code>/models/{model_name}</code></p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the model doesn't exist.</p> <code>HTTPException(409)</code> <p>If the model isn't in the correct state to be deleted.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.delete(\n    \"/models/{model_name}\",\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Models\"],\n)\ndef delete_model(model_name: str, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a model from the database.\n\n    DELETE Endpoint: `/models/{model_name}`\n\n    Parameters\n    ----------\n    model_name : str\n        The name of the model.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the model doesn't exist.\n    HTTPException (409)\n        If the model isn't in the correct state to be deleted.\n    \"\"\"\n    try:\n        crud.delete(db=db, model_name=model_name)\n    except exceptions.ModelDoesNotExistError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n    except exceptions.StateflowError as e:\n        raise HTTPException(status_code=409, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.finalize_dataset","title":"<code>velour_api.main.finalize_dataset(dataset_name, db=Depends(get_db))</code>","text":"<p>Finalizes a dataset for evaluation.</p> <p>PUT Endpoint: <code>/datasets/{dataset_name}/finalize</code></p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Raises:</p> Type Description <code>HTTPException(409)</code> <p>If the dataset is empty.</p> <code>HTTPException(404)</code> <p>If the dataset doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.put(\n    \"/datasets/{dataset_name}/finalize\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Datasets\"],\n)\ndef finalize_dataset(dataset_name: str, db: Session = Depends(get_db)):\n    \"\"\"\n    Finalizes a dataset for evaluation.\n\n    PUT Endpoint: `/datasets/{dataset_name}/finalize`\n\n    Parameters\n    ----------\n    dataset_name : str\n        The name of the dataset.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Raises\n    ------\n    HTTPException (409)\n        If the dataset is empty.\n    HTTPException (404)\n        If the dataset doesn't exist.\n\n    \"\"\"\n    try:\n        crud.finalize(db=db, dataset_name=dataset_name)\n    except exceptions.DatasetIsEmptyError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except exceptions.DatasetDoesNotExistError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.finalize_inferences","title":"<code>velour_api.main.finalize_inferences(dataset_name, model_name, db=Depends(get_db))</code>","text":"<p>Finalize a model prior to evaluation.</p> <p>PUT Endpoint: <code>/models/{model_name}/datasets/{dataset_name}/finalize</code></p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Raises:</p> Type Description <code>HTTPException(400)</code> <p>If the dataset or model are empty.</p> <code>HTTPException(404)</code> <p>If the dataset or model do not exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.put(\n    \"/models/{model_name}/datasets/{dataset_name}/finalize\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Models\"],\n)\ndef finalize_inferences(\n    dataset_name: str, model_name: str, db: Session = Depends(get_db)\n):\n    \"\"\"\n    Finalize a model prior to evaluation.\n\n    PUT Endpoint: `/models/{model_name}/datasets/{dataset_name}/finalize`\n\n    Parameters\n    ----------\n    dataset_name : str\n        The name of the dataset.\n    model_name : str\n        The name of the model.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n\n    Raises\n    ------\n    HTTPException (400)\n        If the dataset or model are empty.\n    HTTPException (404)\n        If the dataset or model do not exist.\n    \"\"\"\n    try:\n        crud.finalize(\n            db=db,\n            model_name=model_name,\n            dataset_name=dataset_name,\n        )\n    except (\n        exceptions.DatasetIsEmptyError,\n        exceptions.ModelIsEmptyError,\n    ) as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except (\n        exceptions.DatasetDoesNotExistError,\n        exceptions.ModelDoesNotExistError,\n    ) as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_all_labels","title":"<code>velour_api.main.get_all_labels(db=Depends(get_db))</code>","text":"<p>Fetch all labels in the database.</p> <p>GET Endpoint: <code>/labels</code></p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>List[Label]</code> <p>A list of all labels in the database.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/labels\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Labels\"],\n)\ndef get_all_labels(db: Session = Depends(get_db)) -&gt; list[schemas.Label]:\n    \"\"\"\n    Fetch all labels in the database.\n\n    GET Endpoint: `/labels`\n\n    Parameters\n    ----------\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    List[schemas.Label]\n        A list of all labels in the database.\n    \"\"\"\n    return crud.get_all_labels(db=db)\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_bulk_evaluations","title":"<code>velour_api.main.get_bulk_evaluations(datasets=None, models=None, db=Depends(get_db))</code>","text":"<p>Fetch all metrics associated with user-supplied dataset and model names. Users may query using model names, dataset names, or both. All metrics for all specified models and datasets will be returned in a list of Evaluations.</p> <p>GET Endpoint: <code>/evaluations</code></p> <p>Parameters:</p> Name Type Description Default <code>datasets</code> <code>str</code> <p>An optional set of dataset names to return metrics for</p> <code>None</code> <code>models</code> <code>str</code> <p>An optional set of model names to return metrics for</p> <code>None</code> <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>List[Evaluation]</code> <p>A list of evaluations.</p> <p>Raises:</p> Type Description <code>HTTPException(400)</code> <p>If a ValueError is thrown.</p> <code>HTTPException(404)</code> <p>If the dataset or model doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/evaluations\",\n    dependencies=[Depends(token_auth_scheme)],\n    response_model_exclude_none=True,\n    tags=[\"Evaluations\"],\n)\ndef get_bulk_evaluations(\n    datasets: str = None,\n    models: str = None,\n    db: Session = Depends(get_db),\n) -&gt; list[schemas.Evaluation]:\n    \"\"\"\n    Fetch all metrics associated with user-supplied dataset and model names. Users\n    may query using model names, dataset names, or both. All metrics for all specified\n    models and datasets will be returned in a list of Evaluations.\n\n    GET Endpoint: `/evaluations`\n\n    Parameters\n    ----------\n    datasets : str\n        An optional set of dataset names to return metrics for\n    models : str\n        An optional set of model names to return metrics for\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    List[schemas.Evaluation]\n        A list of evaluations.\n\n    Raises\n    ------\n    HTTPException (400)\n        If a ValueError is thrown.\n    HTTPException (404)\n        If the dataset or model doesn't exist.\n    \"\"\"\n    model_names = _split_query_params(models)\n    dataset_names = _split_query_params(datasets)\n\n    try:\n        return crud.get_evaluations(\n            db=db, dataset_names=dataset_names, model_names=model_names\n        )\n    except (ValueError,) as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except (\n        exceptions.DatasetDoesNotExistError,\n        exceptions.ModelDoesNotExistError,\n    ) as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_dataset","title":"<code>velour_api.main.get_dataset(dataset_name, db=Depends(get_db))</code>","text":"<p>Fetch a particular dataset from the database.</p> <p>GET Endpoint: <code>/datasets/{dataset_name}</code></p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>The requested dataset.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the dataset doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/datasets/{dataset_name}\",\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Datasets\"],\n)\ndef get_dataset(\n    dataset_name: str, db: Session = Depends(get_db)\n) -&gt; schemas.Dataset:\n    \"\"\"\n    Fetch a particular dataset from the database.\n\n    GET Endpoint: `/datasets/{dataset_name}`\n\n    Parameters\n    ----------\n    dataset_name : str\n        The name of the dataset.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    schemas.Dataset\n        The requested dataset.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the dataset doesn't exist.\n    \"\"\"\n    try:\n        return crud.get_dataset(db=db, dataset_name=dataset_name)\n    except exceptions.DatasetDoesNotExistError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_dataset_status","title":"<code>velour_api.main.get_dataset_status(dataset_name, db=Depends(get_db))</code>","text":"<p>Fetch the status of a dataset.</p> <p>GET Endpoint: <code>/datasets/{dataset_name}/status</code></p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>State</code> <p>The requested state.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the dataset doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/datasets/{dataset_name}/status\",\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Datasets\"],\n)\ndef get_dataset_status(\n    dataset_name: str, db: Session = Depends(get_db)\n) -&gt; enums.State:\n    \"\"\"\n    Fetch the status of a dataset.\n\n    GET Endpoint: `/datasets/{dataset_name}/status`\n\n    Parameters\n    ----------\n    dataset_name : str\n        The name of the dataset.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    enums.State\n        The requested state.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the dataset doesn't exist.\n    \"\"\"\n    try:\n        resp = crud.get_backend_state(dataset_name=dataset_name)\n        return resp\n    except exceptions.DatasetDoesNotExistError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_datasets","title":"<code>velour_api.main.get_datasets(db=Depends(get_db))</code>","text":"<p>Fetch all datasets from the database.</p> <p>GET Endpoint: <code>/datasets</code></p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>List[Dataset]</code> <p>A list of all datasets stored in the database.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/datasets\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Datasets\"],\n)\ndef get_datasets(db: Session = Depends(get_db)) -&gt; list[schemas.Dataset]:\n    \"\"\"\n    Fetch all datasets from the database.\n\n    GET Endpoint: `/datasets`\n\n    Parameters\n    ----------\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    List[schemas.Dataset]\n        A list of all datasets stored in the database.\n    \"\"\"\n    return crud.get_datasets(db=db)\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_datum","title":"<code>velour_api.main.get_datum(dataset_name, uid, db=Depends(get_db))</code>","text":"<p>Fetch a particular datum.</p> <p>GET Endpoint: <code>/data/dataset/{dataset_name}/uid/{uid}</code></p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>uid</code> <code>str</code> <p>The UID of the datum.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>Datum</code> <p>The requested datum.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the dataset or datum doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/data/dataset/{dataset_name}/uid/{uid}\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Datums\"],\n)\ndef get_datum(\n    dataset_name: str, uid: str, db: Session = Depends(get_db)\n) -&gt; schemas.Datum | None:\n    \"\"\"\n    Fetch a particular datum.\n\n    GET Endpoint: `/data/dataset/{dataset_name}/uid/{uid}`\n\n    Parameters\n    ----------\n    dataset_name : str\n        The name of the dataset.\n    uid : str\n        The UID of the datum.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    schemas.Datum\n        The requested datum.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the dataset or datum doesn't exist.\n    \"\"\"\n    try:\n        return crud.get_datum(\n            db=db,\n            dataset_name=dataset_name,\n            uid=uid,\n        )\n    except (\n        exceptions.DatumDoesNotExistError,\n        exceptions.DatasetDoesNotExistError,\n    ) as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_datums","title":"<code>velour_api.main.get_datums(dataset_name, db=Depends(get_db))</code>","text":"<p>Fetch all datums for a particular dataset.</p> <p>GET Endpoint: <code>/data/dataset/{dataset_name}</code></p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>List[Datum]</code> <p>A list of datums.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the dataset or datum doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/data/dataset/{dataset_name}\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Datums\"],\n)\ndef get_datums(\n    dataset_name: str, db: Session = Depends(get_db)\n) -&gt; list[schemas.Datum]:\n    \"\"\"\n    Fetch all datums for a particular dataset.\n\n    GET Endpoint: `/data/dataset/{dataset_name}`\n\n    Parameters\n    ----------\n    dataset_name : str\n        The name of the dataset.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    List[schemas.Datum]\n        A list of datums.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the dataset or datum doesn't exist.\n    \"\"\"\n    try:\n        return crud.get_datums(\n            db=db,\n            request=schemas.Filter(\n                dataset_names=[dataset_name],\n            ),\n        )\n    except (\n        exceptions.DatumDoesNotExistError,\n        exceptions.DatasetDoesNotExistError,\n    ) as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_evaluation","title":"<code>velour_api.main.get_evaluation(job_id, db=Depends(get_db))</code>","text":"<p>Fetch a particular evaluation by its job ID.</p> <p>GET Endpoint: <code>/evaluations/{job_id}</code></p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>int</code> <p>The job ID to fetch the evaluation for.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>Evaluation</code> <p>The requested evaluation.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the job doesn't have the correct state. If the job ID does not exist</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/evaluations/{job_id}\",\n    dependencies=[Depends(token_auth_scheme)],\n    response_model_exclude_none=True,\n    tags=[\"Evaluations\"],\n)\ndef get_evaluation(\n    job_id: int,\n    db: Session = Depends(get_db),\n) -&gt; schemas.Evaluation:\n    \"\"\"\n    Fetch a particular evaluation by its job ID.\n\n    GET Endpoint: `/evaluations/{job_id}`\n\n    Parameters\n    ----------\n    job_id : int\n        The job ID to fetch the evaluation for.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    schemas.Evaluation\n        The requested evaluation.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the job doesn't have the correct state.\n        If the job ID does not exist\n    \"\"\"\n    try:\n        status = crud.get_evaluation_status(\n            job_id=job_id,\n        )\n        if status != enums.JobStatus.DONE:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"No metrics for job {job_id} since its status is {status}\",\n            )\n        output = crud.get_evaluations(db=db, job_ids=[job_id])\n        return output[0]\n    except (\n        exceptions.JobDoesNotExistError,\n        AttributeError,\n    ) as e:\n        if \"'NoneType' object has no attribute 'metrics'\" in str(e):\n            raise HTTPException(\n                status_code=404, detail=\"Evaluation ID does not exist.\"\n            )\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_evaluation_job","title":"<code>velour_api.main.get_evaluation_job(job_id, db=Depends(get_db))</code>","text":"<p>Fetch an evaluation job.</p> <p>GET Endpoint: <code>/evaluations/{job_id}/settings</code></p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>int</code> <p>The job ID to fetch the evaluation for.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>EvaluationJob</code> <p>The requested EvaluationJob.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the job doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/evaluations/{job_id}/settings\",\n    dependencies=[Depends(token_auth_scheme)],\n    response_model_exclude_none=True,\n    tags=[\"Evaluations\"],\n)\ndef get_evaluation_job(\n    job_id: int,\n    db: Session = Depends(get_db),\n) -&gt; schemas.EvaluationJob:\n    \"\"\"\n    Fetch an evaluation job.\n\n    GET Endpoint: `/evaluations/{job_id}/settings`\n\n    Parameters\n    ----------\n    job_id : int\n        The job ID to fetch the evaluation for.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    schemas.EvaluationJob\n        The requested EvaluationJob.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the job doesn't exist.\n    \"\"\"\n    try:\n        if job := crud.get_evaluation_jobs(db=db, job_ids=[job_id]):\n            return job[0]\n        else:\n            raise exceptions.JobDoesNotExistError(job_id)\n    except exceptions.JobDoesNotExistError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_evaluation_jobs_for_dataset","title":"<code>velour_api.main.get_evaluation_jobs_for_dataset(dataset_name)</code>","text":"<p>Fetch all evaluation job IDs for a particular dataset.</p> <p>GET Endpoint: <code>/evaluations/dataset/{dataset_name}</code></p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of evaluation jobs for the dataset.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/evaluations/dataset/{dataset_name}\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Evaluations\"],\n)\ndef get_evaluation_jobs_for_dataset(\n    dataset_name: str,\n) -&gt; dict[str, list[int]]:\n    \"\"\"\n    Fetch all evaluation job IDs for a particular dataset.\n\n    GET Endpoint: `/evaluations/dataset/{dataset_name}`\n\n    Parameters\n    ----------\n    dataset_name : str\n        The name of the dataset.\n\n    Returns\n    -------\n    dict\n        A dictionary of evaluation jobs for the dataset.\n    \"\"\"\n    return crud.get_evaluation_ids_for_dataset(dataset_name=dataset_name)\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_evaluation_jobs_for_model","title":"<code>velour_api.main.get_evaluation_jobs_for_model(model_name)</code>","text":"<p>Fetch all evaluation job IDs for a particular model.</p> <p>GET Endpoint: <code>/evaluations/model/{model_name}</code></p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of evaluation jobs for the model.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/evaluations/model/{model_name}\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Evaluations\"],\n)\ndef get_evaluation_jobs_for_model(\n    model_name: str,\n) -&gt; dict[str, list[int]]:\n    \"\"\"\n    Fetch all evaluation job IDs for a particular model.\n\n    GET Endpoint: `/evaluations/model/{model_name}`\n\n    Parameters\n    ----------\n    model_name : str\n        The name of the model.\n\n    Returns\n    -------\n    dict\n        A dictionary of evaluation jobs for the model.\n    \"\"\"\n    return crud.get_evaluation_ids_for_model(model_name=model_name)\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_evaluation_status","title":"<code>velour_api.main.get_evaluation_status(job_id)</code>","text":"<p>Get the status of an evaluation.</p> <p>GET Endpoint: <code>/evaluations/{job_id}/status</code></p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>int</code> <p>The job ID to fetch the status of.</p> required <p>Returns:</p> Type Description <code>JobStatus</code> <p>The status of the job.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the job doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/evaluations/{job_id}/status\",\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Evaluations\"],\n)\ndef get_evaluation_status(job_id: int) -&gt; enums.JobStatus:\n    \"\"\"\n    Get the status of an evaluation.\n\n    GET Endpoint: `/evaluations/{job_id}/status`\n\n    Parameters\n    ----------\n    job_id: int\n        The job ID to fetch the status of.\n\n    Returns\n    -------\n    enums.JobStatus\n        The status of the job.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the job doesn't exist.\n    \"\"\"\n    try:\n        return crud.get_evaluation_status(\n            job_id=job_id,\n        )\n    except exceptions.JobDoesNotExistError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_groundtruth","title":"<code>velour_api.main.get_groundtruth(dataset_name, uid, db=Depends(get_db))</code>","text":"<p>Fetch a groundtruth from the database.</p> <p>GET Endpoint: <code>/groundtruths/dataset/{dataset_name}/datum/{uid}</code></p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset to fetch the groundtruth from.</p> required <code>uid</code> <code>str</code> <p>The UID of the groundtruth.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>GroundTruth</code> <p>Thee groundtruth requested by the user.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the dataset or datum does not exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/groundtruths/dataset/{dataset_name}/datum/{uid}\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"GroundTruths\"],\n)\ndef get_groundtruth(\n    dataset_name: str, uid: str, db: Session = Depends(get_db)\n) -&gt; schemas.GroundTruth | None:\n    \"\"\"\n    Fetch a groundtruth from the database.\n\n    GET Endpoint: `/groundtruths/dataset/{dataset_name}/datum/{uid}`\n\n    Parameters\n    ----------\n    dataset_name : str\n        The name of the dataset to fetch the groundtruth from.\n    uid : str\n        The UID of the groundtruth.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    schemas.GroundTruth\n        Thee groundtruth requested by the user.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the dataset or datum does not exist.\n    \"\"\"\n    try:\n        return crud.get_groundtruth(\n            db=db,\n            dataset_name=dataset_name,\n            datum_uid=uid,\n        )\n    except (\n        exceptions.DatumDoesNotExistError,\n        exceptions.DatasetDoesNotExistError,\n    ) as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_labels_from_dataset","title":"<code>velour_api.main.get_labels_from_dataset(dataset_name, db=Depends(get_db))</code>","text":"<p>Fetch all labels for a particular dataset from the database.</p> <p>GET Endpoint: <code>/labels/dataset/{dataset_name}</code></p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>List[Label]</code> <p>A list of all labels associated with the dataset in the database.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the dataset doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/labels/dataset/{dataset_name}\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Labels\"],\n)\ndef get_labels_from_dataset(\n    dataset_name: str, db: Session = Depends(get_db)\n) -&gt; list[schemas.Label]:\n    \"\"\"\n    Fetch all labels for a particular dataset from the database.\n\n    GET Endpoint: `/labels/dataset/{dataset_name}`\n\n    Parameters\n    ----------\n    dataset_name : str\n        The name of the dataset.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    List[schemas.Label]\n        A list of all labels associated with the dataset in the database.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the dataset doesn't exist.\n    \"\"\"\n    try:\n        return crud.get_dataset_labels(\n            db=db,\n            filters=schemas.Filter(\n                dataset_names=[dataset_name],\n            ),\n        )\n    except exceptions.DatasetDoesNotExistError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_labels_from_model","title":"<code>velour_api.main.get_labels_from_model(model_name, db=Depends(get_db))</code>","text":"<p>Fetch all labels for a particular model from the database.</p> <p>GET Endpoint: <code>/labels/model/{model_name}</code></p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>List[Label]</code> <p>A list of all labels associated with the model in the database.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the model doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/labels/model/{model_name}\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Labels\"],\n)\ndef get_labels_from_model(\n    model_name: str, db: Session = Depends(get_db)\n) -&gt; list[schemas.Label]:\n    \"\"\"\n    Fetch all labels for a particular model from the database.\n\n    GET Endpoint: `/labels/model/{model_name}`\n\n    Parameters\n    ----------\n    model_name : str\n        The name of the model.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    List[schemas.Label]\n        A list of all labels associated with the model in the database.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the model doesn't exist.\n    \"\"\"\n    try:\n        return crud.get_model_labels(\n            db=db,\n            filters=schemas.Filter(\n                models_names=[model_name],\n            ),\n        )\n    except exceptions.ModelDoesNotExistError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_model","title":"<code>velour_api.main.get_model(model_name, db=Depends(get_db))</code>","text":"<p>Fetch a particular model.</p> <p>GET Endpoint: <code>/models/{model_name}</code></p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>Model</code> <p>The requested model.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the model datum doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/models/{model_name}\",\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Models\"],\n)\ndef get_model(model_name: str, db: Session = Depends(get_db)) -&gt; schemas.Model:\n    \"\"\"\n    Fetch a particular model.\n\n    GET Endpoint: `/models/{model_name}`\n\n    Parameters\n    ----------\n    model_name : str\n        The name of the model.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    schemas.Model\n        The requested model.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the model datum doesn't exist.\n    \"\"\"\n    try:\n        return crud.get_model(db=db, model_name=model_name)\n    except exceptions.ModelDoesNotExistError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_models","title":"<code>velour_api.main.get_models(db=Depends(get_db))</code>","text":"<p>Fetch all models in the database.</p> <p>GET Endpoint: <code>/models</code></p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>List[Model]</code> <p>A list of models.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/models\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Models\"],\n)\ndef get_models(db: Session = Depends(get_db)) -&gt; list[schemas.Model]:\n    \"\"\"\n    Fetch all models in the database.\n\n    GET Endpoint: `/models`\n\n    Parameters\n    ----------\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    List[schemas.Model]\n        A list of models.\n    \"\"\"\n    return crud.get_models(db=db)\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.get_prediction","title":"<code>velour_api.main.get_prediction(model_name, dataset_name, uid, db=Depends(get_db))</code>","text":"<p>Fetch a prediction from the database.</p> <p>GET Endpoint: <code>/predictions/model/{model_name}/dataset/{dataset_name}/datum/{uid}</code></p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model associated with the prediction.</p> required <code>dataset_name</code> <code>str</code> <p>The name of the dataset associated with the prediction.</p> required <code>uid</code> <code>str</code> <p>The UID associated with the prediction.</p> required <code>db</code> <code>Session</code> <p>The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.</p> <code>Depends(get_db)</code> <p>Returns:</p> Type Description <code>Prediction</code> <p>The requested prediction.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If the dataset or datum doesn't exist.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/predictions/model/{model_name}/dataset/{dataset_name}/datum/{uid}\",\n    status_code=200,\n    dependencies=[Depends(token_auth_scheme)],\n    tags=[\"Predictions\"],\n)\ndef get_prediction(\n    model_name: str, dataset_name: str, uid: str, db: Session = Depends(get_db)\n) -&gt; schemas.Prediction | None:\n    \"\"\"\n    Fetch a prediction from the database.\n\n    GET Endpoint: `/predictions/model/{model_name}/dataset/{dataset_name}/datum/{uid}`\n\n    Parameters\n    ----------\n    model_name : str\n        The name of the model associated with the prediction.\n    dataset_name : str\n        The name of the dataset associated with the prediction.\n    uid : str\n        The UID associated with the prediction.\n    db : Session\n        The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n    Returns\n    -------\n    schemas.Prediction\n        The requested prediction.\n\n    Raises\n    ------\n    HTTPException (404)\n        If the dataset or datum doesn't exist.\n    \"\"\"\n    try:\n        return crud.get_prediction(\n            db=db,\n            model_name=model_name,\n            dataset_name=dataset_name,\n            datum_uid=uid,\n        )\n    except (\n        exceptions.DatumDoesNotExistError,\n        exceptions.DatasetDoesNotExistError,\n    ) as e:\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"references/API/Endpoints/#velour_api.main.user","title":"<code>velour_api.main.user(token=Depends(token_auth_scheme))</code>","text":"<p>Verify a user.</p> <p>GET Endpoint: <code>/user</code></p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>HTTPAuthorizationCredentials | None</code> <p>The auth token for the user.</p> <code>Depends(token_auth_scheme)</code> <p>Returns:</p> Type Description <code>User</code> <p>A response object containing information about the user.</p> Source code in <code>api/velour_api/main.py</code> <pre><code>@app.get(\n    \"/user\",\n    tags=[\"Authentication\"],\n)\ndef user(\n    token: HTTPAuthorizationCredentials | None = Depends(token_auth_scheme),\n) -&gt; schemas.User:\n    \"\"\"\n    Verify a user.\n\n    GET Endpoint: `/user`\n\n    Parameters\n    ----------\n    token: HTTPAuthorizationCredentials\n        The auth token for the user.\n\n    Returns\n    -------\n    schemas.User\n        A response object containing information about the user.\n    \"\"\"\n    token_payload = auth.verify_token(token)\n    return schemas.User(email=token_payload.get(\"email\"))\n</code></pre>"},{"location":"references/API/Exceptions/","title":"Exceptions","text":"<p>Dataset</p>"},{"location":"references/API/Exceptions/#velour_api.exceptions-classes","title":"Classes","text":""},{"location":"references/API/Exceptions/#velour_api.exceptions.AnnotationAlreadyExistsError","title":"<code>velour_api.exceptions.AnnotationAlreadyExistsError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to create an <code>Annotation</code> that already exists.</p> Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class AnnotationAlreadyExistsError(Exception):\n    \"\"\"Raises an exception if the user tries to create an `Annotation` that already exists.\"\"\"\n\n    pass\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.DatasetAlreadyExistsError","title":"<code>velour_api.exceptions.DatasetAlreadyExistsError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to create a dataset with a name that already exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class DatasetAlreadyExistsError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to create a dataset with a name that already exists.\n\n    Parameters\n    -------\n    name : str\n        The name of the dataset.\n    \"\"\"\n\n    def __init__(self, name: str):\n        return super().__init__(f\"Dataset with name `{name}` already exists.\")\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.DatasetDoesNotExistError","title":"<code>velour_api.exceptions.DatasetDoesNotExistError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to manipulate a dataset that doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class DatasetDoesNotExistError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to manipulate a dataset that doesn't exist.\n\n    Parameters\n    -------\n    name : str\n        The name of the dataset.\n    \"\"\"\n\n    def __init__(self, name: str):\n        return super().__init__(f\"Dataset with name `{name}` does not exist.\")\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.DatasetFinalizedError","title":"<code>velour_api.exceptions.DatasetFinalizedError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to add groundtruths to a dataset that has already been finalized.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class DatasetFinalizedError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to add groundtruths to a dataset that has already been finalized.\n\n    Parameters\n    -------\n    name : str\n        The name of the dataset.\n    \"\"\"\n\n    def __init__(self, name: str):\n        return super().__init__(\n            f\"cannot edit dataset `{name}` since it has been finalized.\"\n        )\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.DatasetIsEmptyError","title":"<code>velour_api.exceptions.DatasetIsEmptyError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to manipulate an empty dataset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class DatasetIsEmptyError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to manipulate an empty dataset.\n\n    Parameters\n    -------\n    name : str\n        The name of the dataset.\n    \"\"\"\n\n    def __init__(self, name: str):\n        return super().__init__(\n            f\"Dataset with name `{name}` contains no groundtruths.\"\n        )\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.DatasetNotFinalizedError","title":"<code>velour_api.exceptions.DatasetNotFinalizedError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to process a dataset that hasn't been finalized.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class DatasetNotFinalizedError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to process a dataset that hasn't been finalized.\n\n    Parameters\n    -------\n    name : str\n        The name of the dataset.\n    \"\"\"\n\n    def __init__(self, name: str):\n        return super().__init__(\n            f\"cannot evaluate dataset `{name}` since it has not been finalized.\"\n        )\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.DatumAlreadyExistsError","title":"<code>velour_api.exceptions.DatumAlreadyExistsError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to create a datum that already exists.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The uid of the datum.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class DatumAlreadyExistsError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to create a datum that already exists.\n\n    Parameters\n    -------\n    uid : str\n        The uid of the datum.\n    \"\"\"\n\n    def __init__(self, uid: str):\n        return super().__init__(f\"Datum with uid: `{uid}` already exists.\")\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.DatumDoesNotBelongToDatasetError","title":"<code>velour_api.exceptions.DatumDoesNotBelongToDatasetError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to manipulate a datum that doesn't exist on a particular dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>datum_uid</code> <code>str</code> <p>The uid of the datum.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class DatumDoesNotBelongToDatasetError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to manipulate a datum that doesn't exist on a particular dataset.\n\n    Parameters\n    -------\n    dataset_name : str\n        The name of the dataset.\n    datum_uid : str\n        The uid of the datum.\n    \"\"\"\n\n    def __init__(self, dataset_name: str, datum_uid: str):\n        return super().__init__(\n            f\"Datum with uid: `{datum_uid}` does not belong to dataset `{dataset_name}`.\"\n        )\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.DatumDoesNotExistError","title":"<code>velour_api.exceptions.DatumDoesNotExistError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to manipulate a datum that doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The uid of the datum.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class DatumDoesNotExistError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to manipulate a datum that doesn't exist.\n\n    Parameters\n    -------\n    uid : str\n        The uid of the datum.\n    \"\"\"\n\n    def __init__(self, uid: str):\n        return super().__init__(f\"Datum with uid `{uid}` does not exist.\")\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.GroundTruthAlreadyExistsError","title":"<code>velour_api.exceptions.GroundTruthAlreadyExistsError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to create a <code>GroundTruth</code> that already exists.</p> Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class GroundTruthAlreadyExistsError(Exception):\n    \"\"\"Raises an exception if the user tries to create a `GroundTruth` that already exists.\"\"\"\n\n    pass\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.JobDoesNotExistError","title":"<code>velour_api.exceptions.JobDoesNotExistError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user queries a job ID which doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the job.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class JobDoesNotExistError(Exception):\n    \"\"\"\n    Raises an exception if the user queries a job ID which doesn't exist.\n\n    Parameters\n    -------\n    id : str\n        The id of the job.\n    \"\"\"\n\n    def __init__(self, id: str):\n        return super().__init__(f\"job with id `{id}` does not exist\")\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.JobStateError","title":"<code>velour_api.exceptions.JobStateError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to manipulate a job at the wrong time (e.g., deleting a job that is currently processing).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the job.</p> required <code>msg</code> <code>str</code> <p>The message of the stateflow error.</p> <code>'none'</code> Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class JobStateError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to manipulate a job at the wrong time (e.g., deleting a job that is currently processing).\n\n    Parameters\n    -------\n    id : str\n        The id of the job.\n    msg : str\n        The message of the stateflow error.\n    \"\"\"\n\n    def __init__(self, id: int, msg: str = \"none\"):\n        return super().__init__(f\"state error with job id: `{id}`, msg: {msg}\")\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.ModelAlreadyExistsError","title":"<code>velour_api.exceptions.ModelAlreadyExistsError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to create a model using a name that already exists in the database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the model.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class ModelAlreadyExistsError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to create a model using a name that already exists in the database.\n\n    Parameters\n    -------\n    name : str\n        The name of the model.\n    \"\"\"\n\n    def __init__(self, name: str):\n        return super().__init__(f\"Model with name `{name}` already exists.\")\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.ModelDoesNotExistError","title":"<code>velour_api.exceptions.ModelDoesNotExistError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to manipulate a model that doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the model.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class ModelDoesNotExistError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to manipulate a model that doesn't exist.\n\n    Parameters\n    -------\n    name : str\n        The name of the model.\n    \"\"\"\n\n    def __init__(self, name: str):\n        return super().__init__(f\"Model with name `{name}` does not exist.\")\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.ModelFinalizedError","title":"<code>velour_api.exceptions.ModelFinalizedError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to add predictions to a model that has been finalized.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of the model.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class ModelFinalizedError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to add predictions to a model that has been finalized.\n\n    Parameters\n    -------\n    dataset_name : str\n        The name of the dataset.\n    model_name : str\n        The name of the model.\n    \"\"\"\n\n    def __init__(self, *, dataset_name: str, model_name: str):\n        return super().__init__(\n            f\"cannot edit inferences for model`{model_name}` on dataset `{dataset_name}` since it has been finalized\"\n        )\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.ModelInferencesDoNotExist","title":"<code>velour_api.exceptions.ModelInferencesDoNotExist</code>","text":"<p>             Bases: <code>Exception</code></p> Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class ModelInferencesDoNotExist(Exception):\n    def __init__(self, *, dataset_name: str, model_name: str):\n        \"\"\"\n        Raises an exception if the user tries to manipulate an inference that doesn't exist.\n\n        Parameters\n        -------\n        dataset_name : str\n            The name of the dataset.\n        model_name : str\n            The name of the model.\n        \"\"\"\n\n        return super().__init__(\n            f\"inferences for model `{model_name}` over dataset `{dataset_name}` do not exist.\"\n        )\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.ModelInferencesDoNotExist-functions","title":"Functions","text":""},{"location":"references/API/Exceptions/#velour_api.exceptions.ModelInferencesDoNotExist.__init__","title":"<code>velour_api.exceptions.ModelInferencesDoNotExist.__init__(*, dataset_name, model_name)</code>","text":"<p>Raises an exception if the user tries to manipulate an inference that doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of the model.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>def __init__(self, *, dataset_name: str, model_name: str):\n    \"\"\"\n    Raises an exception if the user tries to manipulate an inference that doesn't exist.\n\n    Parameters\n    -------\n    dataset_name : str\n        The name of the dataset.\n    model_name : str\n        The name of the model.\n    \"\"\"\n\n    return super().__init__(\n        f\"inferences for model `{model_name}` over dataset `{dataset_name}` do not exist.\"\n    )\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.ModelIsEmptyError","title":"<code>velour_api.exceptions.ModelIsEmptyError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to manipulate an empty model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the model.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class ModelIsEmptyError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to manipulate an empty model.\n\n    Parameters\n    -------\n    name : str\n        The name of the model.\n    \"\"\"\n\n    def __init__(self, name: str):\n        return super().__init__(\n            f\"Model with name `{name}` contains no inferences.\"\n        )\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.ModelNotFinalizedError","title":"<code>velour_api.exceptions.ModelNotFinalizedError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to manipulate a model that hasn't been finalized.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of the model.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class ModelNotFinalizedError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to manipulate a model that hasn't been finalized.\n\n    Parameters\n    -------\n    dataset_name : str\n        The name of the dataset.\n    model_name : str\n        The name of the model.\n    \"\"\"\n\n    def __init__(self, *, dataset_name: str, model_name: str):\n        return super().__init__(\n            f\"cannot evaluate inferences for model `{model_name}` on dataset `{dataset_name}` since it has not been finalized.\"\n        )\n</code></pre>"},{"location":"references/API/Exceptions/#velour_api.exceptions.StateflowError","title":"<code>velour_api.exceptions.StateflowError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raises an exception if the user tries to take an action that violates the correct state order.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message of the stateflow error.</p> required Source code in <code>api/velour_api/exceptions.py</code> <pre><code>class StateflowError(Exception):\n    \"\"\"\n    Raises an exception if the user tries to take an action that violates the correct state order.\n\n    Parameters\n    -------\n    msg : str\n        The message of the stateflow error.\n    \"\"\"\n\n    def __init__(self, msg: str):\n        return super().__init__(msg)\n</code></pre>"},{"location":"references/API/Stateflow/","title":"Stateflow","text":""},{"location":"references/API/Stateflow/#velour_api.backend.stateflow-functions","title":"Functions","text":""},{"location":"references/API/Stateflow/#velour_api.backend.stateflow.computation","title":"<code>velour_api.backend.stateflow.computation(fn)</code>","text":"<p>Update the state of an EvaluationJob.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>callable</code> <p>An input function to wrap around.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If input args aren't explicitly defined.</p> <code>ValueError</code> <p>If the job request is defined, but isn't the right type. If the job request isn't defined. If the job is missing an ID.</p> Source code in <code>api/velour_api/backend/stateflow.py</code> <pre><code>def computation(fn: callable) -&gt; callable:\n    \"\"\"\n    Update the state of an EvaluationJob.\n\n    Parameters\n    ----------\n    fn : callable\n        An input function to wrap around.\n\n    Raises\n    ------\n    RuntimeError\n        If input args aren't explicitly defined.\n    ValueError\n        If the job request is defined, but isn't the right type.\n        If the job request isn't defined.\n        If the job is missing an ID.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        # input args should be explicitly defined\n        if len(args) != 0 and len(kwargs) != 2:\n            raise RuntimeError\n\n        # unpack job_request\n        if \"job_request\" in kwargs:\n            if isinstance(kwargs[\"job_request\"], schemas.EvaluationJob):\n                dataset_name = kwargs[\"job_request\"].dataset\n                model_name = kwargs[\"job_request\"].model\n            else:\n                raise ValueError(\n                    \"job_request object must be of type `schemas.EvaluationJob`\"\n                )\n        else:\n            raise ValueError(\n                \"missing job_request which should be an evaluation request type (e.g. `schemas.EvaluationJob`)\"\n            )\n\n        # unpack job_id\n        if \"job_id\" in kwargs:\n            job_id = kwargs[\"job_id\"]\n        else:\n            raise ValueError(\"missing job_id\")\n\n        if get_stateflow().get_job_status(job_id) == JobStatus.DONE:\n            _update_backend_state(\n                status=State.READY,\n                dataset_name=dataset_name,\n                model_name=model_name,\n            )\n            return\n\n        # set up stateflow for pre-computation\n        _update_backend_state(\n            status=State.EVALUATE,\n            dataset_name=dataset_name,\n            model_name=model_name,\n        )\n        _update_job_state(\n            dataset_name=dataset_name,\n            model_name=model_name,\n            job_id=job_id,\n            status=JobStatus.PROCESSING,\n        )\n\n        try:\n            # compute\n            result = fn(*args, **kwargs)\n        except Exception as e:\n            # failed\n            _update_job_state(\n                dataset_name=dataset_name,\n                model_name=model_name,\n                job_id=job_id,\n                status=JobStatus.FAILED,\n            )\n            logger.debug(f\"job with id `{job_id}` failed. Exception: {str(e)}\")\n            raise e\n        else:\n            # success\n            _update_job_state(\n                dataset_name=dataset_name,\n                model_name=model_name,\n                job_id=job_id,\n                status=JobStatus.DONE,\n            )\n        finally:\n            # return to ready state\n            _update_backend_state(\n                status=State.READY,\n                dataset_name=dataset_name,\n                model_name=model_name,\n            )\n\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"references/API/Stateflow/#velour_api.backend.stateflow.create","title":"<code>velour_api.backend.stateflow.create(fn)</code>","text":"<p>Set the state of a dataset and/or model object to State.CREATE.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>callable</code> <p>An input function to wrap around. Sets the state of any datasets or models mentioned in the function's kwargs.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If input args aren't explicitly defined.</p> Source code in <code>api/velour_api/backend/stateflow.py</code> <pre><code>def create(fn: callable) -&gt; callable:\n    \"\"\"\n    Set the state of a dataset and/or model object to State.CREATE.\n\n    Parameters\n    ----------\n    fn : callable\n        An input function to wrap around. Sets the state of any datasets or models mentioned in the function's kwargs.\n\n    Raises\n    ------\n    RuntimeError\n        If input args aren't explicitly defined.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        # input args should be explicitly defined\n        if len(args) != 0 and len(kwargs) != 2:\n            raise RuntimeError(\"input arguments should be explicitly defined\")\n\n        # unpack args\n        dataset_name = None\n        model_name = None\n        state = State.CREATE\n\n        # create grouping\n        if \"dataset\" in kwargs:\n            if isinstance(kwargs[\"dataset\"], schemas.Dataset):\n                dataset_name = kwargs[\"dataset\"].name\n                model_name = None\n                state = State.NONE\n        elif \"model\" in kwargs:\n            if isinstance(kwargs[\"model\"], schemas.Dataset):\n                dataset_name = None\n                model_name = kwargs[\"model\"].name\n                state = State.NONE\n        # create annotations\n        elif \"groundtruth\" in kwargs:\n            if isinstance(kwargs[\"groundtruth\"], schemas.GroundTruth):\n                dataset_name = kwargs[\"groundtruth\"].datum.dataset\n                model_name = None\n        elif \"prediction\" in kwargs:\n            if isinstance(kwargs[\"prediction\"], schemas.Prediction):\n                dataset_name = kwargs[\"prediction\"].datum.dataset\n                model_name = kwargs[\"prediction\"].model\n\n        _update_backend_state(\n            status=state,\n            dataset_name=dataset_name,\n            model_name=model_name,\n        )\n        return fn(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"references/API/Stateflow/#velour_api.backend.stateflow.delete","title":"<code>velour_api.backend.stateflow.delete(fn)</code>","text":"<p>Set the state of a dataset and/or model object to State.DELETE.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>callable</code> <p>An input function to wrap around. Sets the state of any datasets or models mentioned in the function's kwargs.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If input args aren't explicitly defined.</p> Source code in <code>api/velour_api/backend/stateflow.py</code> <pre><code>def delete(fn: callable) -&gt; callable:\n    \"\"\"\n    Set the state of a dataset and/or model object to State.DELETE.\n\n    Parameters\n    ----------\n    fn : callable\n        An input function to wrap around. Sets the state of any datasets or models mentioned in the function's kwargs.\n\n    Raises\n    ------\n    RuntimeError\n        If input args aren't explicitly defined.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        # input args should be explicitly defined\n        if len(args) != 0 and len(kwargs) != 3:\n            raise RuntimeError\n\n        # unpack dataset\n        dataset_name = None\n        if \"dataset_name\" in kwargs:\n            dataset_name = kwargs[\"dataset_name\"]\n\n        # unpack model\n        model_name = None\n        if \"model_name\" in kwargs:\n            model_name = kwargs[\"model_name\"]\n\n        _update_backend_state(\n            status=State.DELETE,\n            dataset_name=dataset_name,\n            model_name=model_name,\n        )\n\n        try:\n            result = fn(*args, **kwargs)\n        finally:\n            _remove_backend_state(\n                dataset_name=dataset_name, model_name=model_name\n            )\n\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"references/API/Stateflow/#velour_api.backend.stateflow.evaluate","title":"<code>velour_api.backend.stateflow.evaluate(fn)</code>","text":"<p>Set the state of a dataset and/or model object to State.EVALUATE.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>callable</code> <p>An input function to wrap around. Sets the state of any datasets or models mentioned in the function's kwargs.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If input args aren't explicitly defined.</p> Source code in <code>api/velour_api/backend/stateflow.py</code> <pre><code>def evaluate(fn: callable) -&gt; callable:\n    \"\"\"\n    Set the state of a dataset and/or model object to State.EVALUATE.\n\n    Parameters\n    ----------\n    fn : callable\n        An input function to wrap around. Sets the state of any datasets or models mentioned in the function's kwargs.\n\n    Raises\n    ------\n    RuntimeError\n        If input args aren't explicitly defined.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        # input args should be explicitly defined\n        if len(args) != 0 and len(kwargs) != 2:\n            raise RuntimeError\n\n        # unpack args\n        dataset_name = None\n        model_name = None\n        if \"job_request\" in kwargs:\n            dataset_name = kwargs[\"job_request\"].dataset\n            model_name = kwargs[\"job_request\"].model\n\n        _update_backend_state(\n            status=State.EVALUATE,\n            dataset_name=dataset_name,\n            model_name=model_name,\n        )\n\n        try:\n            results = fn(*args, **kwargs)\n        except Exception as e:\n            _update_backend_state(\n                status=State.READY,\n                dataset_name=dataset_name,\n                model_name=model_name,\n            )\n            logger.debug(f\"Evaluation request failed. Exception: {str(e)}\")\n            raise e\n\n        if hasattr(results, \"job_id\"):\n            _update_job_state(\n                dataset_name=dataset_name,\n                model_name=model_name,\n                job_id=results.job_id,\n                status=JobStatus.PENDING,\n            )\n\n        return results\n\n    return wrapper\n</code></pre>"},{"location":"references/API/Stateflow/#velour_api.backend.stateflow.finalize","title":"<code>velour_api.backend.stateflow.finalize(fn)</code>","text":"<p>Set the state of a dataset and/or model object to State.Finalize.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>callable</code> <p>An input function to wrap around. Sets the state of any datasets or models mentioned in the function's kwargs.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If input args aren't explicitly defined.</p> Source code in <code>api/velour_api/backend/stateflow.py</code> <pre><code>def finalize(fn: callable) -&gt; callable:\n    \"\"\"\n    Set the state of a dataset and/or model object to State.Finalize.\n\n    Parameters\n    ----------\n    fn : callable\n        An input function to wrap around. Sets the state of any datasets or models mentioned in the function's kwargs.\n\n    Raises\n    ------\n    RuntimeError\n        If input args aren't explicitly defined.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        # input args should be explicitly defined\n        if len(args) != 0 and len(kwargs) != 3:\n            raise RuntimeError\n\n        # unpack dataset\n        dataset_name = None\n        if \"dataset_name\" in kwargs:\n            dataset_name = kwargs[\"dataset_name\"]\n\n        # unpack model\n        model_name = None\n        if \"model_name\" in kwargs:\n            model_name = kwargs[\"model_name\"]\n\n        _update_backend_state(\n            status=State.READY,\n            dataset_name=dataset_name,\n            model_name=model_name,\n        )\n        return fn(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/","title":"Query Functions","text":""},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query-functions","title":"Functions","text":""},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.create_dataset","title":"<code>velour_api.backend.query.create_dataset(db, dataset)</code>","text":"<p>Creates a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>dataset</code> <code>Dataset</code> <p>The dataset to create.</p> required Source code in <code>api/velour_api/backend/query/dataset.py</code> <pre><code>def create_dataset(\n    db: Session,\n    dataset: schemas.Dataset,\n):\n    \"\"\"\n    Creates a dataset.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    dataset : schemas.Dataset\n        The dataset to create.\n    \"\"\"\n    shape = (\n        schemas.GeoJSON.from_dict(data=dataset.geospatial).shape().wkt()\n        if dataset.geospatial\n        else None\n    )\n\n    try:\n        row = models.Dataset(\n            name=dataset.name, meta=dataset.metadata, geo=shape\n        )\n        db.add(row)\n        db.commit()\n        return row\n    except IntegrityError:\n        db.rollback()\n        raise exceptions.DatasetAlreadyExistsError(dataset.name)\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.create_groundtruth","title":"<code>velour_api.backend.query.create_groundtruth(db, groundtruth)</code>","text":"<p>Creates a groundtruth.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>groundtruth</code> <code>GroundTruth</code> <p>The groundtruth to create.</p> required Source code in <code>api/velour_api/backend/query/groundtruth.py</code> <pre><code>def create_groundtruth(\n    db: Session,\n    groundtruth: schemas.GroundTruth,\n):\n    \"\"\"\n    Creates a groundtruth.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    groundtruth: schemas.GroundTruth\n        The groundtruth to create.\n    \"\"\"\n    # create datum\n    datum = core.create_datum(db, groundtruth.datum)\n\n    annotation_list, label_list = core.create_annotations_and_labels(\n        db=db, annotations=groundtruth.annotations, datum=datum\n    )\n\n    rows = []\n\n    for i, annotation in enumerate(annotation_list):\n        for label in label_list[i]:\n            rows += [\n                models.GroundTruth(\n                    annotation_id=annotation.id, label_id=label.id\n                )\n            ]\n\n    try:\n        db.add_all(rows)\n        db.commit()\n    except IntegrityError:\n        db.rollback()\n        raise exceptions.GroundTruthAlreadyExistsError\n\n    return rows\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.create_model","title":"<code>velour_api.backend.query.create_model(db, model)</code>","text":"<p>Creates a model.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>model</code> <code>Model</code> <p>The model to create.</p> required Source code in <code>api/velour_api/backend/query/model.py</code> <pre><code>def create_model(\n    db: Session,\n    model: schemas.Model,\n):\n    \"\"\"\n    Creates a model.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    model : schemas.Model\n        The model to create.\n    \"\"\"\n    shape = (\n        schemas.GeoJSON.from_dict(data=model.geospatial).shape().wkt()\n        if model.geospatial\n        else None\n    )\n\n    try:\n        row = models.Model(name=model.name, meta=model.metadata, geo=shape)\n        db.add(row)\n        db.commit()\n        return row\n    except IntegrityError:\n        db.rollback()\n        raise exceptions.ModelAlreadyExistsError(model.name)\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.create_prediction","title":"<code>velour_api.backend.query.create_prediction(db, prediction)</code>","text":"<p>Creates a prediction.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>prediction</code> <code>Prediction</code> <p>The prediction to create.</p> required Source code in <code>api/velour_api/backend/query/prediction.py</code> <pre><code>def create_prediction(\n    db: Session,\n    prediction: schemas.Prediction,\n):\n    \"\"\"\n    Creates a prediction.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    prediction : schemas.Prediction\n        The prediction to create.\n    \"\"\"\n    # retrieve existing table entries\n    model = core.get_model(db, name=prediction.model)\n    dataset = core.get_dataset(db, name=prediction.datum.dataset)\n    datum = core.get_datum(db, dataset_id=dataset.id, uid=prediction.datum.uid)\n\n    annotation_list, label_list = core.create_annotations_and_labels(\n        db=db, annotations=prediction.annotations, datum=datum, model=model\n    )\n\n    # create tables entries\n    rows = []\n\n    for i, annotation in enumerate(annotation_list):\n        for j, label in enumerate(label_list[i]):\n            rows += [\n                models.Prediction(\n                    annotation_id=annotation.id,\n                    label_id=label.id,\n                    score=prediction.annotations[i].labels[j].score,\n                )\n            ]\n\n    try:\n        db.add_all(rows)\n        db.commit()\n    except IntegrityError as e:\n        db.rollback()\n        raise e\n    return rows\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.delete_dataset","title":"<code>velour_api.backend.query.delete_dataset(db, name)</code>","text":"<p>Delete a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>name</code> <code>str</code> <p>The name of the dataset.</p> required Source code in <code>api/velour_api/backend/query/dataset.py</code> <pre><code>def delete_dataset(\n    db: Session,\n    name: str,\n):\n    \"\"\"\n    Delete a dataset.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    name : str\n        The name of the dataset.\n    \"\"\"\n    dataset = core.get_dataset(db, name=name)\n    try:\n        db.delete(dataset)\n        db.commit()\n    except IntegrityError as e:\n        db.rollback()\n        raise e\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.delete_model","title":"<code>velour_api.backend.query.delete_model(db, name)</code>","text":"<p>Delete a model.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>name</code> <code>str</code> <p>The name of the model.</p> required Source code in <code>api/velour_api/backend/query/model.py</code> <pre><code>def delete_model(\n    db: Session,\n    name: str,\n):\n    \"\"\"\n    Delete a model.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    name : str\n        The name of the model.\n    \"\"\"\n    model = core.get_model(db, name=name)\n    try:\n        db.delete(model)\n        db.commit()\n    except IntegrityError:\n        db.rollback()\n        raise RuntimeError\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_dataset","title":"<code>velour_api.backend.query.get_dataset(db, name)</code>","text":"<p>Fetch a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>name</code> <code>str</code> <p>The name of the dataset.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>The requested dataset.</p> Source code in <code>api/velour_api/backend/query/dataset.py</code> <pre><code>def get_dataset(\n    db: Session,\n    name: str,\n) -&gt; schemas.Dataset:\n    \"\"\"\n    Fetch a dataset.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    name : str\n        The name of the dataset.\n\n    Returns\n    ----------\n    schemas.Dataset\n        The requested dataset.\n    \"\"\"\n    dataset = core.get_dataset(db, name=name)\n    geo_dict = (\n        json.loads(db.scalar(ST_AsGeoJSON(dataset.geo))) if dataset.geo else {}\n    )\n    return schemas.Dataset(\n        id=dataset.id,\n        name=dataset.name,\n        metadata=dataset.meta,\n        geospatial=geo_dict,\n    )\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_datasets","title":"<code>velour_api.backend.query.get_datasets(db)</code>","text":"<p>Fetch all datasets.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <p>Returns:</p> Type Description <code>List[Dataset]</code> <p>A list of all datasets.</p> Source code in <code>api/velour_api/backend/query/dataset.py</code> <pre><code>def get_datasets(\n    db: Session,\n) -&gt; list[schemas.Dataset]:\n    \"\"\"\n    Fetch all datasets.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n\n    Returns\n    ----------\n    List[schemas.Dataset]\n        A list of all datasets.\n    \"\"\"\n    return [\n        get_dataset(db, name)\n        for name in db.scalars(select(models.Dataset.name)).all()\n    ]\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_datums","title":"<code>velour_api.backend.query.get_datums(db, filters=None)</code>","text":"<p>Fetch all datums.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>filters</code> <code>Filter</code> <p>An optional filter to apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Datum]</code> <p>A list of all datums.</p> Source code in <code>api/velour_api/backend/query/dataset.py</code> <pre><code>def get_datums(\n    db: Session,\n    filters: schemas.Filter | None = None,\n) -&gt; list[schemas.Datum]:\n    \"\"\"\n    Fetch all datums.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    filters : schemas.Filter\n        An optional filter to apply.\n\n    Returns\n    ----------\n    List[schemas.Datum]\n        A list of all datums.\n    \"\"\"\n    q = ops.Query(models.Datum).filter(filters).any()\n    datums = db.query(q).all()\n\n    output = []\n\n    for datum in datums:\n        geo_dict = (\n            json.loads(db.scalar(ST_AsGeoJSON(datum.geo))) if datum.geo else {}\n        )\n\n        output.append(\n            schemas.Datum(\n                dataset=db.scalar(\n                    select(models.Dataset.name).where(\n                        models.Dataset.id == datum.dataset_id\n                    )\n                ),\n                uid=datum.uid,\n                metadata=datum.meta,\n                geospatial=geo_dict,\n            )\n        )\n    return output\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_disjoint_keys","title":"<code>velour_api.backend.query.get_disjoint_keys(db, dataset_name, model_name, task_type)</code>","text":"<p>Returns all unique label keys that are not shared between both predictions and groundtruths.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>dataset_name</code> <code>str</code> <p>The name of a dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of a model.</p> required <code>task_type</code> <code>TaskType</code> <p>The task type to filter on.</p> required <p>Returns:</p> Type Description <code>Tuple[list[Label], list[Label]]</code> <p>A tuple of disjoint label key, where the first element is those labels which are present in groundtruths but absent in predictions.</p> Source code in <code>api/velour_api/backend/query/label.py</code> <pre><code>def get_disjoint_keys(\n    db: Session, dataset_name: str, model_name: str, task_type: enums.TaskType\n) -&gt; tuple[list[schemas.Label], list[schemas.Label]]:\n    \"\"\"\n    Returns all unique label keys that are not shared between both predictions and groundtruths.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    dataset_name: str\n        The name of a dataset.\n    model_name: str\n        The name of a model.\n    task_type: task_type: enums.TaskType\n        The task type to filter on.\n\n    Returns\n    ----------\n    Tuple[list[schemas.Label], list[schemas.Label]]\n        A tuple of disjoint label key, where the first element is those labels which are present in groundtruths but absent in predictions.\n    \"\"\"\n    # create filters\n    gt_filter = schemas.Filter(\n        dataset_names=[dataset_name],\n        task_types=[task_type],\n    )\n    pd_filter = schemas.Filter(\n        dataset_names=[dataset_name],\n        models_names=[model_name],\n        task_types=[task_type],\n    )\n\n    # get keys\n    ds_keys = get_groundtruth_label_keys(db, gt_filter)\n    md_keys = get_prediction_label_keys(db, pd_filter)\n\n    # set operation to get disjoint sets wrt the lhs operand\n    ds_unique = list(ds_keys - md_keys)\n    md_unique = list(md_keys - ds_keys)\n\n    # returns tuple of label lists\n    return (ds_unique, md_unique)\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_disjoint_labels","title":"<code>velour_api.backend.query.get_disjoint_labels(db, dataset_name, model_name, task_types, groundtruth_type, prediction_type)</code>","text":"<p>Returns all unique labels that are not shared between both predictions and groundtruths.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>dataset_name</code> <code>str</code> <p>The name of a dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of a model.</p> required <code>task_types</code> <code>list[TaskType]</code> <p>The task types to filter on.</p> required <code>groundtruth_type</code> <code>AnnotationType</code> <p>The groundtruth type to filter on.</p> required <code>prediction_type</code> <code>AnnotationType</code> <p>The prediction type to filter on</p> required <p>Returns:</p> Type Description <code>Tuple[list[Label], list[Label]]</code> <p>A tuple of disjoint labels, where the first element is those labels which are present in groundtruths but absent in predictions.</p> Source code in <code>api/velour_api/backend/query/label.py</code> <pre><code>def get_disjoint_labels(\n    db: Session,\n    dataset_name: str,\n    model_name: str,\n    task_types: list[enums.TaskType],\n    groundtruth_type: enums.AnnotationType,\n    prediction_type: enums.AnnotationType,\n) -&gt; tuple[list[schemas.Label], list[schemas.Label]]:\n    \"\"\"\n    Returns all unique labels that are not shared between both predictions and groundtruths.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    dataset_name: str\n        The name of a dataset.\n    model_name: str\n        The name of a model.\n    task_types: list[enums.TaskType]\n        The task types to filter on.\n    groundtruth_type: enums.AnnotationType\n        The groundtruth type to filter on.\n    prediction_type: enums.AnnotationType\n        The prediction type to filter on\n\n    Returns\n    ----------\n    Tuple[list[schemas.Label], list[schemas.Label]]\n        A tuple of disjoint labels, where the first element is those labels which are present in groundtruths but absent in predictions.\n    \"\"\"\n\n    # create filters\n    gt_filter = schemas.Filter(\n        dataset_names=[dataset_name],\n        task_types=task_types,\n        annotation_types=[groundtruth_type],\n    )\n    pd_filter = schemas.Filter(\n        dataset_names=[dataset_name],\n        models_names=[model_name],\n        task_types=task_types,\n        annotation_types=[prediction_type],\n    )\n\n    # get labels\n    ds_labels = get_groundtruth_labels(db, gt_filter)\n    md_labels = get_prediction_labels(db, pd_filter)\n\n    # set operation to get disjoint sets wrt the lhs operand\n    ds_unique = list(ds_labels - md_labels)\n    md_unique = list(md_labels - ds_labels)\n\n    # returns tuple of label lists\n    return (ds_unique, md_unique)\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_groundtruth","title":"<code>velour_api.backend.query.get_groundtruth(db, dataset_name, datum_uid)</code>","text":"<p>Fetch a groundtruth.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>datum_uid</code> <code>str</code> <p>The UID of the datum to fetch.</p> required <p>Returns:</p> Type Description <code>GroundTruth</code> <p>The requested groundtruth.</p> Source code in <code>api/velour_api/backend/query/groundtruth.py</code> <pre><code>def get_groundtruth(\n    db: Session,\n    dataset_name: str,\n    datum_uid: str,\n) -&gt; schemas.GroundTruth:\n    \"\"\"\n    Fetch a groundtruth.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    dataset_name : str\n        The name of the dataset.\n    datum_uid: str\n        The UID of the datum to fetch.\n\n\n    Returns\n    ----------\n    schemas.GroundTruth\n        The requested groundtruth.\n    \"\"\"\n    # retrieve from table\n    dataset = core.get_dataset(db, name=dataset_name)\n    datum = core.get_datum(db, dataset_id=dataset.id, uid=datum_uid)\n\n    geo_dict = (\n        json.loads(db.scalar(ST_AsGeoJSON(datum.geo))) if datum.geo else {}\n    )\n\n    return schemas.GroundTruth(\n        datum=schemas.Datum(\n            uid=datum.uid,\n            dataset=dataset_name,\n            metadata=datum.meta,\n            geospatial=geo_dict,\n        ),\n        annotations=core.get_annotations(db, datum),\n    )\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_groundtruth_label_keys","title":"<code>velour_api.backend.query.get_groundtruth_label_keys(db, filters)</code>","text":"<p>Returns all unique groundtruth label keys.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>filters</code> <code>Filter</code> <p>An optional filter to apply.</p> required <p>Returns:</p> Type Description <code>set[Label]</code> <p>A set of labels.</p> Source code in <code>api/velour_api/backend/query/label.py</code> <pre><code>def get_groundtruth_label_keys(\n    db: Session,\n    filters: schemas.Filter | None,\n) -&gt; set[schemas.Label]:\n    \"\"\"\n    Returns all unique groundtruth label keys.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    filters : schemas.Filter\n        An optional filter to apply.\n\n    Returns\n    ----------\n    set[schemas.Label]\n        A set of labels.\n    \"\"\"\n    stmt = ops.Query(models.Label).filter(filters).groundtruths()\n    return _get_label_keys(db, stmt)\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_groundtruth_labels","title":"<code>velour_api.backend.query.get_groundtruth_labels(db, filters)</code>","text":"<p>Returns a set of unique groundtruth labels.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>filters</code> <code>Filter</code> <p>An optional filter to apply.</p> required <p>Returns:</p> Type Description <code>set[Label]</code> <p>A set of labels.</p> Source code in <code>api/velour_api/backend/query/label.py</code> <pre><code>def get_groundtruth_labels(\n    db: Session,\n    filters: schemas.Filter | None,\n) -&gt; set[schemas.Label]:\n    \"\"\"\n    Returns a set of unique groundtruth labels.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    filters : schemas.Filter\n        An optional filter to apply.\n\n    Returns\n    ----------\n    set[schemas.Label]\n        A set of labels.\n    \"\"\"\n    stmt = ops.Query(models.Label).filter(filters).groundtruths()\n    return _get_labels(db, stmt)\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_joint_keys","title":"<code>velour_api.backend.query.get_joint_keys(db, dataset_name, model_name, task_type)</code>","text":"<p>Returns all unique label keys that are shared between both predictions and groundtruths.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>dataset_name</code> <code>str</code> <p>The name of a dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of a model.</p> required <code>task_type</code> <code>TaskType</code> <p>The task types to filter on.</p> required <p>Returns:</p> Type Description <code>set[Label]</code> <p>A list of labels.</p> Source code in <code>api/velour_api/backend/query/label.py</code> <pre><code>def get_joint_keys(\n    db: Session,\n    dataset_name: str,\n    model_name: str,\n    task_type: enums.TaskType,\n) -&gt; list[schemas.Label]:\n    \"\"\"\n    Returns all unique label keys that are shared between both predictions and groundtruths.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    dataset_name: str\n        The name of a dataset.\n    model_name: str\n        The name of a model.\n    task_type: enums.TaskType\n        The task types to filter on.\n\n    Returns\n    ----------\n    set[schemas.Label]\n        A list of labels.\n    \"\"\"\n    gt_filter = schemas.Filter(\n        dataset_names=[dataset_name],\n        task_types=[task_type],\n    )\n    pd_filter = schemas.Filter(\n        dataset_names=[dataset_name],\n        models_names=[model_name],\n        task_types=[task_type],\n    )\n    return list(\n        get_groundtruth_label_keys(db, gt_filter).intersection(\n            get_prediction_label_keys(db, pd_filter)\n        )\n    )\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_joint_labels","title":"<code>velour_api.backend.query.get_joint_labels(db, dataset_name, model_name, task_types, groundtruth_type, prediction_type)</code>","text":"<p>Returns all unique labels that are shared between both predictions and groundtruths.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>dataset_name</code> <code>str</code> <p>The name of a dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of a model.</p> required <code>task_types</code> <code>list[TaskType]</code> <p>The task types to filter on.</p> required <code>groundtruth_type</code> <code>AnnotationType</code> <p>The groundtruth type to filter on.</p> required <code>prediction_type</code> <code>AnnotationType</code> <p>The prediction type to filter on</p> required <p>Returns:</p> Type Description <code>list[Label]</code> <p>A list of labels.</p> Source code in <code>api/velour_api/backend/query/label.py</code> <pre><code>def get_joint_labels(\n    db: Session,\n    dataset_name: str,\n    model_name: str,\n    task_types: list[enums.TaskType],\n    groundtruth_type: enums.AnnotationType,\n    prediction_type: enums.AnnotationType,\n) -&gt; list[schemas.Label]:\n    \"\"\"\n    Returns all unique labels that are shared between both predictions and groundtruths.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    dataset_name: str\n        The name of a dataset.\n    model_name: str\n        The name of a model.\n    task_types: list[enums.TaskType]\n        The task types to filter on.\n    groundtruth_type: enums.AnnotationType\n        The groundtruth type to filter on.\n    prediction_type: enums.AnnotationType\n        The prediction type to filter on\n\n    Returns\n    ----------\n    list[schemas.Label]\n        A list of labels.\n    \"\"\"\n    gt_filter = schemas.Filter(\n        dataset_names=[dataset_name],\n        task_types=task_types,\n        annotation_types=[groundtruth_type],\n    )\n    pd_filter = schemas.Filter(\n        dataset_names=[dataset_name],\n        models_names=[model_name],\n        task_types=task_types,\n        annotation_types=[prediction_type],\n    )\n    return list(\n        get_groundtruth_labels(db, gt_filter).intersection(\n            get_prediction_labels(db, pd_filter)\n        )\n    )\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_label_keys","title":"<code>velour_api.backend.query.get_label_keys(db, filters=None)</code>","text":"<p>Returns all unique label keys.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>filters</code> <code>Filter</code> <p>An optional filter to apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>set[Label]</code> <p>A set of labels.</p> Source code in <code>api/velour_api/backend/query/label.py</code> <pre><code>def get_label_keys(\n    db: Session,\n    filters: schemas.Filter | None = None,\n) -&gt; set[schemas.Label]:\n    \"\"\"\n    Returns all unique label keys.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    filters : schemas.Filter\n        An optional filter to apply.\n\n    Returns\n    ----------\n    set[schemas.Label]\n        A set of labels.\n    \"\"\"\n    stmt = ops.Query(models.Label).filter(filters).any()\n    return _get_label_keys(db, stmt)\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_labels","title":"<code>velour_api.backend.query.get_labels(db, filters=None)</code>","text":"<p>Returns a set of unique labels from a union of sources (dataset, model, datum, annotation) optionally filtered by (label key, task_type).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>filters</code> <code>Filter</code> <p>An optional filter to apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>set[Label]</code> <p>A set of labels.</p> Source code in <code>api/velour_api/backend/query/label.py</code> <pre><code>def get_labels(\n    db: Session,\n    filters: schemas.Filter | None = None,\n) -&gt; set[schemas.Label]:\n    \"\"\"\n    Returns a set of unique labels from a union of sources (dataset, model, datum, annotation) optionally filtered by (label key, task_type).\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    filters : schemas.Filter\n        An optional filter to apply.\n\n    Returns\n    ----------\n    set[schemas.Label]\n        A set of labels.\n    \"\"\"\n    stmt = ops.Query(models.Label).filter(filters).any()\n    return _get_labels(db, stmt)\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_model","title":"<code>velour_api.backend.query.get_model(db, name)</code>","text":"<p>Fetch a model.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>name</code> <code>str</code> <p>The name of the model.</p> required <p>Returns:</p> Type Description <code>Model</code> <p>The requested model.</p> Source code in <code>api/velour_api/backend/query/model.py</code> <pre><code>def get_model(\n    db: Session,\n    name: str,\n) -&gt; schemas.Model:\n    \"\"\"\n    Fetch a model.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    name : str\n        The name of the model.\n\n    Returns\n    ----------\n    schemas.Model\n        The requested model.\n    \"\"\"\n    model = core.get_model(db, name=name)\n    geo_dict = (\n        json.loads(db.scalar(ST_AsGeoJSON(model.geo))) if model.geo else {}\n    )\n    return schemas.Model(\n        id=model.id, name=model.name, metadata=model.meta, geospatial=geo_dict\n    )\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_models","title":"<code>velour_api.backend.query.get_models(db)</code>","text":"<p>Fetch all models.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <p>Returns:</p> Type Description <code>List[Model]</code> <p>A list of all models.</p> Source code in <code>api/velour_api/backend/query/model.py</code> <pre><code>def get_models(\n    db: Session,\n) -&gt; list[schemas.Model]:\n    \"\"\"\n    Fetch all models.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n\n    Returns\n    ----------\n    List[schemas.Model]\n        A list of all models.\n    \"\"\"\n    return [\n        get_model(db, name) for name in db.scalars(select(models.Model.name))\n    ]\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_prediction","title":"<code>velour_api.backend.query.get_prediction(db, model_name, dataset_name, datum_uid)</code>","text":"<p>Fetch a prediction.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>datum_uid</code> <code>str</code> <p>The UID of the datum to fetch.</p> required <p>Returns:</p> Type Description <code>Prediction</code> <p>The requested prediction.</p> Source code in <code>api/velour_api/backend/query/prediction.py</code> <pre><code>def get_prediction(\n    db: Session,\n    model_name: str,\n    dataset_name: str,\n    datum_uid: str,\n) -&gt; schemas.Prediction:\n    \"\"\"\n    Fetch a prediction.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    model_name : str\n        The name of the model.\n    dataset_name : str\n        The name of the dataset.\n    datum_uid: str\n        The UID of the datum to fetch.\n\n    Returns\n    ----------\n    schemas.Prediction\n        The requested prediction.\n    \"\"\"\n    model = core.get_model(db, name=model_name)\n    dataset = core.get_dataset(db, name=dataset_name)\n    datum = core.get_datum(db, dataset_id=dataset.id, uid=datum_uid)\n    geo_dict = (\n        json.loads(db.scalar(ST_AsGeoJSON(datum.geo))) if datum.geo else {}\n    )\n\n    return schemas.Prediction(\n        model=model_name,\n        datum=schemas.Datum(\n            uid=datum.uid,\n            dataset=dataset.name,\n            metadata=datum.meta,\n            geospatial=geo_dict,\n        ),\n        annotations=core.get_annotations(db, datum=datum, model=model),\n    )\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_prediction_label_keys","title":"<code>velour_api.backend.query.get_prediction_label_keys(db, filters)</code>","text":"<p>Returns all unique prediction label keys.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>filters</code> <code>Filter</code> <p>An optional filter to apply.</p> required <p>Returns:</p> Type Description <code>set[Label]</code> <p>A set of labels.</p> Source code in <code>api/velour_api/backend/query/label.py</code> <pre><code>def get_prediction_label_keys(\n    db: Session,\n    filters: schemas.Filter | None,\n) -&gt; set[schemas.Label]:\n    \"\"\"\n    Returns all unique prediction label keys.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    filters : schemas.Filter\n        An optional filter to apply.\n\n    Returns\n    ----------\n    set[schemas.Label]\n        A set of labels.\n    \"\"\"\n    stmt = ops.Query(models.Label).filter(filters).predictions()\n    return _get_label_keys(db, stmt)\n</code></pre>"},{"location":"references/API/Backend/Query%20Functions/#velour_api.backend.query.get_prediction_labels","title":"<code>velour_api.backend.query.get_prediction_labels(db, filters)</code>","text":"<p>Returns a set of unique prediction labels.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>filters</code> <code>Filter</code> <p>An optional filter to apply.</p> required <p>Returns:</p> Type Description <code>set[Label]</code> <p>A set of labels.</p> Source code in <code>api/velour_api/backend/query/label.py</code> <pre><code>def get_prediction_labels(\n    db: Session,\n    filters: schemas.Filter | None,\n) -&gt; set[schemas.Label]:\n    \"\"\"\n    Returns a set of unique prediction labels.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    filters : schemas.Filter\n        An optional filter to apply.\n\n    Returns\n    ----------\n    set[schemas.Label]\n        A set of labels.\n    \"\"\"\n    stmt = ops.Query(models.Label).filter(filters).predictions()\n    return _get_labels(db, stmt)\n</code></pre>"},{"location":"references/API/Backend/Core/Annotation/","title":"Annotation","text":""},{"location":"references/API/Backend/Core/Annotation/#velour_api.backend.core.annotation-functions","title":"Functions","text":""},{"location":"references/API/Backend/Core/Annotation/#velour_api.backend.core.annotation.create_annotations_and_labels","title":"<code>velour_api.backend.core.annotation.create_annotations_and_labels(db, annotations, datum, model=None)</code>","text":"<p>Create a list of annotations and associated labels in postgis</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session you want to query against.</p> required <code>annotations</code> <code>List[Annotation]</code> <p>The list of annotations to create.</p> required <code>datum</code> <code>Datum</code> <p>The datum associated with the annotation.</p> required <code>model</code> <code>Model</code> <p>The model associated with the annotation.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[annotation]</code> <p>The model associated with the annotation.</p> Source code in <code>api/velour_api/backend/core/annotation.py</code> <pre><code>def create_annotations_and_labels(\n    db: Session,\n    annotations: list[schemas.Annotation],\n    datum: models.Datum,\n    model: models.Model = None,\n) -&gt; list[models.Annotation]:\n    \"\"\"\n    Create a list of annotations and associated labels in postgis\n\n    Parameters\n    ----------\n    db : Session\n        The database Session you want to query against.\n    annotations : List[schemas.Annotation]\n        The list of annotations to create.\n    datum : models.Datum\n        The datum associated with the annotation.\n    model : models.Model\n        The model associated with the annotation.\n\n    Returns\n    ----------\n    List[models.annotation]\n        The model associated with the annotation.\n    \"\"\"\n    annotation_list = []\n    label_list = []\n\n    for annotation in annotations:\n        mapping = _get_annotation_mapping(\n            annotation=annotation, datum=datum, model=model\n        )\n        annotation_list.append(models.Annotation(**mapping))\n        label_list.append(create_labels(db=db, labels=annotation.labels))\n\n    try:\n        db.add_all(annotation_list)\n        db.commit()\n    except IntegrityError:\n        db.rollback()\n        raise exceptions.AnnotationAlreadyExistsError\n\n    # return the label_list, too, since these are needed for GroundTruth\n    return (annotation_list, label_list)\n</code></pre>"},{"location":"references/API/Backend/Core/Annotation/#velour_api.backend.core.annotation.get_annotation","title":"<code>velour_api.backend.core.annotation.get_annotation(db, annotation, datum=None)</code>","text":"<p>Fetch an annotation from the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session you want to query against.</p> required <code>annotation</code> <code>Annotation</code> <p>The annotation you want to fetch.</p> required <code>datum</code> <code>Datum</code> <p>The datum associated with the annotation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Annotation</code> <p>The requested annotation.</p> Source code in <code>api/velour_api/backend/core/annotation.py</code> <pre><code>def get_annotation(\n    db: Session, annotation: models.Annotation, datum: models.Datum = None\n) -&gt; schemas.Annotation:\n    \"\"\"\n    Fetch an annotation from the database.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session you want to query against.\n    annotation : models.Annotation\n        The annotation you want to fetch.\n    datum : models.Datum\n        The datum associated with the annotation.\n\n    Returns\n    ----------\n    schemas.Annotation\n        The requested annotation.\n    \"\"\"\n    # Retrieve all labels associated with annotation\n    groundtruth_labels = [\n        schemas.Label(key=label[0], value=label[1])\n        for label in (\n            db.query(models.Label.key, models.Label.value)\n            .join(\n                models.GroundTruth,\n                models.GroundTruth.label_id == models.Label.id,\n            )\n            .where(\n                models.GroundTruth.annotation_id == annotation.id,\n            )\n            .all()\n        )\n    ]\n    prediction_labels = [\n        schemas.Label(key=label[0], value=label[1], score=label[2])\n        for label in (\n            db.query(\n                models.Label.key, models.Label.value, models.Prediction.score\n            )\n            .join(\n                models.Prediction,\n                models.Prediction.label_id == models.Label.id,\n            )\n            .where(\n                models.Prediction.annotation_id == annotation.id,\n            )\n            .all()\n        )\n    ]\n    labels = groundtruth_labels if groundtruth_labels else prediction_labels\n\n    # Initialize\n    retval = schemas.Annotation(\n        task_type=annotation.task_type,\n        labels=labels,\n        metadata=annotation.meta,\n        bounding_box=None,\n        polygon=None,\n        multipolygon=None,\n        raster=None,\n    )\n\n    # Bounding Box\n    if annotation.box is not None:\n        geojson = json.loads(db.scalar(ST_AsGeoJSON(annotation.box)))\n        retval.bounding_box = schemas.BoundingBox(\n            polygon=schemas.GeoJSON.from_dict(data=geojson).shape().boundary,\n            box=None,\n        )\n\n    # Polygon\n    if annotation.polygon is not None:\n        geojson = json.loads(db.scalar(ST_AsGeoJSON(annotation.polygon)))\n        retval.polygon = schemas.GeoJSON.from_dict(data=geojson).shape()\n\n    # Raster\n    if annotation.raster is not None:\n        datum = db.scalar(\n            select(models.Datum).where(models.Datum.id == annotation.datum_id)\n        )\n        if \"height\" not in datum.meta or \"width\" not in datum.meta:\n            raise ValueError(\"missing height or width\")\n        height = datum.meta[\"height\"]\n        width = datum.meta[\"width\"]\n        retval.raster = schemas.Raster(\n            mask=_raster_to_png_b64(\n                db, raster=annotation.raster, height=height, width=width\n            ),\n            height=height,\n            width=width,\n        )\n\n    return retval\n</code></pre>"},{"location":"references/API/Backend/Core/Annotation/#velour_api.backend.core.annotation.get_annotation_type","title":"<code>velour_api.backend.core.annotation.get_annotation_type(db, dataset, model=None)</code>","text":"<p>Fetch an annotation type from postgis.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session you want to query against.</p> required <code>dataset</code> <code>Dataset</code> <p>The dataset associated with the annotation.</p> required <code>model</code> <code>Model</code> <p>The model associated with the annotation.</p> <code>None</code> <p>Returns:</p> Type Description <code>AnnotationType</code> <p>The type of the annotation.</p> Source code in <code>api/velour_api/backend/core/annotation.py</code> <pre><code>def get_annotation_type(\n    db: Session,\n    dataset: models.Dataset,\n    model: models.Model | None = None,\n) -&gt; AnnotationType:\n    \"\"\"\n    Fetch an annotation type from postgis.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session you want to query against.\n    dataset : models.Dataset\n        The dataset associated with the annotation.\n    model : models.Model\n        The model associated with the annotation.\n\n    Returns\n    ----------\n    AnnotationType\n        The type of the annotation.\n    \"\"\"\n    model_expr = (\n        models.Annotation.model_id == model.id\n        if model\n        else models.Annotation.model_id.is_(None)\n    )\n    hierarchy = [\n        (AnnotationType.RASTER, models.Annotation.raster),\n        (AnnotationType.MULTIPOLYGON, models.Annotation.multipolygon),\n        (AnnotationType.POLYGON, models.Annotation.polygon),\n        (AnnotationType.BOX, models.Annotation.box),\n    ]\n    for atype, col in hierarchy:\n        search = (\n            db.query(distinct(models.Dataset.id))\n            .select_from(models.Annotation)\n            .join(models.Datum, models.Datum.id == models.Annotation.datum_id)\n            .join(models.Dataset, models.Dataset.id == models.Datum.dataset_id)\n            .where(\n                models.Datum.dataset_id == dataset.id,\n                models.Annotation.task_type == enums.TaskType.DETECTION.value,\n                model_expr,\n                col.isnot(None),\n            )\n            .one_or_none()\n        )\n        if search is not None:\n            return atype\n    return AnnotationType.NONE\n</code></pre>"},{"location":"references/API/Backend/Core/Annotation/#velour_api.backend.core.annotation.get_annotations","title":"<code>velour_api.backend.core.annotation.get_annotations(db, datum, model=None)</code>","text":"<p>Query postgis to get all annotations for a particular datum.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database session to query against.</p> required <code>datum</code> <code>Datum</code> <p>The datum you want to fetch annotations for.</p> required <code>model</code> <code>Model</code> <p>The model you want to query against (optional).</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>A list of annotations.</p> Source code in <code>api/velour_api/backend/core/annotation.py</code> <pre><code>def get_annotations(\n    db: Session,\n    datum: models.Datum,\n    model: models.Model | None = None,\n) -&gt; list[schemas.Annotation]:\n    \"\"\"\n    Query postgis to get all annotations for a particular datum.\n\n    Parameters\n    -------\n    db : Session\n        The database session to query against.\n    datum : models.Datum\n        The datum you want to fetch annotations for.\n    model : models.Model\n        The model you want to query against (optional).\n\n    Returns\n    ----------\n    List[schemas.Annotation]\n        A list of annotations.\n    \"\"\"\n    model_expr = (\n        models.Annotation.model_id.is_(None)\n        if model is None\n        else models.Annotation.model_id == model.id\n    )\n    return [\n        get_annotation(db, annotation=annotation, datum=datum)\n        for annotation in (\n            db.query(models.Annotation)\n            .where(\n                and_(\n                    model_expr,\n                    models.Annotation.datum_id == datum.id,\n                )\n            )\n            .all()\n        )\n    ]\n</code></pre>"},{"location":"references/API/Backend/Core/Dataset/","title":"Dataset","text":""},{"location":"references/API/Backend/Core/Dataset/#velour_api.backend.core.dataset-functions","title":"Functions","text":""},{"location":"references/API/Backend/Core/Dataset/#velour_api.backend.core.dataset.create_datum","title":"<code>velour_api.backend.core.dataset.create_datum(db, datum)</code>","text":"<p>Create a datum in the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session you want to query against.</p> required <code>datum</code> <code>Datum</code> <p>The datum to add to the database.</p> required <p>Returns:</p> Type Description <code>Datum</code> <p>The datum.</p> Source code in <code>api/velour_api/backend/core/dataset.py</code> <pre><code>def create_datum(\n    db: Session,\n    datum: schemas.Datum,\n) -&gt; models.Datum:\n    \"\"\"\n    Create a datum in the database.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session you want to query against.\n    datum : schemas.Datum\n        The datum to add to the database.\n\n    Returns\n    ----------\n    models.Datum\n        The datum.\n\n    \"\"\"\n    # retrieve dataset\n    dataset = get_dataset(db, datum.dataset)\n\n    shape = (\n        schemas.GeoJSON.from_dict(data=datum.geospatial).shape().wkt()\n        if datum.geospatial\n        else None\n    )\n\n    # create datum\n    try:\n        row = models.Datum(\n            uid=datum.uid,\n            dataset_id=dataset.id,\n            meta=datum.metadata,\n            geo=shape,\n        )\n        db.add(row)\n        db.commit()\n    except IntegrityError:\n        db.rollback()\n        raise exceptions.DatumAlreadyExistsError(datum.uid)\n\n    return row\n</code></pre>"},{"location":"references/API/Backend/Core/Dataset/#velour_api.backend.core.dataset.get_dataset","title":"<code>velour_api.backend.core.dataset.get_dataset(db, name)</code>","text":"<p>Fetch a dataset from the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session you want to query against.</p> required <code>name</code> <code>str</code> <p>The name of the dataset.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>The requested dataset.</p> Source code in <code>api/velour_api/backend/core/dataset.py</code> <pre><code>def get_dataset(\n    db: Session,\n    name: str,\n) -&gt; models.Dataset:\n    \"\"\"\n    Fetch a dataset from the database.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session you want to query against.\n    name : str\n        The name of the dataset.\n\n    Returns\n    ----------\n    models.Dataset\n        The requested dataset.\n\n    \"\"\"\n\n    dataset = (\n        db.query(models.Dataset)\n        .where(models.Dataset.name == name)\n        .one_or_none()\n    )\n    if dataset is None:\n        raise exceptions.DatasetDoesNotExistError(name)\n    return dataset\n</code></pre>"},{"location":"references/API/Backend/Core/Dataset/#velour_api.backend.core.dataset.get_datum","title":"<code>velour_api.backend.core.dataset.get_datum(db, dataset_id, uid)</code>","text":"<p>Fetch a datum from the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>dataset_id</code> <code>int</code> <p>The ID of the dataset.</p> required <code>uid</code> <code>str</code> <p>The UID of the datum.</p> required <p>Returns:</p> Type Description <code>Datum</code> <p>The requested datum.</p> Source code in <code>api/velour_api/backend/core/dataset.py</code> <pre><code>def get_datum(\n    db: Session,\n    dataset_id: int,\n    uid: str,\n) -&gt; models.Datum:\n    \"\"\"\n    Fetch a datum from the database.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    dataset_id : int\n        The ID of the dataset.\n    uid : str\n        The UID of the datum.\n\n    Returns\n    ----------\n    models.Datum\n        The requested datum.\n\n    \"\"\"\n    datum = (\n        db.query(models.Datum)\n        .where(\n            and_(\n                models.Datum.dataset_id == dataset_id,\n                models.Datum.uid == uid,\n            )\n        )\n        .one_or_none()\n    )\n    if datum is None:\n        raise exceptions.DatumDoesNotExistError(uid)\n    return datum\n</code></pre>"},{"location":"references/API/Backend/Core/Geometry/","title":"Geometry","text":""},{"location":"references/API/Backend/Core/Geometry/#velour_api.backend.core.geometry-functions","title":"Functions","text":""},{"location":"references/API/Backend/Core/Geometry/#velour_api.backend.core.geometry.convert_geometry","title":"<code>velour_api.backend.core.geometry.convert_geometry(db, dataset, model, dataset_source_type, model_source_type, evaluation_target_type)</code>","text":"<p>Converts geometry into some target type</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session you want to query against.</p> required <code>dataset</code> <code>Dataset</code> <p>The dataset of the geometry.</p> required <code>model</code> <code>Model</code> <p>The model of the geometry.</p> required <code>dataset_source_type</code> <code>AnnotationType</code> <p>The annotation type associated with the dataset.</p> required <code>model_source_type</code> <code>AnnotationType</code> <p>The annotation type associated with the model.</p> required <code>evaluation_target_type</code> <code>AnnotationType</code> <p>The annotation type we wish to convert to.</p> required Source code in <code>api/velour_api/backend/core/geometry.py</code> <pre><code>def convert_geometry(\n    db: Session,\n    dataset: models.Dataset,\n    model: models.Model,\n    dataset_source_type: AnnotationType,\n    model_source_type: AnnotationType,\n    evaluation_target_type: AnnotationType,\n):\n    \"\"\"\n    Converts geometry into some target type\n\n    Parameters\n    ----------\n    db : Session\n        The database Session you want to query against.\n    dataset : models.Dataset\n        The dataset of the geometry.\n    model : models.Model\n        The model of the geometry.\n    dataset_source_type: AnnotationType\n        The annotation type associated with the dataset.\n    model_source_type: AnnotationType\n        The annotation type associated with the model.\n    evaluation_target_type: AnnotationType\n        The annotation type we wish to convert to.\n    \"\"\"\n\n    # Check typing\n    valid_types = [\n        AnnotationType.BOX,\n        AnnotationType.POLYGON,\n        AnnotationType.RASTER,\n    ]\n    if evaluation_target_type not in valid_types:\n        raise RuntimeError(\n            f\"Evaluation type `{evaluation_target_type}` not in valid set `{valid_types}`\"\n        )\n    if dataset_source_type not in valid_types:\n        raise RuntimeError(\n            f\"GroundTruth type `{evaluation_target_type}` not in valid set `{valid_types}`\"\n        )\n    if model_source_type not in valid_types:\n        raise RuntimeError(\n            f\"Prediction type `{evaluation_target_type}` not in valid set `{valid_types}`\"\n        )\n\n    # Check if source type can serve the target type\n    assert dataset_source_type &gt;= evaluation_target_type\n    assert model_source_type &gt;= evaluation_target_type\n\n    # Dataset type conversion\n    if (\n        dataset_source_type == AnnotationType.POLYGON\n        and evaluation_target_type == AnnotationType.BOX\n    ):\n        db.execute(text(convert_polygon_to_box(dataset_id=dataset.id)))\n    elif (\n        dataset_source_type == AnnotationType.RASTER\n        and evaluation_target_type == AnnotationType.BOX\n    ):\n        db.execute(text(convert_raster_to_box(dataset_id=dataset.id)))\n    elif (\n        dataset_source_type == AnnotationType.RASTER\n        and evaluation_target_type == AnnotationType.POLYGON\n    ):\n        db.execute(text(convert_raster_to_polygon(dataset_id=dataset.id)))\n\n    # Model type conversion\n    if (\n        model_source_type == AnnotationType.POLYGON\n        and evaluation_target_type == AnnotationType.BOX\n    ):\n        db.execute(\n            text(\n                convert_polygon_to_box(\n                    dataset_id=dataset.id, model_id=model.id\n                )\n            )\n        )\n    elif (\n        model_source_type == AnnotationType.RASTER\n        and evaluation_target_type == AnnotationType.BOX\n    ):\n        db.execute(\n            text(\n                convert_raster_to_box(dataset_id=dataset.id, model_id=model.id)\n            )\n        )\n    elif (\n        model_source_type == AnnotationType.RASTER\n        and evaluation_target_type == AnnotationType.POLYGON\n    ):\n        db.execute(\n            text(\n                convert_raster_to_polygon(\n                    dataset_id=dataset.id, model_id=model.id\n                )\n            )\n        )\n\n    db.commit()\n</code></pre>"},{"location":"references/API/Backend/Core/Geometry/#velour_api.backend.core.geometry.convert_polygon_to_box","title":"<code>velour_api.backend.core.geometry.convert_polygon_to_box(dataset_id, model_id=None)</code>","text":"<p>Converts annotation column 'polygon' into column 'box'.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>int</code> <p>the id of the dataset.</p> required <code>model_id</code> <code>int</code> <p>the id of the model.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A SQL query to complete the conversion.</p> Source code in <code>api/velour_api/backend/core/geometry.py</code> <pre><code>def convert_polygon_to_box(\n    dataset_id: int, model_id: int | None = None\n) -&gt; str:\n    \"\"\"\n    Converts annotation column 'polygon' into column 'box'.\n\n    Parameters\n    ----------\n    dataset_id : int\n        the id of the dataset.\n    model_id : int\n        the id of the model.\n\n    Returns\n    ----------\n    str\n        A SQL query to complete the conversion.\n    \"\"\"\n\n    model_id = f\" = {model_id}\" if model_id else \" IS NULL\"\n\n    return f\"\"\"\n    UPDATE annotation\n    SET box = ST_Envelope(annotation.polygon)\n    FROM annotation ann\n    JOIN datum ON datum.id = ann.datum_id\n    WHERE\n    annotation.id = ann.id\n    AND ann.box IS NULL\n    AND ann.polygon IS NOT NULL\n    AND datum.dataset_id = {dataset_id}\n    AND ann.model_id {model_id}\n    \"\"\"\n</code></pre>"},{"location":"references/API/Backend/Core/Geometry/#velour_api.backend.core.geometry.convert_raster_to_box","title":"<code>velour_api.backend.core.geometry.convert_raster_to_box(dataset_id, model_id=None)</code>","text":"<p>Converts annotation column 'raster' into column 'box'.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>int</code> <p>the id of the dataset.</p> required <code>model_id</code> <code>int</code> <p>the id of the model.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A SQL query to complete the conversion.</p> Source code in <code>api/velour_api/backend/core/geometry.py</code> <pre><code>def convert_raster_to_box(dataset_id: int, model_id: int | None = None):\n    \"\"\"\n    Converts annotation column 'raster' into column 'box'.\n\n    Parameters\n    ----------\n    dataset_id : int\n        the id of the dataset.\n    model_id : int\n        the id of the model.\n\n    Returns\n    ----------\n    str\n        A SQL query to complete the conversion.\n    \"\"\"\n\n    model_id = f\" = {model_id}\" if model_id else \" IS NULL\"\n\n    return f\"\"\"\n    UPDATE annotation\n    SET box = subquery.raster_envelope\n    FROM (\n        SELECT id, ST_Envelope(ST_Union(geom)) as raster_envelope\n        FROM (\n            SELECT ann.id as id, ST_MakeValid((ST_DumpAsPolygons(raster)).geom) as geom\n            FROM annotation AS ann\n            JOIN datum ON datum.id = ann.datum_id\n            WHERE\n            ann.box IS NULL\n            AND ann.raster IS NOT NULL\n            AND datum.dataset_id = {dataset_id}\n            AND ann.model_id {model_id}\n        ) AS conversion\n        GROUP BY id\n    ) as subquery\n    WHERE annotation.id = subquery.id\n    \"\"\"\n</code></pre>"},{"location":"references/API/Backend/Core/Geometry/#velour_api.backend.core.geometry.convert_raster_to_multipolygon","title":"<code>velour_api.backend.core.geometry.convert_raster_to_multipolygon(dataset_id, model_id=None)</code>","text":"<p>Converts annotation column 'raster' into column 'multipolygon'.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>int</code> <p>the id of the dataset.</p> required <code>model_id</code> <code>int</code> <p>the id of the model.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A SQL query to complete the conversion.</p> Source code in <code>api/velour_api/backend/core/geometry.py</code> <pre><code>def convert_raster_to_multipolygon(\n    dataset_id: int, model_id: int | None = None\n):\n    \"\"\"\n    Converts annotation column 'raster' into column 'multipolygon'.\n\n    Parameters\n    ----------\n    dataset_id : int\n        the id of the dataset.\n    model_id : int\n        the id of the model.\n\n    Returns\n    ----------\n    str\n        A SQL query to complete the conversion.\n    \"\"\"\n\n    model_id = f\" = {model_id}\" if model_id else \" IS NULL\"\n\n    return f\"\"\"\n    UPDATE annotation\n    SET multipolygon = subquery.raster_multipolygon\n    FROM (\n        SELECT id, ST_Union(geom) as raster_multipolygon\n        FROM (\n            SELECT ann.id as id, ST_MakeValid((ST_DumpAsPolygons(raster)).geom) as geom\n            FROM annotation ann\n            JOIN datum ON datum.id = ann.datum_id\n            WHERE\n            ann.id = annotation.id\n            AND ann.multipolygon IS NULL\n            AND ann.raster IS NOT NULL\n            AND datum.dataset_id = {dataset_id}\n            AND ann.model_id {model_id}\n        ) AS conversion\n        GROUP BY id\n    ) as subquery\n    WHERE annotation.id = subquery.id\n    \"\"\"\n</code></pre>"},{"location":"references/API/Backend/Core/Geometry/#velour_api.backend.core.geometry.convert_raster_to_polygon","title":"<code>velour_api.backend.core.geometry.convert_raster_to_polygon(dataset_id, model_id=None)</code>","text":"<p>Converts annotation column 'raster' into column 'polygon'.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>int</code> <p>the id of the dataset.</p> required <code>model_id</code> <code>int</code> <p>the id of the model.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A SQL query to complete the conversion.</p> Source code in <code>api/velour_api/backend/core/geometry.py</code> <pre><code>def convert_raster_to_polygon(dataset_id: int, model_id: int | None = None):\n    \"\"\"\n    Converts annotation column 'raster' into column 'polygon'.\n\n    Parameters\n    ----------\n    dataset_id : int\n        the id of the dataset.\n    model_id : int\n        the id of the model.\n\n    Returns\n    ----------\n    str\n        A SQL query to complete the conversion.\n    \"\"\"\n\n    # @TODO: should this be purely an boundary around the raster,\n    # multipolygon handles holes and odd regions better.\n\n    raise NotImplementedError\n</code></pre>"},{"location":"references/API/Backend/Core/Label/","title":"Label","text":""},{"location":"references/API/Backend/Core/Label/#velour_api.backend.core.label-functions","title":"Functions","text":""},{"location":"references/API/Backend/Core/Label/#velour_api.backend.core.label.create_labels","title":"<code>velour_api.backend.core.label.create_labels(db, labels)</code>","text":"<p>Add a list of labels to postgis. Handles cases where the label already exists in the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database session to query against.</p> required <code>labels</code> <code>list[Label]</code> <p>A list of labels to add to postgis.</p> required <p>Returns:</p> Type Description <code>List[Label]</code> <p>A list of labels.</p> Source code in <code>api/velour_api/backend/core/label.py</code> <pre><code>def create_labels(\n    db: Session,\n    labels: list[schemas.Label],\n) -&gt; list[models.Label]:\n    \"\"\"\n    Add a list of labels to postgis. Handles cases where the label already exists in the database.\n\n    Parameters\n    -------\n    db : Session\n        The database session to query against.\n    labels : list[schemas.Label]\n        A list of labels to add to postgis.\n\n    Returns\n    -------\n    List[models.Label]\n        A list of labels.\n    \"\"\"\n    replace_val = \"to_be_replaced\"\n\n    # get existing labels\n    existing_labels = {\n        (label.key, label.value): label\n        for label in _get_existing_labels(db=db, labels=labels)\n    }\n\n    output = []\n    labels_to_be_added_to_db = []\n\n    # determine which labels already exist\n    for label in labels:\n        lookup = (label.key, label.value)\n        if lookup in existing_labels:\n            output.append(existing_labels[lookup])\n        else:\n            labels_to_be_added_to_db.append(\n                models.Label(key=label.key, value=label.value)\n            )\n            output.append(replace_val)\n\n    # upload the labels that were missing\n    try:\n        db.add_all(labels_to_be_added_to_db)\n        db.commit()\n    except IntegrityError as e:\n        db.rollback()\n        raise e  # this should never be called\n\n    # move those fetched labels into output in the correct order\n    for i in range(len(output)):\n        if output[i] == replace_val:\n            output[i] = labels_to_be_added_to_db.pop(0)\n\n    assert (\n        not labels_to_be_added_to_db\n    ), \"Error when merging existing labels with new labels\"\n\n    return output\n</code></pre>"},{"location":"references/API/Backend/Core/Label/#velour_api.backend.core.label.get_dataset_labels_query","title":"<code>velour_api.backend.core.label.get_dataset_labels_query(dataset_name, annotation_type, task_types)</code>","text":"<p>Create a query to fetch labels associated with a dataset from the database.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The dataset to fetch labels for.</p> required <code>annotation_type</code> <code>AnnotationType</code> <p>The annotation type of the model.</p> required <code>task_types</code> <code>listp[TaskType]</code> <p>The task types to filter on.</p> required <p>Returns:</p> Type Description <code>Select</code> <p>A sqlalchemy query.</p> Source code in <code>api/velour_api/backend/core/label.py</code> <pre><code>def get_dataset_labels_query(\n    dataset_name: str,\n    annotation_type: enums.AnnotationType,\n    task_types: list[enums.TaskType],\n) -&gt; Select:\n    \"\"\"\n    Create a query to fetch labels associated with a dataset from the database.\n\n    Parameters\n    -------\n    dataset_name : str\n        The dataset to fetch labels for.\n    annotation_type : enums.AnnotationType\n        The annotation type of the model.\n    task_types : listp[enums.TaskType]\n        The task types to filter on.\n\n    Returns\n    -------\n    Select\n        A sqlalchemy query.\n    \"\"\"\n    annotation_type_expr = (\n        [models.annotation_type_to_geometry[annotation_type].is_not(None)]\n        if annotation_type is not enums.AnnotationType.NONE\n        else []\n    )\n\n    return (\n        select(models.Label)\n        .join(\n            models.GroundTruth,\n            models.GroundTruth.label_id == models.Label.id,\n        )\n        .join(\n            models.Annotation,\n            models.Annotation.id == models.GroundTruth.annotation_id,\n        )\n        .join(models.Datum, models.Datum.id == models.Annotation.datum_id)\n        .join(models.Dataset, models.Dataset.id == models.Dataset.id)\n        .where(\n            and_(\n                models.Dataset.name == dataset_name,\n                models.Annotation.task_type.in_(task_types),\n                *annotation_type_expr,\n            )\n        )\n        .distinct()\n    )\n</code></pre>"},{"location":"references/API/Backend/Core/Label/#velour_api.backend.core.label.get_label","title":"<code>velour_api.backend.core.label.get_label(db, label)</code>","text":"<p>Fetch a label from the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database session to query against.</p> required <code>label</code> <code>Label</code> <p>The label to fetch.</p> required <p>Returns:</p> Type Description <code>Label</code> <p>The requested label.</p> Source code in <code>api/velour_api/backend/core/label.py</code> <pre><code>def get_label(\n    db: Session,\n    label: schemas.Label,\n) -&gt; models.Label | None:\n    \"\"\"\n    Fetch a label from the database.\n\n    Parameters\n    -------\n    db : Session\n        The database session to query against.\n    label : schemas.Label\n        The label to fetch.\n\n    Returns\n    -------\n    models.Label\n        The requested label.\n    \"\"\"\n    return (\n        db.query(models.Label)\n        .where(\n            and_(\n                models.Label.key == label.key,\n                models.Label.value == label.value,\n            )\n        )\n        .one_or_none()\n    )\n</code></pre>"},{"location":"references/API/Backend/Core/Label/#velour_api.backend.core.label.get_labels","title":"<code>velour_api.backend.core.label.get_labels(db, annotation)</code>","text":"<p>Fetch labels associated with an annotation from the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database session to query against.</p> required <code>annotation</code> <code>Annotation</code> <p>The annotation to fetch labels for.</p> required <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>The requested list of labels.</p> Source code in <code>api/velour_api/backend/core/label.py</code> <pre><code>def get_labels(\n    db: Session,\n    annotation: models.Annotation,\n) -&gt; list[models.Annotation]:\n    \"\"\"\n    Fetch labels associated with an annotation from the database.\n\n    Parameters\n    -------\n    db : Session\n        The database session to query against.\n    annotation : models.Annotation\n        The annotation to fetch labels for.\n\n    Returns\n    -------\n    List[models.Annotation]\n        The requested list of labels.\n    \"\"\"\n    labels = (\n        db.query(models.Label.key, models.Label.value)\n        .select_from(models.GroundTruth)\n        .join(\n            models.Label,\n            models.GroundTruth.label_id == models.Label.id,\n        )\n        .where(models.GroundTruth.annotation_id == annotation.id)\n        .all()\n    )\n\n    labels_with_score = (\n        db.query(models.Label.key, models.Label.value, models.Prediction.score)\n        .select_from(models.Prediction)\n        .join(\n            models.Label,\n            models.Prediction.label_id == models.Label.id,\n        )\n        .where(models.Prediction.annotation_id == annotation.id)\n        .all()\n    )\n\n    if labels:\n        return [\n            schemas.Label(key=label[0], value=label[1]) for label in labels\n        ]\n    elif labels_with_score:\n        return [\n            schemas.Label(key=label[0], value=label[1], score=label[2])\n            for label in labels_with_score\n        ]\n    else:\n        raise ValueError(\n            f\"no labels found for annotation with id: `{annotation.id}`\"\n        )\n</code></pre>"},{"location":"references/API/Backend/Core/Model/","title":"Model","text":""},{"location":"references/API/Backend/Core/Model/#velour_api.backend.core.model-functions","title":"Functions","text":""},{"location":"references/API/Backend/Core/Model/#velour_api.backend.core.model.get_model","title":"<code>velour_api.backend.core.model.get_model(db, name)</code>","text":"<p>Fetch a model from the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session you want to query against.</p> required <code>name</code> <code>str</code> <p>The name of the model.</p> required <p>Returns:</p> Type Description <code>Model</code> <p>The requested model.</p> Source code in <code>api/velour_api/backend/core/model.py</code> <pre><code>def get_model(\n    db: Session,\n    name: str,\n) -&gt; models.Model:\n    \"\"\"\n    Fetch a model from the database.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session you want to query against.\n    name : str\n        The name of the model.\n\n    Returns\n    ----------\n    models.Model\n        The requested model.\n\n    \"\"\"\n\n    model = (\n        db.query(models.Model).where(models.Model.name == name).one_or_none()\n    )\n    if model is None:\n        raise exceptions.ModelDoesNotExistError(name)\n    return model\n</code></pre>"},{"location":"references/API/Backend/Metrics/Classification/","title":"Classification","text":""},{"location":"references/API/Backend/Metrics/Classification/#velour_api.backend.metrics.classification-classes","title":"Classes","text":""},{"location":"references/API/Backend/Metrics/Classification/#velour_api.backend.metrics.classification-functions","title":"Functions","text":""},{"location":"references/API/Backend/Metrics/Classification/#velour_api.backend.metrics.classification.create_clf_evaluation","title":"<code>velour_api.backend.metrics.classification.create_clf_evaluation(db, job_request)</code>","text":"<p>Create a classification evaluation job.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>job_request</code> <code>EvaluationJob</code> <p>The job request to create an evaluation for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The evaluation job id.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the job's task type is incorrect.</p> <code>ValueError</code> <p>If the evaluation contains an inappropriate filter.</p> Source code in <code>api/velour_api/backend/metrics/classification.py</code> <pre><code>def create_clf_evaluation(\n    db: Session,\n    job_request: schemas.EvaluationJob,\n) -&gt; int:\n    \"\"\"\n    Create a classification evaluation job.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    job_request : schemas.EvaluationJob\n        The job request to create an evaluation for.\n\n    Returns\n    ----------\n    int\n        The evaluation job id.\n\n    Raises\n    ----------\n    TypeError\n        If the job's task type is incorrect.\n    ValueError\n        If the evaluation contains an inappropriate filter.\n    \"\"\"\n    # check matching task_type\n    if job_request.task_type != TaskType.CLASSIFICATION:\n        raise TypeError(\n            \"Invalid task_type, please choose an evaluation method that supports classification\"\n        )\n\n    # configure filters object\n    if job_request.settings.filters:\n        if (\n            job_request.settings.filters.dataset_names is not None\n            or job_request.settings.filters.dataset_metadata is not None\n            or job_request.settings.filters.dataset_geospatial is not None\n            or job_request.settings.filters.models_names is not None\n            or job_request.settings.filters.models_metadata is not None\n            or job_request.settings.filters.models_geospatial is not None\n            or job_request.settings.filters.prediction_scores is not None\n            or job_request.settings.filters.task_types is not None\n        ):\n            raise ValueError(\n                \"Evaluation filter objects should not include any dataset, model, prediction score or task type filters.\"\n            )\n\n    # create evaluation row\n    dataset = core.get_dataset(db, job_request.dataset)\n    model = core.get_model(db, job_request.model)\n    es = get_or_create_row(\n        db,\n        models.Evaluation,\n        mapping={\n            \"dataset_id\": dataset.id,\n            \"model_id\": model.id,\n            \"task_type\": TaskType.CLASSIFICATION,\n            \"settings\": job_request.settings.model_dump(),\n        },\n    )\n    return es.id\n</code></pre>"},{"location":"references/API/Backend/Metrics/Classification/#velour_api.backend.metrics.classification.create_clf_metrics","title":"<code>velour_api.backend.metrics.classification.create_clf_metrics(db, job_id)</code>","text":"<p>Create classification metrics. This function is intended to be run using FastAPI's <code>BackgroundTasks</code>.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>job_id</code> <code>int</code> <p>The job ID to create metrics for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The evaluation job id.</p> Source code in <code>api/velour_api/backend/metrics/classification.py</code> <pre><code>def create_clf_metrics(\n    db: Session,\n    job_id: int,\n) -&gt; int:\n    \"\"\"\n    Create classification metrics. This function is intended to be run using FastAPI's `BackgroundTasks`.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    job_id : int\n        The job ID to create metrics for.\n\n    Returns\n    ----------\n    int\n        The evaluation job id.\n    \"\"\"\n    evaluation = db.scalar(\n        select(models.Evaluation).where(models.Evaluation.id == job_id)\n    )\n\n    # unpack job request\n    job_request = schemas.EvaluationJob(\n        dataset=evaluation.dataset.name,\n        model=evaluation.model.name,\n        task_type=evaluation.task_type,\n        settings=schemas.EvaluationSettings(**evaluation.settings),\n        id=evaluation.id,\n    )\n\n    # configure filters\n    if not job_request.settings.filters:\n        job_request.settings.filters = schemas.Filter()\n    job_request.settings.filters.task_types = [TaskType.CLASSIFICATION]\n\n    confusion_matrices, metrics = _compute_clf_metrics(\n        db=db,\n        job_request=job_request,\n    )\n\n    confusion_matrices_mappings = create_metric_mappings(\n        db=db,\n        metrics=confusion_matrices,\n        evaluation_id=job_request.id,\n    )\n\n    for mapping in confusion_matrices_mappings:\n        get_or_create_row(\n            db,\n            models.ConfusionMatrix,\n            mapping,\n        )\n\n    metric_mappings = create_metric_mappings(\n        db=db, metrics=metrics, evaluation_id=job_request.id\n    )\n\n    for mapping in metric_mappings:\n        # ignore value since the other columns are unique identifiers\n        # and have empirically noticed value can slightly change due to floating\n        # point errors\n        get_or_create_row(\n            db,\n            models.Metric,\n            mapping,\n            columns_to_ignore=[\"value\"],\n        )\n\n    return job_id\n</code></pre>"},{"location":"references/API/Backend/Metrics/Detection/","title":"Detection","text":""},{"location":"references/API/Backend/Metrics/Detection/#velour_api.backend.metrics.detection-classes","title":"Classes","text":""},{"location":"references/API/Backend/Metrics/Detection/#velour_api.backend.metrics.detection-functions","title":"Functions","text":""},{"location":"references/API/Backend/Metrics/Detection/#velour_api.backend.metrics.detection.compute_detection_metrics","title":"<code>velour_api.backend.metrics.detection.compute_detection_metrics(db, dataset, model, settings, target_type)</code>","text":"<p>Compute detection metrics.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>dataset</code> <code>Dataset</code> <p>The dataset to compute metrics for.</p> required <code>model</code> <code>Model</code> <p>The model to compute metrics for.</p> required <code>settings</code> <code>EvaluationSettings</code> <p>The settings for the evaluation.</p> required <code>target_type</code> <code>AnnotationType</code> <p>The annotation type to compute metrics for.</p> required <p>Returns:</p> Type Description <code>List[APMetric | APMetricAveragedOverIOUs | mAPMetric | mAPMetricAveragedOverIOUs]</code> <p>A list of average precision metrics.</p> Source code in <code>api/velour_api/backend/metrics/detection.py</code> <pre><code>def compute_detection_metrics(\n    db: Session,\n    dataset: models.Dataset,\n    model: models.Model,\n    settings: schemas.EvaluationSettings,\n    target_type: enums.AnnotationType,\n) -&gt; list[\n    schemas.APMetric\n    | schemas.APMetricAveragedOverIOUs\n    | schemas.mAPMetric\n    | schemas.mAPMetricAveragedOverIOUs\n]:\n    \"\"\"\n    Compute detection metrics.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    dataset: models.Dataset\n        The dataset to compute metrics for.\n    model: models.Model\n        The model to compute metrics for.\n    settings: schemas.EvaluationSettings\n        The settings for the evaluation.\n    target_type: enums.AnnotationType\n        The annotation type to compute metrics for.\n\n\n    Returns\n    ----------\n    List[schemas.APMetric | schemas.APMetricAveragedOverIOUs | schemas.mAPMetric | schemas.mAPMetricAveragedOverIOUs]\n        A list of average precision metrics.\n\n    \"\"\"\n    # Create groundtruth filter\n    gt_filter = settings.filters.model_copy()\n    gt_filter.dataset_names = [dataset.name]\n    gt_filter.models_names = None\n    gt_filter.models_metadata = None\n    gt_filter.models_geospatial = None\n    gt_filter.prediction_scores = None\n\n    # Create prediction filter\n    pd_filter = settings.filters.model_copy()\n    pd_filter.dataset_names = [dataset.name]\n    pd_filter.models_names = [model.name]\n\n    # Join gt, datum, annotation, label\n    gt = (\n        Query(\n            models.GroundTruth.id.label(\"id\"),\n            models.Datum.id.label(\"datum_id\"),\n            models.annotation_type_to_geometry[target_type].label(\"geom\"),\n            models.Label.id.label(\"label_id\"),\n        )\n        .filter(gt_filter)\n        .groundtruths(\"groundtruths\")\n    )\n\n    # Join pd, datum, annotation, label\n    pd = (\n        Query(\n            models.Prediction.id.label(\"id\"),\n            models.Datum.id.label(\"datum_id\"),\n            models.annotation_type_to_geometry[target_type].label(\"geom\"),\n            models.Label.id.label(\"label_id\"),\n            models.Prediction.score.label(\"score\"),\n        )\n        .filter(pd_filter)\n        .predictions(\"predictions\")\n    )\n\n    # Create joint table\n    joint = (\n        select(\n            func.coalesce(gt.c.datum_id, pd.c.datum_id).label(\"datum_id\"),\n            gt.c.id.label(\"gt_id\"),\n            pd.c.id.label(\"pd_id\"),\n            gt.c.label_id.label(\"gt_label_id\"),\n            pd.c.label_id.label(\"pd_label_id\"),\n            gt.c.geom.label(\"gt_geom\"),\n            pd.c.geom.label(\"pd_geom\"),\n            pd.c.score.label(\"score\"),\n        )\n        .select_from(gt)\n        .join(\n            pd,\n            and_(\n                pd.c.datum_id == gt.c.datum_id,\n                pd.c.label_id == gt.c.label_id,\n            ),\n            full=True,\n        )\n        .subquery()\n    )\n\n    # IOU Computation Block\n    if target_type == AnnotationType.RASTER:\n        gintersection = gfunc.ST_Count(\n            gfunc.ST_Intersection(joint.c.gt_geom, joint.c.pd_geom)\n        )\n        gunion_gt = gfunc.ST_Count(joint.c.gt_geom)\n        gunion_pd = gfunc.ST_Count(joint.c.pd_geom)\n        gunion = gunion_gt + gunion_pd - gintersection\n        iou_computation = gfunc.ST_Area(gintersection) / gfunc.ST_Area(gunion)\n    else:\n        gintersection = gfunc.ST_Intersection(joint.c.gt_geom, joint.c.pd_geom)\n        gunion = gfunc.ST_Union(joint.c.gt_geom, joint.c.pd_geom)\n        iou_computation = gfunc.ST_Area(gintersection) / gfunc.ST_Area(gunion)\n\n    # Compute IOUs\n    ious = (\n        select(\n            joint.c.datum_id.label(\"datum_id\"),\n            joint.c.gt_id.label(\"gt_id\"),\n            joint.c.pd_id.label(\"pd_id\"),\n            joint.c.gt_label_id.label(\"gt_label_id\"),\n            joint.c.pd_label_id.label(\"pd_label_id\"),\n            joint.c.score.label(\"score\"),\n            func.coalesce(iou_computation, 0).label(\"iou\"),\n        )\n        .select_from(joint)\n        .where(\n            and_(\n                joint.c.gt_id.isnot(None),\n                joint.c.pd_id.isnot(None),\n            )\n        )\n        .subquery()\n    )\n\n    # Order by score, iou\n    ordered_ious = db.query(ious).order_by(-ious.c.score, -ious.c.iou).all()\n\n    # Filter out repeated id's\n    gt_set = set()\n    pd_set = set()\n    ranking = {}\n    for row in ordered_ious:\n        # datum_id = row[0]\n        gt_id = row[1]\n        pd_id = row[2]\n        gt_label_id = row[3]\n        # pd_label_id = row[4]\n        score = row[5]\n        iou = row[6]\n\n        # Check if gt or pd already found\n        if gt_id not in gt_set and pd_id not in pd_set:\n            gt_set.add(gt_id)\n            pd_set.add(pd_id)\n\n            if gt_label_id not in ranking:\n                ranking[gt_label_id] = []\n\n            ranking[gt_label_id].append(\n                RankedPair(\n                    gt_id=gt_id,\n                    pd_id=pd_id,\n                    score=score,\n                    iou=iou,\n                )\n            )\n\n    # Get groundtruth labels\n    labels = {\n        label.id: schemas.Label(key=label.key, value=label.value)\n        for label in db.query(\n            Query(models.Label).filter(gt_filter).groundtruths()\n        ).all()\n    }\n\n    # Get the number of ground truths per label id\n    number_of_ground_truths = {}\n    for id in labels:\n        gt_filter.label_ids = [id]\n        number_of_ground_truths[id] = db.query(\n            Query(func.count(models.GroundTruth.id))\n            .filter(gt_filter)\n            .groundtruths()\n        ).scalar()\n\n    # Compute AP\n    detection_metrics = _ap(\n        sorted_ranked_pairs=ranking,\n        number_of_ground_truths=number_of_ground_truths,\n        labels=labels,\n        iou_thresholds=settings.parameters.iou_thresholds_to_compute,\n    )\n\n    # now extend to the averaged AP metrics and mAP metric\n    mean_detection_metrics = _compute_mean_detection_metrics_from_aps(\n        detection_metrics\n    )\n    detection_metrics_ave_over_ious = (\n        _compute_detection_metrics_averaged_over_ious_from_aps(\n            detection_metrics\n        )\n    )\n    mean_detection_metrics_ave_over_ious = (\n        _compute_mean_detection_metrics_from_aps(\n            detection_metrics_ave_over_ious\n        )\n    )\n\n    # filter out only specified ious\n    detection_metrics = [\n        m\n        for m in detection_metrics\n        if m.iou in settings.parameters.iou_thresholds_to_keep\n    ]\n    mean_detection_metrics = [\n        m\n        for m in mean_detection_metrics\n        if m.iou in settings.parameters.iou_thresholds_to_keep\n    ]\n\n    return (\n        detection_metrics\n        + mean_detection_metrics\n        + detection_metrics_ave_over_ious\n        + mean_detection_metrics_ave_over_ious\n    )\n</code></pre>"},{"location":"references/API/Backend/Metrics/Detection/#velour_api.backend.metrics.detection.create_detection_evaluation","title":"<code>velour_api.backend.metrics.detection.create_detection_evaluation(db, job_request)</code>","text":"<p>Create a detection evaluation job.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>job_request</code> <code>EvaluationJob</code> <p>The job request to create an evaluation for.</p> required <p>Returns:</p> Type Description <code>Tuple</code> <p>A tuple containing the evaluation settings id, the unique groundtruths, and unique predictions.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the job's task type is incorrect. If the settings passed to the job are for another type of evaluation.</p> <code>ValueError</code> <p>If the evaluation contains an inappropriate filter.</p> Source code in <code>api/velour_api/backend/metrics/detection.py</code> <pre><code>def create_detection_evaluation(\n    db: Session,\n    job_request: schemas.EvaluationJob,\n) -&gt; tuple:\n    \"\"\"\n    Create a detection evaluation job.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    job_request : schemas.EvaluationJob\n        The job request to create an evaluation for.\n\n    Returns\n    ----------\n    Tuple\n        A tuple containing the evaluation settings id, the unique groundtruths, and unique predictions.\n\n    Raises\n    ----------\n    TypeError\n        If the job's task type is incorrect.\n        If the settings passed to the job are for another type of evaluation.\n    ValueError\n        If the evaluation contains an inappropriate filter.\n\n    \"\"\"\n    # check matching task_type\n    if job_request.task_type != enums.TaskType.DETECTION:\n        raise TypeError(\n            \"Invalid task_type, please choose an evaluation method that supports object detection\"\n        )\n\n    # validate parameters\n    if not job_request.settings.parameters:\n        job_request.settings.parameters = schemas.DetectionParameters()\n\n    # validate filters\n    if not job_request.settings.filters:\n        job_request.settings.filters = schemas.Filter()\n    else:\n        if (\n            job_request.settings.filters.dataset_names is not None\n            or job_request.settings.filters.dataset_metadata is not None\n            or job_request.settings.filters.dataset_geospatial is not None\n            or job_request.settings.filters.models_names is not None\n            or job_request.settings.filters.models_metadata is not None\n            or job_request.settings.filters.models_geospatial is not None\n            or job_request.settings.filters.prediction_scores is not None\n            or job_request.settings.filters.task_types is not None\n        ):\n            raise ValueError(\n                \"Evaluation filter objects should not include any dataset, model, prediction score or task type filters.\"\n            )\n\n    # load sql objects\n    dataset = core.get_dataset(db, job_request.dataset)\n    model = core.get_model(db, job_request.model)\n\n    # determine annotation types\n    (\n        groundtruth_type,\n        prediction_type,\n    ) = _get_annotation_types_for_computation(\n        db, dataset, model, job_request.settings.filters\n    )\n\n    # create groundtruth label filter\n    groundtruth_label_filter = job_request.settings.filters.model_copy()\n    groundtruth_label_filter.dataset_names = [job_request.dataset]\n    groundtruth_label_filter.annotation_types = [groundtruth_type]\n\n    # create prediction label filter\n    prediction_label_filter = job_request.settings.filters.model_copy()\n    prediction_label_filter.dataset_names = [job_request.dataset]\n    prediction_label_filter.models_names = [model.name]\n    prediction_label_filter.annotation_types = [prediction_type]\n\n    # get disjoint sets\n    groundtruth_unique, prediction_unique = _get_disjoint_label_sets(\n        db, groundtruth_label_filter, prediction_label_filter\n    )\n\n    # create evaluation settings row\n    es = get_or_create_row(\n        db,\n        models.Evaluation,\n        mapping={\n            \"dataset_id\": dataset.id,\n            \"model_id\": model.id,\n            \"task_type\": enums.TaskType.DETECTION,\n            \"settings\": job_request.settings.model_dump(),\n        },\n    )\n\n    return es.id, groundtruth_unique, prediction_unique\n</code></pre>"},{"location":"references/API/Backend/Metrics/Detection/#velour_api.backend.metrics.detection.create_detection_metrics","title":"<code>velour_api.backend.metrics.detection.create_detection_metrics(db, job_id)</code>","text":"<p>Create detection metrics. This function is intended to be run using FastAPI's <code>BackgroundTasks</code>.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>job_id</code> <code>int</code> <p>The job ID to create metrics for.</p> required Source code in <code>api/velour_api/backend/metrics/detection.py</code> <pre><code>def create_detection_metrics(\n    db: Session,\n    job_id: int,\n):\n    \"\"\"\n    Create detection metrics. This function is intended to be run using FastAPI's `BackgroundTasks`.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    job_id : int\n        The job ID to create metrics for.\n    \"\"\"\n    evaluation = db.scalar(\n        select(models.Evaluation).where(models.Evaluation.id == job_id)\n    )\n\n    # unpack job request\n    job_request = schemas.EvaluationJob(\n        dataset=evaluation.dataset.name,\n        model=evaluation.model.name,\n        task_type=evaluation.task_type,\n        settings=schemas.EvaluationSettings(**evaluation.settings),\n        id=evaluation.id,\n    )\n\n    # configure filters\n    if not job_request.settings.filters:\n        job_request.settings.filters = schemas.Filter()\n    job_request.settings.filters.task_types = [enums.TaskType.DETECTION]\n\n    dataset = core.get_dataset(db, job_request.dataset)\n    model = core.get_model(db, job_request.model)\n\n    groundtruth_type = core.get_annotation_type(db, dataset, None)\n    prediction_type = core.get_annotation_type(db, dataset, model)\n\n    # Get user-specified annotation type\n    if job_request.settings.filters.annotation_types:\n        target_type = max(\n            job_request.settings.filters.annotation_types, key=lambda x: x\n        )\n    else:\n        target_type = min([groundtruth_type, prediction_type])\n\n    # Convert geometries to target type (if required)\n    core.convert_geometry(\n        db,\n        dataset=dataset,\n        model=model,\n        dataset_source_type=groundtruth_type,\n        model_source_type=prediction_type,\n        evaluation_target_type=target_type,\n    )\n\n    metrics = compute_detection_metrics(\n        db=db,\n        dataset=dataset,\n        model=model,\n        settings=job_request.settings,\n        target_type=target_type,\n    )\n\n    metric_mappings = create_metric_mappings(\n        db=db, metrics=metrics, evaluation_id=job_id\n    )\n\n    for mapping in metric_mappings:\n        # ignore value since the other columns are unique identifiers\n        # and have empircally noticed value can slightly change due to floating\n        # point errors\n\n        get_or_create_row(\n            db, models.Metric, mapping, columns_to_ignore=[\"value\"]\n        )\n    db.commit()\n</code></pre>"},{"location":"references/API/Backend/Metrics/Segmentation/","title":"Segmentation","text":""},{"location":"references/API/Backend/Metrics/Segmentation/#velour_api.backend.metrics.segmentation-classes","title":"Classes","text":""},{"location":"references/API/Backend/Metrics/Segmentation/#velour_api.backend.metrics.segmentation-functions","title":"Functions","text":""},{"location":"references/API/Backend/Metrics/Segmentation/#velour_api.backend.metrics.segmentation.create_semantic_segmentation_evaluation","title":"<code>velour_api.backend.metrics.segmentation.create_semantic_segmentation_evaluation(db, job_request)</code>","text":"<p>Create a semantic segmentation evaluation job.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>job_request</code> <code>EvaluationJob</code> <p>The job request to create an evaluation for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The evaluation id.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the job's task type is incorrect. If the settings passed to the job are for another type of evaluation.</p> <code>ValueError</code> <p>If the evaluation contains an inappropriate filter.</p> Source code in <code>api/velour_api/backend/metrics/segmentation.py</code> <pre><code>def create_semantic_segmentation_evaluation(\n    db: Session, job_request: EvaluationJob\n) -&gt; int:\n    \"\"\"\n    Create a semantic segmentation evaluation job.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    job_request : schemas.EvaluationJob\n        The job request to create an evaluation for.\n\n    Returns\n    ----------\n    int\n        The evaluation id.\n\n    Raises\n    ----------\n    TypeError\n        If the job's task type is incorrect.\n        If the settings passed to the job are for another type of evaluation.\n    ValueError\n        If the evaluation contains an inappropriate filter.\n    \"\"\"\n    # check matching task_type\n    if job_request.task_type != enums.TaskType.SEGMENTATION:\n        raise TypeError(\n            \"Invalid task_type, please choose an evaluation method that supports semantic segmentation\"\n        )\n\n    # validate parameters\n    if job_request.settings.parameters:\n        raise ValueError(\n            \"Semantic segmentation evaluations do not take parametric input.\"\n        )\n\n    # validate filters\n    if not job_request.settings.filters:\n        job_request.settings.filters = schemas.Filter()\n    else:\n        if (\n            job_request.settings.filters.dataset_names is not None\n            or job_request.settings.filters.dataset_metadata is not None\n            or job_request.settings.filters.dataset_geospatial is not None\n            or job_request.settings.filters.models_names is not None\n            or job_request.settings.filters.models_metadata is not None\n            or job_request.settings.filters.models_geospatial is not None\n            or job_request.settings.filters.prediction_scores is not None\n            or job_request.settings.filters.task_types is not None\n            or job_request.settings.filters.annotation_types is not None\n        ):\n            raise ValueError(\n                \"Evaluation filter objects should not include any dataset, model, prediction score or task type filters.\"\n            )\n\n    dataset = core.get_dataset(db, job_request.dataset)\n    model = core.get_model(db, job_request.model)\n\n    es = get_or_create_row(\n        db,\n        models.Evaluation,\n        mapping={\n            \"dataset_id\": dataset.id,\n            \"model_id\": model.id,\n            \"task_type\": enums.TaskType.SEGMENTATION,\n            \"settings\": job_request.settings.model_dump(),\n        },\n    )\n\n    return es.id\n</code></pre>"},{"location":"references/API/Backend/Metrics/Segmentation/#velour_api.backend.metrics.segmentation.create_semantic_segmentation_metrics","title":"<code>velour_api.backend.metrics.segmentation.create_semantic_segmentation_metrics(db, job_request, job_id)</code>","text":"<p>Create semantic segmentation metrics. This function is intended to be run using FastAPI's <code>BackgroundTasks</code>.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>job_request</code> <code>EvaluationJob</code> <p>The evaluation job.</p> required <code>job_id</code> <code>int</code> <p>The job ID to create metrics for.</p> required Source code in <code>api/velour_api/backend/metrics/segmentation.py</code> <pre><code>def create_semantic_segmentation_metrics(\n    db: Session,\n    job_request: EvaluationJob,\n    job_id: int,\n) -&gt; int:\n    \"\"\"\n    Create semantic segmentation metrics. This function is intended to be run using FastAPI's `BackgroundTasks`.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    job_request : EvaluationJob\n        The evaluation job.\n    job_id : int\n        The job ID to create metrics for.\n    \"\"\"\n    evaluation = db.scalar(\n        select(models.Evaluation).where(models.Evaluation.id == job_id)\n    )\n\n    # unpack job request\n    job_request = schemas.EvaluationJob(\n        dataset=evaluation.dataset.name,\n        model=evaluation.model.name,\n        task_type=evaluation.task_type,\n        settings=schemas.EvaluationSettings(**evaluation.settings),\n        id=evaluation.id,\n    )\n\n    # configure filters\n    if not job_request.settings.filters:\n        job_request.settings.filters = schemas.Filter()\n    job_request.settings.filters.task_types = [enums.TaskType.SEGMENTATION]\n    job_request.settings.filters.dataset_names = [job_request.dataset]\n    job_request.settings.filters.annotation_types = [\n        enums.AnnotationType.RASTER\n    ]\n\n    metrics = _compute_segmentation_metrics(\n        db,\n        job_request,\n    )\n    metric_mappings = create_metric_mappings(db, metrics, job_id)\n    for mapping in metric_mappings:\n        # ignore value since the other columns are unique identifiers\n        # and have empirically noticed value can slightly change due to floating\n        # point errors\n        get_or_create_row(\n            db,\n            models.Metric,\n            mapping,\n            columns_to_ignore=[\"value\"],\n        )\n\n    return job_id\n</code></pre>"},{"location":"references/API/Backend/Metrics/Utilities/","title":"Utilities","text":""},{"location":"references/API/Backend/Metrics/Utilities/#velour_api.backend.metrics.metric_utils-functions","title":"Functions","text":""},{"location":"references/API/Backend/Metrics/Utilities/#velour_api.backend.metrics.metric_utils.create_metric_mappings","title":"<code>velour_api.backend.metrics.metric_utils.create_metric_mappings(db, metrics, evaluation_id)</code>","text":"<p>Create metric mappings from a list of metrics.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>metrics</code> <code>List</code> <p>A list of metrics to create mappings for.</p> required <code>evaluation_id</code> <code>int</code> <p>The id of the evaluation job.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A list of metric mappings.</p> Source code in <code>api/velour_api/backend/metrics/metric_utils.py</code> <pre><code>def create_metric_mappings(\n    db: Session,\n    metrics: list[\n        schemas.APMetric\n        | schemas.APMetricAveragedOverIOUs\n        | schemas.mAPMetric\n        | schemas.mAPMetricAveragedOverIOUs\n    ],\n    evaluation_id: int,\n) -&gt; list[dict]:\n    \"\"\"\n    Create metric mappings from a list of metrics.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    metrics : List\n        A list of metrics to create mappings for.\n    evaluation_id : int\n        The id of the evaluation job.\n\n    Returns\n    ----------\n    List[Dict]\n        A list of metric mappings.\n    \"\"\"\n    labels = set(\n        [\n            (metric.label.key, metric.label.value)\n            for metric in metrics\n            if hasattr(metric, \"label\")\n        ]\n    )\n    label_map = {\n        (label[0], label[1]): core.get_label(\n            db, label=schemas.Label(key=label[0], value=label[1])\n        ).id\n        for label in labels\n    }\n\n    ret = []\n    for metric in metrics:\n        if hasattr(metric, \"label\"):\n            ret.append(\n                metric.db_mapping(\n                    label_id=label_map[(metric.label.key, metric.label.value)],\n                    evaluation_id=evaluation_id,\n                )\n            )\n        else:\n            ret.append(metric.db_mapping(evaluation_id=evaluation_id))\n\n    return ret\n</code></pre>"},{"location":"references/API/Backend/Metrics/Utilities/#velour_api.backend.metrics.metric_utils.get_evaluation_jobs","title":"<code>velour_api.backend.metrics.metric_utils.get_evaluation_jobs(db, job_ids=None, dataset_names=None, model_names=None, settings=None)</code>","text":"<p>Get evaluation jobs that conform to input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>job_ids</code> <code>list[int] | None</code> <p>A list of job ids to get evaluation jobs for.</p> <code>None</code> <code>dataset_names</code> <code>list[str] | None</code> <p>A list of dataset names to get evaluation jobs for.</p> <code>None</code> <code>model_names</code> <code>list[str] | None</code> <p>A list of model names to get evaluation jobs for.</p> <code>None</code> <code>settings</code> <code>list[EvaluationSettings] | None</code> <p>A list of evaluation settings to get evaluation jobs for.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[EvaluationJob]</code> <p>A list of evaluation jobs.</p> Source code in <code>api/velour_api/backend/metrics/metric_utils.py</code> <pre><code>def get_evaluation_jobs(\n    db: Session,\n    job_ids: list[int] | None = None,\n    dataset_names: list[str] | None = None,\n    model_names: list[str] | None = None,\n    settings: list[schemas.EvaluationSettings] | None = None,\n) -&gt; list[schemas.EvaluationJob]:\n    \"\"\"\n    Get evaluation jobs that conform to input arguments.\n\n    Parameters\n    ----------\n    job_ids: list[int] | None\n        A list of job ids to get evaluation jobs for.\n    dataset_names: list[str] | None\n        A list of dataset names to get evaluation jobs for.\n    model_names: list[str] | None\n        A list of model names to get evaluation jobs for.\n    settings: list[schemas.EvaluationSettings] | None\n        A list of evaluation settings to get evaluation jobs for.\n\n\n    Returns\n    ----------\n    List[schemas.EvaluationJob]\n        A list of evaluation jobs.\n    \"\"\"\n\n    # argument expressions\n    expr_job_ids = models.Evaluation.id.in_(job_ids) if job_ids else None\n    expr_datasets = (\n        models.Dataset.name.in_(dataset_names) if dataset_names else None\n    )\n    expr_models = models.Model.name.in_(model_names) if model_names else None\n    expr_settings = (\n        models.Evaluation.settings.in_(\n            [setting.model_dump() for setting in settings]\n        )\n        if settings\n        else None\n    )\n\n    # aggregate valid expressions\n    expressions = [\n        expr\n        for expr in [expr_job_ids, expr_datasets, expr_models, expr_settings]\n        if expr is not None\n    ]\n\n    # query evaluations\n    evaluation_rows = db.scalars(\n        select(models.Evaluation)\n        .join(\n            models.Dataset,\n            models.Dataset.id == models.Evaluation.dataset_id,\n        )\n        .join(\n            models.Model,\n            models.Model.id == models.Evaluation.model_id,\n        )\n        .where(*expressions)\n    ).all()\n\n    return [\n        schemas.EvaluationJob(\n            dataset=db.scalar(\n                select(models.Dataset.name).where(\n                    models.Dataset.id == evaluation.dataset_id\n                )\n            ),\n            model=db.scalar(\n                select(models.Model.name).where(\n                    models.Model.id == evaluation.model_id\n                )\n            ),\n            settings=evaluation.settings,\n            task_type=evaluation.task_type,\n            id=evaluation.id,\n        )\n        for evaluation in evaluation_rows\n    ]\n</code></pre>"},{"location":"references/API/Backend/Metrics/Utilities/#velour_api.backend.metrics.metric_utils.get_evaluations","title":"<code>velour_api.backend.metrics.metric_utils.get_evaluations(db, job_ids=None, dataset_names=None, model_names=None, settings=None)</code>","text":"<p>Get evaluations that conform to input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>job_ids</code> <code>list[int] | None</code> <p>A list of job ids to get evaluations for.</p> <code>None</code> <code>dataset_names</code> <code>list[str] | None</code> <p>A list of dataset names to get evaluations for.</p> <code>None</code> <code>model_names</code> <code>list[str] | None</code> <p>A list of model names to get evaluations for.</p> <code>None</code> <code>settings</code> <code>list[EvaluationSettings] | None</code> <p>A list of evaluation settings to get evaluations for.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Evaluation]</code> <p>A list of evaluations.</p> Source code in <code>api/velour_api/backend/metrics/metric_utils.py</code> <pre><code>def get_evaluations(\n    db: Session,\n    job_ids: list[int] | None = None,\n    dataset_names: list[str] | None = None,\n    model_names: list[str] | None = None,\n    settings: list[schemas.EvaluationSettings] | None = None,\n) -&gt; list[schemas.Evaluation]:\n    \"\"\"\n    Get evaluations that conform to input arguments.\n\n    Parameters\n    ----------\n    job_ids: list[int] | None\n        A list of job ids to get evaluations for.\n    dataset_names: list[str] | None\n        A list of dataset names to get evaluations for.\n    model_names: list[str] | None\n        A list of model names to get evaluations for.\n    settings: list[schemas.EvaluationSettings] | None\n        A list of evaluation settings to get evaluations for.\n\n\n    Returns\n    ----------\n    List[schemas.Evaluation]\n        A list of evaluations.\n    \"\"\"\n\n    # argument expressions\n    expr_job_ids = models.Evaluation.id.in_(job_ids) if job_ids else None\n    expr_datasets = (\n        models.Dataset.name.in_(dataset_names) if dataset_names else None\n    )\n    expr_models = models.Model.name.in_(model_names) if model_names else None\n    expr_settings = (\n        models.Evaluation.settings.in_(\n            [setting.model_dump() for setting in settings]\n        )\n        if settings\n        else None\n    )\n\n    # aggregate valid expressions\n    expressions = [\n        expr\n        for expr in [expr_job_ids, expr_datasets, expr_models, expr_settings]\n        if expr is not None\n    ]\n\n    # query evaluations\n    evaluation_rows = db.scalars(\n        select(models.Evaluation)\n        .join(\n            models.Dataset,\n            models.Dataset.id == models.Evaluation.dataset_id,\n        )\n        .join(\n            models.Model,\n            models.Model.id == models.Evaluation.model_id,\n        )\n        .where(*expressions)\n    ).all()\n\n    return [\n        schemas.Evaluation(\n            dataset=db.scalar(\n                select(models.Dataset.name).where(\n                    models.Dataset.id == evaluation.dataset_id\n                )\n            ),\n            model=db.scalar(\n                select(models.Model.name).where(\n                    models.Model.id == evaluation.model_id\n                )\n            ),\n            settings=evaluation.settings,\n            job_id=evaluation.id,\n            status=\"unknown\",  # unknown to backend\n            metrics=[\n                _db_metric_to_pydantic_metric(metric)\n                for metric in evaluation.metrics\n            ],\n            confusion_matrices=[\n                schemas.ConfusionMatrixResponse(\n                    label_key=matrix.label_key,\n                    entries=[\n                        schemas.ConfusionMatrixEntry(**entry)\n                        for entry in matrix.value\n                    ],\n                )\n                for matrix in evaluation.confusion_matrices\n            ],\n        )\n        for evaluation in evaluation_rows\n    ]\n</code></pre>"},{"location":"references/API/Backend/Metrics/Utilities/#velour_api.backend.metrics.metric_utils.get_or_create_row","title":"<code>velour_api.backend.metrics.metric_utils.get_or_create_row(db, model_class, mapping, columns_to_ignore=None)</code>","text":"<p>Tries to get the row defined by mapping. If that exists then its mapped object is returned. Otherwise a row is created by <code>mapping</code> and the newly created object is returned.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The database Session to query against.</p> required <code>model_class</code> <code>type</code> <p>The type of model.</p> required <code>mapping</code> <code>dict</code> <p>The mapping to use when creating the row.</p> required <code>columns_to_ignore</code> <code>List[str]</code> <p>Specifies any columns to ignore in forming the WHERE expression. This can be used for numerical columns that might slightly differ but are essentially the same.</p> <code>None</code> <p>Returns:</p> Type Description <code>any</code> <p>A model class object.</p> Source code in <code>api/velour_api/backend/metrics/metric_utils.py</code> <pre><code>def get_or_create_row(\n    db: Session,\n    model_class: type,\n    mapping: dict,\n    columns_to_ignore: list[str] = None,\n) -&gt; any:\n    \"\"\"\n    Tries to get the row defined by mapping. If that exists then its mapped object is returned. Otherwise a row is created by `mapping` and the newly created object is returned.\n\n    Parameters\n    ----------\n    db : Session\n        The database Session to query against.\n    model_class : type\n        The type of model.\n    mapping : dict\n        The mapping to use when creating the row.\n    columns_to_ignore : List[str]\n        Specifies any columns to ignore in forming the WHERE expression. This can be used for numerical columns that might slightly differ but are essentially the same.\n\n    Returns\n    ----------\n    any\n        A model class object.\n    \"\"\"\n    columns_to_ignore = columns_to_ignore or []\n\n    # create the query from the mapping\n    where_expressions = [\n        (getattr(model_class, k) == v)\n        for k, v in mapping.items()\n        if k not in columns_to_ignore\n    ]\n    where_expression = where_expressions[0]\n    for exp in where_expressions[1:]:\n        where_expression = where_expression &amp; exp\n\n    db_element = db.scalar(select(model_class).where(where_expression))\n\n    if not db_element:\n        db_element = model_class(**mapping)\n        db.add(db_element)\n        db.flush()\n        db.commit()\n\n    return db_element\n</code></pre>"},{"location":"references/API/Schemas/Auth/","title":"Auth","text":""},{"location":"references/API/Schemas/Auth/#velour_api.schemas.auth-classes","title":"Classes","text":""},{"location":"references/API/Schemas/Auth/#velour_api.schemas.auth.User","title":"<code>velour_api.schemas.auth.User</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Defines an authorized user.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>The user's email address.</p> Source code in <code>api/velour_api/schemas/auth.py</code> <pre><code>class User(BaseModel):\n    \"\"\"\n    Defines an authorized user.\n\n    Attributes\n    ----------\n    email : str\n        The user's email address.\n    \"\"\"\n\n    email: str | None = None\n</code></pre>"},{"location":"references/API/Schemas/Core/","title":"Core","text":""},{"location":"references/API/Schemas/Core/#velour_api.schemas.core-classes","title":"Classes","text":""},{"location":"references/API/Schemas/Core/#velour_api.schemas.core.Annotation","title":"<code>velour_api.schemas.core.Annotation</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class used to annotate <code>GroundTruths</code> and <code>Predictions</code>.</p> <p>Attributes:</p> Name Type Description <code>task_type</code> <code>TaskType</code> <p>The task type associated with the <code>Annotation</code>.</p> <code>labels</code> <code>List[Label]</code> <p>A list of labels to use for the <code>Annotation</code>.</p> <code>metadata</code> <code>Dict[str, Union[int, float, str]]</code> <p>A dictionary of metadata that describes the <code>Annotation</code>.</p> <code>bounding_box</code> <code>BoundingBox</code> <p>A bounding box to assign to the <code>Annotation</code>.</p> <code>polygon</code> <code>Polygon</code> <p>A polygon to assign to the <code>Annotation</code>.</p> <code>multipolygon</code> <code>MultiPolygon</code> <p>A multipolygon to assign to the <code>Annotation</code>.</p> <code>raster</code> <code>Raster</code> <p>A raster to assign to the <code>Annotation</code>.</p> <code>jsonb</code> <code>Dict</code> <p>A jsonb to assign to the <code>Annotation</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no labels are passed. If the same label appears in two annotations.</p> Source code in <code>api/velour_api/schemas/core.py</code> <pre><code>class Annotation(BaseModel):\n    \"\"\"\n    A class used to annotate `GroundTruths` and `Predictions`.\n\n    Attributes\n    ----------\n    task_type: TaskType\n        The task type associated with the `Annotation`.\n    labels: List[Label]\n        A list of labels to use for the `Annotation`.\n    metadata: Dict[str, Union[int, float, str]]\n        A dictionary of metadata that describes the `Annotation`.\n    bounding_box: BoundingBox\n        A bounding box to assign to the `Annotation`.\n    polygon: Polygon\n        A polygon to assign to the `Annotation`.\n    multipolygon: MultiPolygon\n        A multipolygon to assign to the `Annotation`.\n    raster: Raster\n        A raster to assign to the `Annotation`.\n    jsonb: Dict\n        A jsonb to assign to the `Annotation`.\n\n    Raises\n    ----------\n    ValueError\n        If no labels are passed.\n        If the same label appears in two annotations.\n    \"\"\"\n\n    task_type: TaskType\n    labels: list[Label]\n    metadata: dict[str, float | str] = Field(default_factory=dict)\n\n    # Geometric types\n    bounding_box: BoundingBox | None = None\n    polygon: Polygon | None = None\n    multipolygon: MultiPolygon | None = None\n    raster: Raster | None = None\n    jsonb: dict[str, str] | None = None\n\n    model_config = ConfigDict(use_enum_values=True, extra=\"forbid\")\n\n    @field_validator(\"labels\")\n    @classmethod\n    def _check_labels_not_empty(cls, v):\n        \"\"\"Validate that labels aren't empty.\"\"\"\n        if not v:\n            raise ValueError(\"`labels` cannot be empty.\")\n        return v\n</code></pre>"},{"location":"references/API/Schemas/Core/#velour_api.schemas.core.Dataset","title":"<code>velour_api.schemas.core.Dataset</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class describing a given dataset.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the dataset.</p> <code>name</code> <code>str</code> <p>The name of the dataset.</p> <code>metadata</code> <code>dict</code> <p>A dictionary of metadata that describes the dataset.</p> <code>geospatial</code> <code>dict</code> <p>A GeoJSON-style dictionary describing the geospatial coordinates of the dataset.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name is invalid.</p> Source code in <code>api/velour_api/schemas/core.py</code> <pre><code>class Dataset(BaseModel):\n    \"\"\"\n    A class describing a given dataset.\n\n    Attributes\n    ----------\n    id : int\n        The ID of the dataset.\n    name : str\n        The name of the dataset.\n    metadata :  dict\n        A dictionary of metadata that describes the dataset.\n    geospatial : dict\n        A GeoJSON-style dictionary describing the geospatial coordinates of the dataset.\n\n    Raises\n    ----------\n    ValueError\n        If the name is invalid.\n    \"\"\"\n\n    id: int | None = None\n    name: str\n    metadata: dict[str, float | str] = Field(default_factory=dict)\n    geospatial: dict[\n        str,\n        list[list[list[list[float | int]]]]\n        | list[list[list[float | int]]]\n        | list[float | int]\n        | str,\n    ] = Field(default_factory=dict)\n    model_config = ConfigDict(extra=\"forbid\")\n\n    @field_validator(\"name\")\n    @classmethod\n    def _check_name_valid(cls, v):\n        \"\"\"Validate the name field.\"\"\"\n        if not v:\n            raise ValueError(\"invalid string\")\n\n        _validate_name_format(v)\n        return v\n</code></pre>"},{"location":"references/API/Schemas/Core/#velour_api.schemas.core.Datum","title":"<code>velour_api.schemas.core.Datum</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class used to store datum about <code>GroundTruths</code> and <code>Predictions</code>.</p> <p>Attributes:</p> Name Type Description <code>uid</code> <code>str</code> <p>The UID of the <code>Datum</code>.</p> <code>metadata</code> <code>dict</code> <p>A dictionary of metadata that describes the <code>Datum</code>.</p> <code>geospatial</code> <code>dict</code> <p>A GeoJSON-style dictionary describing the geospatial coordinates of the <code>Datum</code>.</p> <code>dataset</code> <code>str</code> <p>The name of the dataset to associate the <code>Datum</code> with.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dataset or UID is invalid.</p> Source code in <code>api/velour_api/schemas/core.py</code> <pre><code>class Datum(BaseModel):\n    \"\"\"\n    A class used to store datum about `GroundTruths` and `Predictions`.\n\n    Attributes\n    ----------\n    uid : str\n        The UID of the `Datum`.\n    metadata : dict\n        A dictionary of metadata that describes the `Datum`.\n    geospatial :  dict\n        A GeoJSON-style dictionary describing the geospatial coordinates of the `Datum`.\n    dataset : str\n        The name of the dataset to associate the `Datum` with.\n\n    Raises\n    ----------\n    ValueError\n        If the dataset or UID is invalid.\n    \"\"\"\n\n    uid: str\n    dataset: str\n    metadata: dict[str, float | str] = Field(default_factory=dict)\n    geospatial: dict[\n        str,\n        list[list[list[list[float | int]]]]\n        | list[list[list[float | int]]]\n        | list[float | int]\n        | str,\n    ] = Field(default_factory=dict)\n    model_config = ConfigDict(extra=\"forbid\")\n\n    @field_validator(\"uid\")\n    @classmethod\n    def _check_uid_valid(cls, v):\n        \"\"\"Validate the UID field.\"\"\"\n\n        if not v:\n            raise ValueError(\"invalid string\")\n\n        _validate_uid_format(v)\n        return v\n\n    @field_validator(\"dataset\")\n    @classmethod\n    def _check_name_valid(cls, v):\n        \"\"\"Validate the dataset field.\"\"\"\n\n        if not v:\n            raise ValueError(\"invalid string\")\n\n        _validate_name_format(v)\n        return v\n\n    def __eq__(self, other):\n        \"\"\"\n        Defines how `Datums` are compared to one another\n\n        Parameters\n        ----------\n        other : Datum\n            The object to compare with the `Datum`.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n        \"\"\"\n        if (\n            not hasattr(other, \"uid\")\n            or not hasattr(other, \"dataset\")\n            or not hasattr(other, \"metadata\")\n            or not hasattr(other, \"geospatial\")\n        ):\n            return False\n\n        return (\n            self.uid == other.uid\n            and self.dataset == other.dataset\n            and self.geospatial == other.geospatial\n            and self.metadata == other.geospatial\n        )\n</code></pre>"},{"location":"references/API/Schemas/Core/#velour_api.schemas.core.Datum-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Core/#velour_api.schemas.core.Datum.__eq__","title":"<code>velour_api.schemas.core.Datum.__eq__(other)</code>","text":"<p>Defines how <code>Datums</code> are compared to one another</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Datum</code> <p>The object to compare with the <code>Datum</code>.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> Source code in <code>api/velour_api/schemas/core.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Defines how `Datums` are compared to one another\n\n    Parameters\n    ----------\n    other : Datum\n        The object to compare with the `Datum`.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n    \"\"\"\n    if (\n        not hasattr(other, \"uid\")\n        or not hasattr(other, \"dataset\")\n        or not hasattr(other, \"metadata\")\n        or not hasattr(other, \"geospatial\")\n    ):\n        return False\n\n    return (\n        self.uid == other.uid\n        and self.dataset == other.dataset\n        and self.geospatial == other.geospatial\n        and self.metadata == other.geospatial\n    )\n</code></pre>"},{"location":"references/API/Schemas/Core/#velour_api.schemas.core.GroundTruth","title":"<code>velour_api.schemas.core.GroundTruth</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object describing a groundtruth (e.g., a human-drawn bounding box on an image).</p> <p>Attributes:</p> Name Type Description <code>datum</code> <code>Datum</code> <p>The <code>Datum</code> associated with the <code>GroundTruth</code>.</p> <code>annotations</code> <code>List[Annotation]</code> <p>The list of <code>Annotations</code> associated with the <code>GroundTruth</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no annotaitons are passed. If the same label appears in two annotations. If any rasters don't match their metadata.</p> Source code in <code>api/velour_api/schemas/core.py</code> <pre><code>class GroundTruth(BaseModel):\n    \"\"\"\n    An object describing a groundtruth (e.g., a human-drawn bounding box on an image).\n\n    Attributes\n    ----------\n    datum : Datum\n        The `Datum` associated with the `GroundTruth`.\n    annotations : List[Annotation]\n        The list of `Annotations` associated with the `GroundTruth`.\n\n\n    Raises\n    ----------\n    ValueError\n        If no annotaitons are passed.\n        If the same label appears in two annotations.\n        If any rasters don't match their metadata.\n    \"\"\"\n\n    datum: Datum\n    annotations: list[Annotation]\n    model_config = ConfigDict(extra=\"forbid\")\n\n    @field_validator(\"annotations\")\n    @classmethod\n    def _check_annotations_not_empty(cls, v: list[Annotation]):\n        \"\"\"Validate that annotations aren't empty.\"\"\"\n        if not v:\n            raise ValueError(\"annotations is empty\")\n        return v\n\n    @field_validator(\"annotations\")\n    @classmethod\n    def _check_semantic_segmentation_annotations(cls, v: list[Annotation]):\n        \"\"\"Validate that only one label exists.\"\"\"\n        _check_semantic_segmentations_single_label(v)\n        return v\n\n    @model_validator(mode=\"after\")\n    @classmethod\n    def _validate_annotation_rasters(cls, values):\n        \"\"\"Validate any rasters on the groundtruth.\"\"\"\n        return _validate_rasters(values)\n</code></pre>"},{"location":"references/API/Schemas/Core/#velour_api.schemas.core.Model","title":"<code>velour_api.schemas.core.Model</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class describing a model that was trained on a particular dataset.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the model.</p> <code>name</code> <code>str</code> <p>The name of the model.</p> <code>metadata</code> <code>dict</code> <p>A dictionary of metadata that describes the model.</p> <code>geospatial</code> <code>dict</code> <p>A GeoJSON-style dictionary describing the geospatial metadata of the model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name is invalid.</p> Source code in <code>api/velour_api/schemas/core.py</code> <pre><code>class Model(BaseModel):\n    \"\"\"\n    A class describing a model that was trained on a particular dataset.\n\n    Attributes\n    ----------\n    id : int\n        The ID of the model.\n    name : str\n        The name of the model.\n    metadata :  dict\n        A dictionary of metadata that describes the model.\n    geospatial : dict\n        A GeoJSON-style dictionary describing the geospatial metadata of the model.\n\n    Raises\n    ----------\n    ValueError\n        If the name is invalid.\n    \"\"\"\n\n    id: int | None = None\n    name: str\n    metadata: dict[str, float | str] = Field(default_factory=dict)\n    geospatial: dict[\n        str,\n        list[list[list[list[float | int]]]]\n        | list[list[list[float | int]]]\n        | list[float | int]\n        | str,\n    ] = Field(default_factory=dict)\n    model_config = ConfigDict(extra=\"forbid\")\n\n    @field_validator(\"name\")\n    @classmethod\n    def _check_name_valid(cls, v):\n        \"\"\"Validate the name field.\"\"\"\n        if not v:\n            raise ValueError(\"invalid string\")\n\n        _validate_name_format(v)\n        return v\n</code></pre>"},{"location":"references/API/Schemas/Core/#velour_api.schemas.core.Prediction","title":"<code>velour_api.schemas.core.Prediction</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object describing a prediction (e.g., a machine-drawn bounding box on an image).</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>The name of the model that produced the <code>Prediction</code>.</p> <code>datum</code> <code>Datum</code> <p>The <code>Datum</code> associated with the <code>Prediction</code>.</p> <code>annotations</code> <code>List[Annotation]</code> <p>The list of <code>Annotations</code> associated with the <code>Prediction</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the model name is invalid. If no annotations are passed. If the same label appears in two annotations. If we're missing scores for any label. If semantic segmentations contain a score. If label scores for any key sum to more than 1.</p> Source code in <code>api/velour_api/schemas/core.py</code> <pre><code>class Prediction(BaseModel):\n    \"\"\"\n    An object describing a prediction (e.g., a machine-drawn bounding box on an image).\n\n    Attributes\n    ----------\n    model : str\n        The name of the model that produced the `Prediction`.\n    datum : Datum\n        The `Datum` associated with the `Prediction`.\n    annotations : List[Annotation]\n        The list of `Annotations` associated with the `Prediction`.\n\n    Raises\n    ----------\n    ValueError\n        If the model name is invalid.\n        If no annotations are passed.\n        If the same label appears in two annotations.\n        If we're missing scores for any label.\n        If semantic segmentations contain a score.\n        If label scores for any key sum to more than 1.\n    \"\"\"\n\n    model: str\n    datum: Datum\n    annotations: list[Annotation]\n    model_config = ConfigDict(extra=\"forbid\")\n\n    @field_validator(\"model\")\n    @classmethod\n    def _check_name_valid(cls, v):\n        \"\"\"Validate the model field.\"\"\"\n\n        if not v:\n            raise ValueError(\"invalid string\")\n        _validate_name_format(v)\n        return v\n\n    @field_validator(\"annotations\")\n    @classmethod\n    def _check_annotations(cls, v):\n        \"\"\"Validate that annotations aren't empty.\"\"\"\n\n        if not v:\n            raise ValueError(\"annotations is empty\")\n        return v\n\n    @model_validator(mode=\"after\")\n    @classmethod\n    def _validate_annotation_rasters(cls, values):\n        \"\"\"Validate any rasters on the annotation.\"\"\"\n\n        return _validate_rasters(values)\n\n    @field_validator(\"annotations\")\n    @classmethod\n    def _validate_annotation_scores(cls, v: list[Annotation]):\n        \"\"\"Check that we have scores for all the labels if the task type requires it.\"\"\"\n        for annotation in v:\n            if annotation.task_type in [\n                TaskType.CLASSIFICATION,\n                TaskType.DETECTION,\n            ]:\n                for label in annotation.labels:\n                    if label.score is None:\n                        raise ValueError(\n                            f\"Missing score for label in {annotation.task_type} task.\"\n                        )\n            elif annotation.task_type == TaskType.SEGMENTATION:\n                for label in annotation.labels:\n                    if label.score is not None:\n                        raise ValueError(\n                            \"Semantic segmentation tasks cannot have scores; only metrics with \"\n                            \"hard predictions are supported.\"\n                        )\n\n        return v\n\n    @field_validator(\"annotations\")\n    @classmethod\n    def _check_label_scores(cls, v: list[Annotation]):\n        \"\"\"Check that for classification tasks, the label scores sum to 1.\"\"\"\n        for annotation in v:\n            if annotation.task_type == TaskType.CLASSIFICATION:\n                label_keys_to_sum = {}\n                for scored_label in annotation.labels:\n                    label_key = scored_label.key\n                    if label_key not in label_keys_to_sum:\n                        label_keys_to_sum[label_key] = 0.0\n                    label_keys_to_sum[label_key] += scored_label.score\n\n                for k, total_score in label_keys_to_sum.items():\n                    if abs(total_score - 1) &gt; 1e-5:\n                        raise ValueError(\n                            \"For each label key, prediction scores must sum to 1, but\"\n                            f\" for label key {k} got scores summing to {total_score}.\"\n                        )\n        return v\n\n    @field_validator(\"annotations\")\n    @classmethod\n    def _check_semantic_segmentation_annotations(cls, v: list[Annotation]):\n        \"\"\"Validate that a label doesn't appear more than once.\"\"\"\n        _check_semantic_segmentations_single_label(v)\n        return v\n</code></pre>"},{"location":"references/API/Schemas/Filters/","title":"Filters","text":""},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters-classes","title":"Classes","text":""},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.Filter","title":"<code>velour_api.schemas.filters.Filter</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Used to filter Evaluations according to specific, user-defined criteria.</p> <p>Attributes:</p> Name Type Description <code>dataset_names</code> <code>List[str]</code> <p>A list of <code>Dataset</code> names to filter on.</p> <code>dataset_metadata</code> <code>Dict[str, List[ValueFilter]]</code> <p>A dictionary of <code>Dataset</code> metadata to filter on.</p> <code>dataset_geospatial</code> <code>List[GeospatialFilter].</code> <p>A list of <code>Dataset</code> geospatial filters to filter on.</p> <code>models_names</code> <code>List[str]</code> <p>A list of <code>Model</code> names to filter on.</p> <code>models_metadata</code> <code>Dict[str, List[ValueFilter]]</code> <p>A dictionary of <code>Model</code> metadata to filter on.</p> <code>models_geospatial</code> <code>List[GeospatialFilter]</code> <p>A list of <code>Model</code> geospatial filters to filter on.</p> <code>datum_ids</code> <code>List[str]</code> <p>A list of <code>Datum</code> UIDs to filter on.</p> <code>datum_metadata</code> <code>Dict[str, List[ValueFilter]] = None</code> <p>A dictionary of <code>Datum</code> metadata to filter on.</p> <code>datum_geospatial</code> <code>List[GeospatialFilter]</code> <p>A list of <code>Datum</code> geospatial filters to filter on.</p> <code>task_types</code> <code>List[TaskType]</code> <p>A list of task types to filter on.</p> <code>annotation_types</code> <code>List[AnnotationType]</code> <p>A list of <code>Annotation</code> types to filter on.</p> <code>annotation_geometric_area</code> <code>List[ValueFilter]</code> <p>A list of <code>ValueFilters</code> which are used to filter <code>Evaluations</code> according to the <code>Annotation</code>'s geometric area.</p> <code>annotation_metadata</code> <code>Dict[str, List[ValueFilter]]</code> <p>A dictionary of <code>Annotation</code> metadata to filter on.</p> <code>annotation_geospatial</code> <code>List[GeospatialFilter]</code> <p>A list of <code>Annotation</code> geospatial filters to filter on.</p> <code>prediction_scores</code> <code>List[ValueFilter]</code> <p>A list of <code>ValueFilters</code> which are used to filter <code>Evaluations</code> according to the <code>Model</code>'s prediction scores.</p> <code>labels</code> <code>List[Dict[str, str]]</code> <p>A dictionary of `Labels' to filter on.</p> <code>label_ids</code> <code>List[int]</code> <p>A list of <code>Label</code> IDs to filter on.</p> <code>label_keys</code> <code>List[str] = None</code> <p>A list of <code>Label</code> keys to filter on.</p> Source code in <code>api/velour_api/schemas/filters.py</code> <pre><code>class Filter(BaseModel):\n    \"\"\"\n    Used to filter Evaluations according to specific, user-defined criteria.\n\n    Attributes\n    ----------\n    dataset_names: List[str]\n        A list of `Dataset` names to filter on.\n    dataset_metadata: Dict[str, List[ValueFilter]]\n        A dictionary of `Dataset` metadata to filter on.\n    dataset_geospatial: List[GeospatialFilter].\n        A list of `Dataset` geospatial filters to filter on.\n    models_names: List[str]\n        A list of `Model` names to filter on.\n    models_metadata: Dict[str, List[ValueFilter]]\n        A dictionary of `Model` metadata to filter on.\n    models_geospatial: List[GeospatialFilter]\n        A list of `Model` geospatial filters to filter on.\n    datum_ids: List[str]\n        A list of `Datum` UIDs to filter on.\n    datum_metadata: Dict[str, List[ValueFilter]] = None\n        A dictionary of `Datum` metadata to filter on.\n    datum_geospatial: List[GeospatialFilter]\n        A list of `Datum` geospatial filters to filter on.\n    task_types: List[TaskType]\n        A list of task types to filter on.\n    annotation_types: List[AnnotationType]\n        A list of `Annotation` types to filter on.\n    annotation_geometric_area: List[ValueFilter]\n        A list of `ValueFilters` which are used to filter `Evaluations` according to the `Annotation`'s geometric area.\n    annotation_metadata: Dict[str, List[ValueFilter]]\n        A dictionary of `Annotation` metadata to filter on.\n    annotation_geospatial: List[GeospatialFilter]\n        A list of `Annotation` geospatial filters to filter on.\n    prediction_scores: List[ValueFilter]\n        A list of `ValueFilters` which are used to filter `Evaluations` according to the `Model`'s prediction scores.\n    labels: List[Dict[str, str]]\n        A dictionary of `Labels' to filter on.\n    label_ids: List[int]\n        A list of `Label` IDs to filter on.\n    label_keys: List[str] = None\n        A list of `Label` keys to filter on.\n    \"\"\"\n\n    # datasets\n    dataset_names: list[str] | None = None\n    dataset_metadata: dict[\n        str, StringFilter | list[NumericFilter]\n    ] | None = None\n    dataset_geospatial: list[GeospatialFilter] | None = None\n\n    # models\n    models_names: list[str] | None = None\n    models_metadata: dict[\n        str, StringFilter | list[NumericFilter]\n    ] | None = None\n    models_geospatial: list[GeospatialFilter] | None = None\n\n    # datums\n    datum_ids: list[\n        int\n    ] | None = None  # This should be used sparingly and with small lists.\n    datum_uids: list[str] | None = None\n    datum_metadata: dict[str, StringFilter | list[NumericFilter]] | None = None\n    datum_geospatial: list[GeospatialFilter] | None = None\n\n    # annotations\n    task_types: list[TaskType] | None = None\n    annotation_types: list[AnnotationType] | None = None\n    annotation_geometric_area: list[NumericFilter] | None = None\n    annotation_metadata: dict[\n        str, StringFilter | list[NumericFilter]\n    ] | None = None\n    annotation_geospatial: list[GeospatialFilter] | None = None\n\n    # predictions\n    prediction_scores: list[NumericFilter] | None = None\n\n    # labels\n    labels: list[dict[str, str]] | None = None\n    label_ids: list[int] | None = None\n    label_keys: list[str] | None = None\n\n    # pydantic settings\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.GeospatialFilter","title":"<code>velour_api.schemas.filters.GeospatialFilter</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Used to filter on geospatial coordinates.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>GeoJSON</code> <p>A dictionary containing a Point, Polygon, or MultiPolygon. Mirrors <code>shapely's</code> <code>GeoJSON</code> format.</p> <code>operator</code> <code>str</code> <p>The operator to use for comparison. Should be one of <code>intersect</code>, <code>inside</code>, or <code>outside</code>.</p> Source code in <code>api/velour_api/schemas/filters.py</code> <pre><code>class GeospatialFilter(BaseModel):\n    \"\"\"\n    Used to filter on geospatial coordinates.\n\n    Attributes\n    ----------\n    value : GeoJSON\n        A dictionary containing a Point, Polygon, or MultiPolygon. Mirrors `shapely's` `GeoJSON` format.\n    operator : str\n        The operator to use for comparison. Should be one of `intersect`, `inside`, or `outside`.\n\n    \"\"\"\n\n    value: GeoJSON\n    operator: str = \"intersect\"\n\n    @field_validator(\"operator\")\n    @classmethod\n    def _validate_comparison_operator(cls, op: str) -&gt; str:\n        \"\"\"Validate the operator.\"\"\"\n        allowed_operators = [\"inside\", \"outside\", \"intersect\"]\n        if op not in allowed_operators:\n            raise ValueError(\n                f\"Invalid comparison operator '{op}'. Allowed operators are {', '.join(allowed_operators)}.\"\n            )\n        return op\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        Checks that two `GeospatialFilters` are equivalent.\n\n        Parameters\n        ----------\n        other : GeospatialFilter\n            The object to compare against.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n\n        Raises\n        ----------\n        TypeError\n            When comparing against an object that isn't a `GeospatialFilter`.\n        \"\"\"\n        if not isinstance(other, GeospatialFilter):\n            raise TypeError(\"expected GeospatialFilter\")\n        return (\n            self.value == other.value,\n            self.operator == other.operator,\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Hashes a `GeospatialFilter`.\n\n        Returns\n        ----------\n        int\n            A hashed integer.\n        \"\"\"\n        return hash(f\"Value:{self.value.model_dump_json},Op:{self.operator}\")\n</code></pre>"},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.GeospatialFilter-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.GeospatialFilter.__eq__","title":"<code>velour_api.schemas.filters.GeospatialFilter.__eq__(other)</code>","text":"<p>Checks that two <code>GeospatialFilters</code> are equivalent.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>GeospatialFilter</code> <p>The object to compare against.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>When comparing against an object that isn't a <code>GeospatialFilter</code>.</p> Source code in <code>api/velour_api/schemas/filters.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Checks that two `GeospatialFilters` are equivalent.\n\n    Parameters\n    ----------\n    other : GeospatialFilter\n        The object to compare against.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n\n    Raises\n    ----------\n    TypeError\n        When comparing against an object that isn't a `GeospatialFilter`.\n    \"\"\"\n    if not isinstance(other, GeospatialFilter):\n        raise TypeError(\"expected GeospatialFilter\")\n    return (\n        self.value == other.value,\n        self.operator == other.operator,\n    )\n</code></pre>"},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.GeospatialFilter.__hash__","title":"<code>velour_api.schemas.filters.GeospatialFilter.__hash__()</code>","text":"<p>Hashes a <code>GeospatialFilter</code>.</p> <p>Returns:</p> Type Description <code>int</code> <p>A hashed integer.</p> Source code in <code>api/velour_api/schemas/filters.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Hashes a `GeospatialFilter`.\n\n    Returns\n    ----------\n    int\n        A hashed integer.\n    \"\"\"\n    return hash(f\"Value:{self.value.model_dump_json},Op:{self.operator}\")\n</code></pre>"},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.NumericFilter","title":"<code>velour_api.schemas.filters.NumericFilter</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Used to filter on numeric values that meet some user-defined condition.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>The value to compare the specific field against.</p> <code>operator</code> <code>str</code> <p>The operator to use for comparison. Should be one of <code>[\"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\", \"==\", \"!=\"]</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>operator</code> doesn't match one of the allowed patterns.</p> Source code in <code>api/velour_api/schemas/filters.py</code> <pre><code>class NumericFilter(BaseModel):\n    \"\"\"\n    Used to filter on numeric values that meet some user-defined condition.\n\n    Attributes\n    ----------\n    value : float\n        The value to compare the specific field against.\n    operator : str\n        The operator to use for comparison. Should be one of `[\"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\", \"==\", \"!=\"]`.\n\n    Raises\n    ------\n    ValueError\n        If the `operator` doesn't match one of the allowed patterns.\n    \"\"\"\n\n    value: float\n    operator: str = \"==\"\n\n    @field_validator(\"operator\")\n    @classmethod\n    def _validate_comparison_operator(cls, op: str) -&gt; str:\n        \"\"\"Validate the operator.\"\"\"\n        allowed_operators = [\"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\", \"==\", \"!=\"]\n        if op not in allowed_operators:\n            raise ValueError(\n                f\"Invalid comparison operator '{op}'. Allowed operators are {', '.join(allowed_operators)}.\"\n            )\n        return op\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        Checks that two `NumericFilters` are equivalent.\n\n        Parameters\n        ----------\n        other : NumericFilter\n            The object to compare against.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n\n        Raises\n        ----------\n        TypeError\n            When comparing against an object that isn't a `NumericFilter`.\n        \"\"\"\n        if not isinstance(other, NumericFilter):\n            raise TypeError(\"expected NumericFilter\")\n        return (\n            self.value == other.value,\n            self.operator == other.operator,\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Hashes a `StringFilter`.\n\n        Returns\n        ----------\n        int\n            A hashed integer.\n        \"\"\"\n        return hash(f\"Value:{self.value},Op:{self.operator}\")\n</code></pre>"},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.NumericFilter-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.NumericFilter.__eq__","title":"<code>velour_api.schemas.filters.NumericFilter.__eq__(other)</code>","text":"<p>Checks that two <code>NumericFilters</code> are equivalent.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>NumericFilter</code> <p>The object to compare against.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>When comparing against an object that isn't a <code>NumericFilter</code>.</p> Source code in <code>api/velour_api/schemas/filters.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Checks that two `NumericFilters` are equivalent.\n\n    Parameters\n    ----------\n    other : NumericFilter\n        The object to compare against.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n\n    Raises\n    ----------\n    TypeError\n        When comparing against an object that isn't a `NumericFilter`.\n    \"\"\"\n    if not isinstance(other, NumericFilter):\n        raise TypeError(\"expected NumericFilter\")\n    return (\n        self.value == other.value,\n        self.operator == other.operator,\n    )\n</code></pre>"},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.NumericFilter.__hash__","title":"<code>velour_api.schemas.filters.NumericFilter.__hash__()</code>","text":"<p>Hashes a <code>StringFilter</code>.</p> <p>Returns:</p> Type Description <code>int</code> <p>A hashed integer.</p> Source code in <code>api/velour_api/schemas/filters.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Hashes a `StringFilter`.\n\n    Returns\n    ----------\n    int\n        A hashed integer.\n    \"\"\"\n    return hash(f\"Value:{self.value},Op:{self.operator}\")\n</code></pre>"},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.StringFilter","title":"<code>velour_api.schemas.filters.StringFilter</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Used to filter on string values that meet some user-defined condition.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>The value to compare the specific field against.</p> <code>operator</code> <code>str</code> <p>The operator to use for comparison. Should be one of <code>[\"==\", \"!=\"]</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>operator</code> doesn't match one of the allowed patterns.</p> Source code in <code>api/velour_api/schemas/filters.py</code> <pre><code>class StringFilter(BaseModel):\n    \"\"\"\n    Used to filter on string values that meet some user-defined condition.\n\n    Attributes\n    ----------\n    value : str\n        The value to compare the specific field against.\n    operator : str\n        The operator to use for comparison. Should be one of `[\"==\", \"!=\"]`.\n\n    Raises\n    ------\n    ValueError\n        If the `operator` doesn't match one of the allowed patterns.\n    \"\"\"\n\n    value: str\n    operator: str = \"==\"\n\n    @field_validator(\"operator\")\n    @classmethod\n    def _validate_comparison_operator(cls, op: str) -&gt; str:\n        \"\"\"Validate the operator.\"\"\"\n        allowed_operators = [\"==\", \"!=\"]\n        if op not in allowed_operators:\n            raise ValueError(\n                f\"Invalid comparison operator '{op}'. Allowed operators are {', '.join(allowed_operators)}.\"\n            )\n        return op\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        Checks that two `StringFilters` are equivalent.\n\n        Parameters\n        ----------\n        other : StringFilter\n            The object to compare against.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n\n        Raises\n        ----------\n        TypeError\n            When comparing against an object that isn't a `StringFilter`.\n        \"\"\"\n        if not isinstance(other, StringFilter):\n            raise TypeError(\"expected StringFilter\")\n        return (\n            self.value == other.value,\n            self.operator == other.operator,\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Hashes a `StringFilter`.\n\n        Returns\n        ----------\n        int\n            A hashed integer.\n        \"\"\"\n        return hash(f\"Value:{self.value},Op:{self.operator}\")\n</code></pre>"},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.StringFilter-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.StringFilter.__eq__","title":"<code>velour_api.schemas.filters.StringFilter.__eq__(other)</code>","text":"<p>Checks that two <code>StringFilters</code> are equivalent.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>StringFilter</code> <p>The object to compare against.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>When comparing against an object that isn't a <code>StringFilter</code>.</p> Source code in <code>api/velour_api/schemas/filters.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Checks that two `StringFilters` are equivalent.\n\n    Parameters\n    ----------\n    other : StringFilter\n        The object to compare against.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n\n    Raises\n    ----------\n    TypeError\n        When comparing against an object that isn't a `StringFilter`.\n    \"\"\"\n    if not isinstance(other, StringFilter):\n        raise TypeError(\"expected StringFilter\")\n    return (\n        self.value == other.value,\n        self.operator == other.operator,\n    )\n</code></pre>"},{"location":"references/API/Schemas/Filters/#velour_api.schemas.filters.StringFilter.__hash__","title":"<code>velour_api.schemas.filters.StringFilter.__hash__()</code>","text":"<p>Hashes a <code>StringFilter</code>.</p> <p>Returns:</p> Type Description <code>int</code> <p>A hashed integer.</p> Source code in <code>api/velour_api/schemas/filters.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Hashes a `StringFilter`.\n\n    Returns\n    ----------\n    int\n        A hashed integer.\n    \"\"\"\n    return hash(f\"Value:{self.value},Op:{self.operator}\")\n</code></pre>"},{"location":"references/API/Schemas/GeoJSON/","title":"GeoJSON","text":""},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson-classes","title":"Classes","text":""},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSON","title":"<code>velour_api.schemas.geojson.GeoJSON</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Wraps other GeoJSON types.</p> <p>Attributes:</p> Name Type Description <code>geometry</code> <code>GeoJSONPoint | GeoJSONPolygon | GeoJSONMultiPolygon</code> <p>The geometry type of the GeoJSON.</p> Source code in <code>api/velour_api/schemas/geojson.py</code> <pre><code>class GeoJSON(BaseModel):\n    \"\"\"\n    Wraps other GeoJSON types.\n\n    Attributes\n    ----------\n    geometry : GeoJSONPoint | GeoJSONPolygon | GeoJSONMultiPolygon\n        The geometry type of the GeoJSON.\n    \"\"\"\n\n    geometry: GeoJSONPoint | GeoJSONPolygon | GeoJSONMultiPolygon\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        \"\"\"\n        Create a GeoJSON from a dictionary.\n\n        Parameters\n        ----------\n        data : dict\n            A dictionary of GeoJSON-like data.\n\n        Returns\n        ----------\n        GeoJSON\n            A GeoJSON object.\n\n        Raises\n        ----------\n        ValueError\n            If the dict doesn't contain a \"type\" or \"coordinates\" key.\n            If the type of the GeoJSON isn't supported.\n        \"\"\"\n        if \"type\" not in data:\n            raise ValueError(\"missing geojson type\")\n        if \"coordinates\" not in data:\n            raise ValueError(\"missing geojson coordinates\")\n\n        if data[\"type\"] == \"Point\":\n            return cls(geometry=GeoJSONPoint(**data))\n        elif data[\"type\"] == \"Polygon\":\n            return cls(geometry=GeoJSONPolygon(**data))\n        elif data[\"type\"] == \"MultiPolygon\":\n            return cls(geometry=GeoJSONMultiPolygon(**data))\n        else:\n            raise ValueError(\"Unsupported type.\")\n\n    def shape(self) -&gt; Point | Polygon | MultiPolygon:\n        \"\"\"\n        Convert the GeoJSON into a geometric shape.\n\n        Returns\n        ----------\n        Point | Polygon | MultiPolygon\n            A geometric object.\n\n        Raises\n        ----------\n        ValueError\n            If the GeoJSON isn't of a recognized type.\n        \"\"\"\n        if isinstance(self.geometry, GeoJSONPoint):\n            return self.geometry.point()\n        elif isinstance(self.geometry, GeoJSONPolygon):\n            return self.geometry.polygon()\n        elif isinstance(self.geometry, GeoJSONMultiPolygon):\n            return self.geometry.multipolygon()\n        else:\n            raise ValueError\n</code></pre>"},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSON-functions","title":"Functions","text":""},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSON.from_dict","title":"<code>velour_api.schemas.geojson.GeoJSON.from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a GeoJSON from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary of GeoJSON-like data.</p> required <p>Returns:</p> Type Description <code>GeoJSON</code> <p>A GeoJSON object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dict doesn't contain a \"type\" or \"coordinates\" key. If the type of the GeoJSON isn't supported.</p> Source code in <code>api/velour_api/schemas/geojson.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict):\n    \"\"\"\n    Create a GeoJSON from a dictionary.\n\n    Parameters\n    ----------\n    data : dict\n        A dictionary of GeoJSON-like data.\n\n    Returns\n    ----------\n    GeoJSON\n        A GeoJSON object.\n\n    Raises\n    ----------\n    ValueError\n        If the dict doesn't contain a \"type\" or \"coordinates\" key.\n        If the type of the GeoJSON isn't supported.\n    \"\"\"\n    if \"type\" not in data:\n        raise ValueError(\"missing geojson type\")\n    if \"coordinates\" not in data:\n        raise ValueError(\"missing geojson coordinates\")\n\n    if data[\"type\"] == \"Point\":\n        return cls(geometry=GeoJSONPoint(**data))\n    elif data[\"type\"] == \"Polygon\":\n        return cls(geometry=GeoJSONPolygon(**data))\n    elif data[\"type\"] == \"MultiPolygon\":\n        return cls(geometry=GeoJSONMultiPolygon(**data))\n    else:\n        raise ValueError(\"Unsupported type.\")\n</code></pre>"},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSON.shape","title":"<code>velour_api.schemas.geojson.GeoJSON.shape()</code>","text":"<p>Convert the GeoJSON into a geometric shape.</p> <p>Returns:</p> Type Description <code>Point | Polygon | MultiPolygon</code> <p>A geometric object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the GeoJSON isn't of a recognized type.</p> Source code in <code>api/velour_api/schemas/geojson.py</code> <pre><code>def shape(self) -&gt; Point | Polygon | MultiPolygon:\n    \"\"\"\n    Convert the GeoJSON into a geometric shape.\n\n    Returns\n    ----------\n    Point | Polygon | MultiPolygon\n        A geometric object.\n\n    Raises\n    ----------\n    ValueError\n        If the GeoJSON isn't of a recognized type.\n    \"\"\"\n    if isinstance(self.geometry, GeoJSONPoint):\n        return self.geometry.point()\n    elif isinstance(self.geometry, GeoJSONPolygon):\n        return self.geometry.polygon()\n    elif isinstance(self.geometry, GeoJSONMultiPolygon):\n        return self.geometry.multipolygon()\n    else:\n        raise ValueError\n</code></pre>"},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSONMultiPolygon","title":"<code>velour_api.schemas.geojson.GeoJSONMultiPolygon</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes a multipolygon in geospatial coordinates.</p> <p>Attributes:</p> Name Type Description <code>types</code> <code>str</code> <p>The type of GeoJSON. Should be \"MultiPolygon\" for this class.</p> <code>coordinates</code> <code>List[List[List[List[float | int]]]]</code> <p>A list of coordinates describing where the <code>MultiPolygon</code> lies.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the type isn't correct.</p> Source code in <code>api/velour_api/schemas/geojson.py</code> <pre><code>class GeoJSONMultiPolygon(BaseModel):\n    \"\"\"\n    Describes a multipolygon in geospatial coordinates.\n\n    Attributes\n    ----------\n    types : str\n        The type of GeoJSON. Should be \"MultiPolygon\" for this class.\n    coordinates : List[List[List[List[float | int]]]]\n        A list of coordinates describing where the `MultiPolygon` lies.\n\n    Raises\n    ------\n    ValueError\n        If the type isn't correct.\n    \"\"\"\n\n    type: str\n    coordinates: list[list[list[list[float | int]]]]\n\n    @field_validator(\"type\")\n    @classmethod\n    def _check_type(cls, v):\n        if v != \"MultiPolygon\":\n            raise ValueError(\"Incorrect geometry type.\")\n\n        return v\n\n    def multipolygon(self) -&gt; MultiPolygon:\n        \"\"\"\n        Converts the GeoJSON into a MultiPolygon object.\n\n        Returns\n        ----------\n        MultiPolygon\n            A geometric multipolygon.\n\n        Raises\n        ----------\n        ValueError\n            If coordinates are empty.\n        \"\"\"\n        multipolygons = []\n        for subpolygon in self.coordinates:\n            polygons = [\n                BasicPolygon(\n                    points=[Point(x=coord[0], y=coord[1]) for coord in poly]\n                )\n                for poly in subpolygon\n            ]\n            multipolygons.append(\n                Polygon(\n                    boundary=polygons[0],\n                    holes=polygons[1:] if len(polygons) &gt; 1 else None,\n                )\n            )\n        if not multipolygons:\n            raise ValueError(\"Incorrect geometry type.\")\n        return MultiPolygon(polygons=multipolygons)\n</code></pre>"},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSONMultiPolygon-functions","title":"Functions","text":""},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSONMultiPolygon.multipolygon","title":"<code>velour_api.schemas.geojson.GeoJSONMultiPolygon.multipolygon()</code>","text":"<p>Converts the GeoJSON into a MultiPolygon object.</p> <p>Returns:</p> Type Description <code>MultiPolygon</code> <p>A geometric multipolygon.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If coordinates are empty.</p> Source code in <code>api/velour_api/schemas/geojson.py</code> <pre><code>def multipolygon(self) -&gt; MultiPolygon:\n    \"\"\"\n    Converts the GeoJSON into a MultiPolygon object.\n\n    Returns\n    ----------\n    MultiPolygon\n        A geometric multipolygon.\n\n    Raises\n    ----------\n    ValueError\n        If coordinates are empty.\n    \"\"\"\n    multipolygons = []\n    for subpolygon in self.coordinates:\n        polygons = [\n            BasicPolygon(\n                points=[Point(x=coord[0], y=coord[1]) for coord in poly]\n            )\n            for poly in subpolygon\n        ]\n        multipolygons.append(\n            Polygon(\n                boundary=polygons[0],\n                holes=polygons[1:] if len(polygons) &gt; 1 else None,\n            )\n        )\n    if not multipolygons:\n        raise ValueError(\"Incorrect geometry type.\")\n    return MultiPolygon(polygons=multipolygons)\n</code></pre>"},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSONPoint","title":"<code>velour_api.schemas.geojson.GeoJSONPoint</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes a point in geospatial coordinates.</p> <p>Attributes:</p> Name Type Description <code>types</code> <code>str</code> <p>The type of GeoJSON. Should be \"Point\" for this class.</p> <code>coordinates</code> <code>List[float | int]</code> <p>A list of coordinates describing where the <code>Point</code> lies.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the type isn't correct. If passed an incorrect number of coordinates.</p> Source code in <code>api/velour_api/schemas/geojson.py</code> <pre><code>class GeoJSONPoint(BaseModel):\n    \"\"\"\n    Describes a point in geospatial coordinates.\n\n    Attributes\n    ----------\n    types : str\n        The type of GeoJSON. Should be \"Point\" for this class.\n    coordinates : List[float | int]\n        A list of coordinates describing where the `Point` lies.\n\n    Raises\n    ------\n    ValueError\n        If the type isn't correct.\n        If passed an incorrect number of coordinates.\n    \"\"\"\n\n    type: str\n    coordinates: list[float | int]\n\n    @field_validator(\"type\")\n    @classmethod\n    def _check_type(cls, v):\n        \"\"\"Validate the GeoJSON type.\"\"\"\n        if v != \"Point\":\n            raise ValueError(\"Incorrect geometry type.\")\n        return v\n\n    @field_validator(\"coordinates\")\n    @classmethod\n    def _check_coordinates(cls, v):\n        \"\"\"Validate the number of coordinates.\"\"\"\n        if len(v) != 2:\n            raise ValueError(\"Incorrect number of points.\")\n        return v\n\n    def point(self) -&gt; Point:\n        \"\"\"\n        Converts the GeoJSON into a Point object.\n\n        Returns\n        ----------\n        Point\n            A geometric point.\n        \"\"\"\n        return Point(\n            x=self.coordinates[0],\n            y=self.coordinates[1],\n        )\n</code></pre>"},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSONPoint-functions","title":"Functions","text":""},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSONPoint.point","title":"<code>velour_api.schemas.geojson.GeoJSONPoint.point()</code>","text":"<p>Converts the GeoJSON into a Point object.</p> <p>Returns:</p> Type Description <code>Point</code> <p>A geometric point.</p> Source code in <code>api/velour_api/schemas/geojson.py</code> <pre><code>def point(self) -&gt; Point:\n    \"\"\"\n    Converts the GeoJSON into a Point object.\n\n    Returns\n    ----------\n    Point\n        A geometric point.\n    \"\"\"\n    return Point(\n        x=self.coordinates[0],\n        y=self.coordinates[1],\n    )\n</code></pre>"},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSONPolygon","title":"<code>velour_api.schemas.geojson.GeoJSONPolygon</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes a polygon in geospatial coordinates.</p> <p>Attributes:</p> Name Type Description <code>types</code> <code>str</code> <p>The type of GeoJSON. Should be \"Polygon\" for this class.</p> <code>coordinates</code> <code>List[List[List[float | int]]]</code> <p>A list of coordinates describing where the <code>Polygon</code> lies.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the type isn't correct.</p> Source code in <code>api/velour_api/schemas/geojson.py</code> <pre><code>class GeoJSONPolygon(BaseModel):\n    \"\"\"\n    Describes a polygon in geospatial coordinates.\n\n    Attributes\n    ----------\n    types : str\n        The type of GeoJSON. Should be \"Polygon\" for this class.\n    coordinates : List[List[List[float | int]]]\n        A list of coordinates describing where the `Polygon` lies.\n\n    Raises\n    ------\n    ValueError\n        If the type isn't correct.\n    \"\"\"\n\n    type: str\n    coordinates: list[list[list[float | int]]]\n\n    @field_validator(\"type\")\n    @classmethod\n    def _check_type(cls, v):\n        \"\"\"Validate the GeoJSON type.\"\"\"\n        if v != \"Polygon\":\n            raise ValueError(\"Incorrect geometry type.\")\n        return v\n\n    def polygon(self) -&gt; Polygon:\n        \"\"\"\n        Converts the GeoJSON into a Polygon object.\n\n        Returns\n        ----------\n        Polygon\n            A geometric polygon.\n\n        Raises\n        ----------\n        ValueError\n            If the coordinates are empty.\n        \"\"\"\n        polygons = [\n            BasicPolygon(\n                points=[Point(x=coord[0], y=coord[1]) for coord in poly]\n            )\n            for poly in self.coordinates\n        ]\n        if not polygons:\n            raise ValueError(\"Incorrect geometry type.\")\n        return Polygon(\n            boundary=polygons[0],\n            holes=polygons[1:] if len(polygons) &gt; 1 else None,\n        )\n</code></pre>"},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSONPolygon-functions","title":"Functions","text":""},{"location":"references/API/Schemas/GeoJSON/#velour_api.schemas.geojson.GeoJSONPolygon.polygon","title":"<code>velour_api.schemas.geojson.GeoJSONPolygon.polygon()</code>","text":"<p>Converts the GeoJSON into a Polygon object.</p> <p>Returns:</p> Type Description <code>Polygon</code> <p>A geometric polygon.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the coordinates are empty.</p> Source code in <code>api/velour_api/schemas/geojson.py</code> <pre><code>def polygon(self) -&gt; Polygon:\n    \"\"\"\n    Converts the GeoJSON into a Polygon object.\n\n    Returns\n    ----------\n    Polygon\n        A geometric polygon.\n\n    Raises\n    ----------\n    ValueError\n        If the coordinates are empty.\n    \"\"\"\n    polygons = [\n        BasicPolygon(\n            points=[Point(x=coord[0], y=coord[1]) for coord in poly]\n        )\n        for poly in self.coordinates\n    ]\n    if not polygons:\n        raise ValueError(\"Incorrect geometry type.\")\n    return Polygon(\n        boundary=polygons[0],\n        holes=polygons[1:] if len(polygons) &gt; 1 else None,\n    )\n</code></pre>"},{"location":"references/API/Schemas/Geometry/","title":"Geometry","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry-classes","title":"Classes","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon","title":"<code>velour_api.schemas.geometry.BasicPolygon</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes a polygon in geometric space.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>Tuple[Point, Point]</code> <p>The coordinates of the polygon.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If less than three points are passed.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>class BasicPolygon(BaseModel):\n    \"\"\"\n    Describes a polygon in geometric space.\n\n    Attributes\n    ----------\n    points: Tuple[Point, Point]\n        The coordinates of the polygon.\n\n    Raises\n    ------\n    ValueError\n        If less than three points are passed.\n    \"\"\"\n\n    points: list[Point]\n\n    @field_validator(\"points\")\n    @classmethod\n    def _check_points(cls, v):\n        if v is not None:\n            if len(set(v)) &lt; 3:\n                raise ValueError(\n                    \"Polygon must be composed of at least three unique points.\"\n                )\n            # Remove duplicate of start point\n            if v[0] == v[-1]:\n                v = v[:-1]\n            # @TODO (maybe) implement self-intersection check?\n        return v\n\n    @property\n    def left(self):\n        \"\"\"\n        Returns the left-most point of the polygon.\n\n        Returns\n        ----------\n        float | int\n            A coordinate.\n        \"\"\"\n        return min(self.points, key=lambda point: point.x).x\n\n    @property\n    def right(self):\n        \"\"\"\n        Returns the right-most point of the polygon.\n\n        Returns\n        ----------\n        float | int\n            A coordinate.\n        \"\"\"\n        return max(self.points, key=lambda point: point.x).x\n\n    @property\n    def top(self):\n        \"\"\"\n        Returns the top-most point of the polygon.\n\n        Returns\n        ----------\n        float | int\n            A coordinate.\n        \"\"\"\n        return max(self.points, key=lambda point: point.y).y\n\n    @property\n    def bottom(self):\n        \"\"\"\n        Returns the bottom-most point of the polygon.\n\n        Returns\n        ----------\n        float | int\n            A coordinate.\n        \"\"\"\n        return min(self.points, key=lambda point: point.y).y\n\n    @property\n    def width(self):\n        \"\"\"\n        Returns the width of the polygon.\n\n        Returns\n        ----------\n        float | int\n            The width of the polygon.\n        \"\"\"\n        return self.right - self.left\n\n    @property\n    def height(self):\n        \"\"\"\n        Returns the height of the polygon.\n\n        Returns\n        ----------\n        float | int\n            The height of the polygon.\n        \"\"\"\n        return self.top - self.bottom\n\n    @property\n    def segments(self) -&gt; list[LineSegment]:\n        \"\"\"\n        Returns a list of line segments for the polygon.\n\n        Returns\n        ----------\n        List[LineSegment]\n            A list of segments.\n        \"\"\"\n        plist = self.points + [self.points[0]]\n        return [\n            LineSegment(points=(plist[i], plist[i + 1]))\n            for i in range(len(plist) - 1)\n        ]\n\n    def __str__(self):\n        \"\"\"Converts the object to a string. In PostGIS, a polygon has to begin and end at the same point\"\"\"\n\n        pts = self.points\n        if pts[0] != pts[-1]:\n            pts = pts + [pts[0]]\n        points_string = [f\"({','.join([str(pt.x), str(pt.y)])})\" for pt in pts]\n        return f\"({','.join(points_string)})\"\n\n    def wkt(self, partial: bool = False) -&gt; str:\n        \"\"\"\n        Returns the well-known text (WKT) representation of the object.\n\n        Parameters\n        ----------\n        partial : bool\n            Whether to return the full WKT string or not.\n\n        Returns\n        ----------\n        str\n            The WKT representation of the shape.\n        \"\"\"\n        # in PostGIS polygon has to begin and end at the same point\n        pts = self.points\n        if pts[0] != pts[-1]:\n            pts = pts + [pts[0]]\n        points_string = [\" \".join([str(pt.x), str(pt.y)]) for pt in pts]\n        wkt_format = f\"({', '.join(points_string)})\"\n        if partial:\n            return wkt_format\n        return f\"POLYGON ({wkt_format})\"\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon-attributes","title":"Attributes","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon.bottom","title":"<code>velour_api.schemas.geometry.BasicPolygon.bottom</code>  <code>property</code>","text":"<p>Returns the bottom-most point of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>A coordinate.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon.height","title":"<code>velour_api.schemas.geometry.BasicPolygon.height</code>  <code>property</code>","text":"<p>Returns the height of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>The height of the polygon.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon.left","title":"<code>velour_api.schemas.geometry.BasicPolygon.left</code>  <code>property</code>","text":"<p>Returns the left-most point of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>A coordinate.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon.right","title":"<code>velour_api.schemas.geometry.BasicPolygon.right</code>  <code>property</code>","text":"<p>Returns the right-most point of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>A coordinate.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon.segments","title":"<code>velour_api.schemas.geometry.BasicPolygon.segments: list[LineSegment]</code>  <code>property</code>","text":"<p>Returns a list of line segments for the polygon.</p> <p>Returns:</p> Type Description <code>List[LineSegment]</code> <p>A list of segments.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon.top","title":"<code>velour_api.schemas.geometry.BasicPolygon.top</code>  <code>property</code>","text":"<p>Returns the top-most point of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>A coordinate.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon.width","title":"<code>velour_api.schemas.geometry.BasicPolygon.width</code>  <code>property</code>","text":"<p>Returns the width of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>The width of the polygon.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon.__str__","title":"<code>velour_api.schemas.geometry.BasicPolygon.__str__()</code>","text":"<p>Converts the object to a string. In PostGIS, a polygon has to begin and end at the same point</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def __str__(self):\n    \"\"\"Converts the object to a string. In PostGIS, a polygon has to begin and end at the same point\"\"\"\n\n    pts = self.points\n    if pts[0] != pts[-1]:\n        pts = pts + [pts[0]]\n    points_string = [f\"({','.join([str(pt.x), str(pt.y)])})\" for pt in pts]\n    return f\"({','.join(points_string)})\"\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BasicPolygon.wkt","title":"<code>velour_api.schemas.geometry.BasicPolygon.wkt(partial=False)</code>","text":"<p>Returns the well-known text (WKT) representation of the object.</p> <p>Parameters:</p> Name Type Description Default <code>partial</code> <code>bool</code> <p>Whether to return the full WKT string or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The WKT representation of the shape.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def wkt(self, partial: bool = False) -&gt; str:\n    \"\"\"\n    Returns the well-known text (WKT) representation of the object.\n\n    Parameters\n    ----------\n    partial : bool\n        Whether to return the full WKT string or not.\n\n    Returns\n    ----------\n    str\n        The WKT representation of the shape.\n    \"\"\"\n    # in PostGIS polygon has to begin and end at the same point\n    pts = self.points\n    if pts[0] != pts[-1]:\n        pts = pts + [pts[0]]\n    points_string = [\" \".join([str(pt.x), str(pt.y)]) for pt in pts]\n    wkt_format = f\"({', '.join(points_string)})\"\n    if partial:\n        return wkt_format\n    return f\"POLYGON ({wkt_format})\"\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox","title":"<code>velour_api.schemas.geometry.BoundingBox</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes a bounding box in geometric space.</p> <p>Attributes:</p> Name Type Description <code>polygons</code> <code>BasicPolygon</code> <p>A polygon describing the bounding box.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of points != 4.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>class BoundingBox(BaseModel):\n    \"\"\"\n    Describes a bounding box in geometric space.\n\n    Attributes\n    ----------\n    polygons: BasicPolygon\n        A polygon describing the bounding box.\n\n    Raises\n    ------\n    ValueError\n        If the number of points != 4.\n    \"\"\"\n\n    polygon: BasicPolygon\n\n    @field_validator(\"polygon\")\n    @classmethod\n    def _validate_polygon(cls, v):\n        \"\"\"Validates the number of points in the polygon.\"\"\"\n        if len(set(v.points)) != 4:\n            raise ValueError(\n                \"bounding box polygon requires exactly 4 unique points.\"\n            )\n        return v\n\n    @classmethod\n    def from_extrema(cls, xmin: float, ymin: float, xmax: float, ymax: float):\n        \"\"\"\n        Create a bounding box from extrema.\n\n        Parameters\n        ----------\n        xmin: float\n            The minimum x-coordinate.\n        ymin: float\n            The minimum y-coordinate.\n        xmax: float\n            The maximum x-coordinate.\n        ymax: float\n            The maximum y-coordinate.\n\n\n        Returns\n        ------\n        BoundingBox\n            The bounding box created from the extrema.\n        \"\"\"\n        return cls(\n            polygon=BasicPolygon(\n                points=[\n                    Point(x=xmin, y=ymin),\n                    Point(x=xmax, y=ymin),\n                    Point(x=xmax, y=ymax),\n                    Point(x=xmin, y=ymax),\n                ]\n            )\n        )\n\n    @property\n    def left(self):\n        \"\"\"\n        Returns the left-most point of the polygon.\n\n        Returns\n        ----------\n        float | int\n            A coordinate.\n        \"\"\"\n        return self.polygon.left\n\n    @property\n    def right(self):\n        \"\"\"\n        Returns the right-most point of the polygon.\n\n        Returns\n        ----------\n        float | int\n            A coordinate.\n        \"\"\"\n        return self.polygon.right\n\n    @property\n    def top(self):\n        \"\"\"\n        Returns the top-most point of the polygon.\n\n        Returns\n        ----------\n        float | int\n            A coordinate.\n        \"\"\"\n        return self.polygon.top\n\n    @property\n    def bottom(self):\n        \"\"\"\n        Returns the bottom-most point of the polygon.\n\n        Returns\n        ----------\n        float | int\n            A coordinate.\n        \"\"\"\n        return self.polygon.bottom\n\n    @property\n    def width(self):\n        \"\"\"\n        Returns the width of the polygon.\n\n        Returns\n        ----------\n        float | int\n            The width of the polygon.\n        \"\"\"\n        return self.polygon.width\n\n    @property\n    def height(self):\n        \"\"\"\n        Returns the height of the polygon.\n\n        Returns\n        ----------\n        float | int\n            The height of the polygon.\n        \"\"\"\n        return self.polygon.height\n\n    def is_rectangular(self):\n        \"\"\"\n        Asserts whether the bounding box is rectangular.\n\n        Returns\n        ----------\n        bool\n            Whether the polygon is rectangular or not.\n        \"\"\"\n        # retrieve segments\n        segments = self.polygon.segments\n\n        # check if segments are parallel\n        if not (\n            segments[0].parallel(segments[2])\n            and segments[1].parallel(segments[3])\n        ):\n            return False\n\n        # check if segments are perpendicular\n        for i in range(3):\n            if not segments[i].perpendicular(segments[i + 1]):\n                return False\n\n        return True\n\n    def is_rotated(self):\n        \"\"\"\n        Asserts whether the bounding box is rotated.\n\n        Returns\n        ----------\n        bool\n            Whether the polygon is rotated or not.\n        \"\"\"\n        # check if rectangular\n        if not self.is_rectangular():\n            return False\n\n        # check if rotation exists by seeing if corners do not share values.\n        x = set([p.x for p in self.polygon.points])\n        y = set([p.y for p in self.polygon.points])\n        return (len(x) != 2) and (len(y) != 2)\n\n    def is_skewed(self):\n        \"\"\"\n        Asserts whether the bounding box is skewed.\n\n        Returns\n        ----------\n        bool\n            Whether the polygon is skewed or not.\n        \"\"\"\n        return not (self.is_rotated() or self.is_rectangular())\n\n    def wkt(self) -&gt; str:\n        \"\"\"\n        Returns the well-known text (WKT) representation of the object.\n\n        Returns\n        ----------\n        str\n            The WKT representation of the shape.\n        \"\"\"\n        return self.polygon.wkt()\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox-attributes","title":"Attributes","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox.bottom","title":"<code>velour_api.schemas.geometry.BoundingBox.bottom</code>  <code>property</code>","text":"<p>Returns the bottom-most point of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>A coordinate.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox.height","title":"<code>velour_api.schemas.geometry.BoundingBox.height</code>  <code>property</code>","text":"<p>Returns the height of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>The height of the polygon.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox.left","title":"<code>velour_api.schemas.geometry.BoundingBox.left</code>  <code>property</code>","text":"<p>Returns the left-most point of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>A coordinate.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox.right","title":"<code>velour_api.schemas.geometry.BoundingBox.right</code>  <code>property</code>","text":"<p>Returns the right-most point of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>A coordinate.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox.top","title":"<code>velour_api.schemas.geometry.BoundingBox.top</code>  <code>property</code>","text":"<p>Returns the top-most point of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>A coordinate.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox.width","title":"<code>velour_api.schemas.geometry.BoundingBox.width</code>  <code>property</code>","text":"<p>Returns the width of the polygon.</p> <p>Returns:</p> Type Description <code>float | int</code> <p>The width of the polygon.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox.from_extrema","title":"<code>velour_api.schemas.geometry.BoundingBox.from_extrema(xmin, ymin, xmax, ymax)</code>  <code>classmethod</code>","text":"<p>Create a bounding box from extrema.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>The minimum x-coordinate.</p> required <code>ymin</code> <code>float</code> <p>The minimum y-coordinate.</p> required <code>xmax</code> <code>float</code> <p>The maximum x-coordinate.</p> required <code>ymax</code> <code>float</code> <p>The maximum y-coordinate.</p> required <p>Returns:</p> Type Description <code>BoundingBox</code> <p>The bounding box created from the extrema.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>@classmethod\ndef from_extrema(cls, xmin: float, ymin: float, xmax: float, ymax: float):\n    \"\"\"\n    Create a bounding box from extrema.\n\n    Parameters\n    ----------\n    xmin: float\n        The minimum x-coordinate.\n    ymin: float\n        The minimum y-coordinate.\n    xmax: float\n        The maximum x-coordinate.\n    ymax: float\n        The maximum y-coordinate.\n\n\n    Returns\n    ------\n    BoundingBox\n        The bounding box created from the extrema.\n    \"\"\"\n    return cls(\n        polygon=BasicPolygon(\n            points=[\n                Point(x=xmin, y=ymin),\n                Point(x=xmax, y=ymin),\n                Point(x=xmax, y=ymax),\n                Point(x=xmin, y=ymax),\n            ]\n        )\n    )\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox.is_rectangular","title":"<code>velour_api.schemas.geometry.BoundingBox.is_rectangular()</code>","text":"<p>Asserts whether the bounding box is rectangular.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the polygon is rectangular or not.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def is_rectangular(self):\n    \"\"\"\n    Asserts whether the bounding box is rectangular.\n\n    Returns\n    ----------\n    bool\n        Whether the polygon is rectangular or not.\n    \"\"\"\n    # retrieve segments\n    segments = self.polygon.segments\n\n    # check if segments are parallel\n    if not (\n        segments[0].parallel(segments[2])\n        and segments[1].parallel(segments[3])\n    ):\n        return False\n\n    # check if segments are perpendicular\n    for i in range(3):\n        if not segments[i].perpendicular(segments[i + 1]):\n            return False\n\n    return True\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox.is_rotated","title":"<code>velour_api.schemas.geometry.BoundingBox.is_rotated()</code>","text":"<p>Asserts whether the bounding box is rotated.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the polygon is rotated or not.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def is_rotated(self):\n    \"\"\"\n    Asserts whether the bounding box is rotated.\n\n    Returns\n    ----------\n    bool\n        Whether the polygon is rotated or not.\n    \"\"\"\n    # check if rectangular\n    if not self.is_rectangular():\n        return False\n\n    # check if rotation exists by seeing if corners do not share values.\n    x = set([p.x for p in self.polygon.points])\n    y = set([p.y for p in self.polygon.points])\n    return (len(x) != 2) and (len(y) != 2)\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox.is_skewed","title":"<code>velour_api.schemas.geometry.BoundingBox.is_skewed()</code>","text":"<p>Asserts whether the bounding box is skewed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the polygon is skewed or not.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def is_skewed(self):\n    \"\"\"\n    Asserts whether the bounding box is skewed.\n\n    Returns\n    ----------\n    bool\n        Whether the polygon is skewed or not.\n    \"\"\"\n    return not (self.is_rotated() or self.is_rectangular())\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.BoundingBox.wkt","title":"<code>velour_api.schemas.geometry.BoundingBox.wkt()</code>","text":"<p>Returns the well-known text (WKT) representation of the object.</p> <p>Returns:</p> Type Description <code>str</code> <p>The WKT representation of the shape.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def wkt(self) -&gt; str:\n    \"\"\"\n    Returns the well-known text (WKT) representation of the object.\n\n    Returns\n    ----------\n    str\n        The WKT representation of the shape.\n    \"\"\"\n    return self.polygon.wkt()\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.LineSegment","title":"<code>velour_api.schemas.geometry.LineSegment</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes a line segment in geometric space.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>Tuple[Point, Point]</code> <p>The coordinates of two points creating the line.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>class LineSegment(BaseModel):\n    \"\"\"\n    Describes a line segment in geometric space.\n\n    Attributes\n    ----------\n    points: Tuple[Point, Point]\n        The coordinates of two points creating the line.\n    \"\"\"\n\n    points: tuple[Point, Point]\n\n    def delta_xy(self) -&gt; Point:\n        \"\"\"\n        Return the change in x and y over the start and end points of the line.\n\n        Returns\n        ----------\n        Point\n            A `Point` with the coordinates subtracted.\n        \"\"\"\n        return self.points[0] - self.points[1]\n\n    def parallel(self, other) -&gt; bool:\n        \"\"\"\n        Check whether two lines are parallel.\n\n        Parameters\n        ----------\n        other : LineSegment\n            The other line to compare against.\n\n        Returns\n        ----------\n        bool\n            Whether the lines are parallel.\n\n        Raises\n        ----------\n        TypeError\n            If other isn't of the correct type.\n        \"\"\"\n        if not isinstance(other, LineSegment):\n            raise TypeError\n\n        d1 = self.delta_xy()\n        d2 = other.delta_xy()\n\n        slope1 = d1.y / d1.x if d1.x else math.inf\n        slope2 = d2.y / d2.x if d2.x else math.inf\n        return math.isclose(slope1, slope2)\n\n    def perpendicular(self, other) -&gt; bool:\n        \"\"\"\n        Check whether two lines are perpendicular.\n\n        Parameters\n        ----------\n        other : LineSegment\n            The other line to compare against.\n\n        Returns\n        ----------\n        bool\n            Whether the lines are perpendicular.\n\n        Raises\n        ----------\n        TypeError\n            If other isn't of the correct type.\n        \"\"\"\n        \"\"\"Check whether two lines are perpendicular.\"\"\"\n        if not isinstance(other, LineSegment):\n            raise TypeError\n\n        d1 = self.delta_xy()\n        d2 = other.delta_xy()\n\n        slope1 = d1.y / d1.x if d1.x else math.inf\n        slope2 = d2.y / d2.x if d2.x else math.inf\n\n        if slope1 == 0 and math.fabs(slope2) == math.inf:\n            return True\n        elif math.fabs(slope1) == math.inf and slope2 == 0:\n            return True\n        elif slope2 == 0:\n            return False\n        else:\n            return math.isclose(slope1, -1.0 / slope2)\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.LineSegment-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.LineSegment.delta_xy","title":"<code>velour_api.schemas.geometry.LineSegment.delta_xy()</code>","text":"<p>Return the change in x and y over the start and end points of the line.</p> <p>Returns:</p> Type Description <code>Point</code> <p>A <code>Point</code> with the coordinates subtracted.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def delta_xy(self) -&gt; Point:\n    \"\"\"\n    Return the change in x and y over the start and end points of the line.\n\n    Returns\n    ----------\n    Point\n        A `Point` with the coordinates subtracted.\n    \"\"\"\n    return self.points[0] - self.points[1]\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.LineSegment.parallel","title":"<code>velour_api.schemas.geometry.LineSegment.parallel(other)</code>","text":"<p>Check whether two lines are parallel.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>LineSegment</code> <p>The other line to compare against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the lines are parallel.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If other isn't of the correct type.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def parallel(self, other) -&gt; bool:\n    \"\"\"\n    Check whether two lines are parallel.\n\n    Parameters\n    ----------\n    other : LineSegment\n        The other line to compare against.\n\n    Returns\n    ----------\n    bool\n        Whether the lines are parallel.\n\n    Raises\n    ----------\n    TypeError\n        If other isn't of the correct type.\n    \"\"\"\n    if not isinstance(other, LineSegment):\n        raise TypeError\n\n    d1 = self.delta_xy()\n    d2 = other.delta_xy()\n\n    slope1 = d1.y / d1.x if d1.x else math.inf\n    slope2 = d2.y / d2.x if d2.x else math.inf\n    return math.isclose(slope1, slope2)\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.LineSegment.perpendicular","title":"<code>velour_api.schemas.geometry.LineSegment.perpendicular(other)</code>","text":"<p>Check whether two lines are perpendicular.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>LineSegment</code> <p>The other line to compare against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the lines are perpendicular.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If other isn't of the correct type.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def perpendicular(self, other) -&gt; bool:\n    \"\"\"\n    Check whether two lines are perpendicular.\n\n    Parameters\n    ----------\n    other : LineSegment\n        The other line to compare against.\n\n    Returns\n    ----------\n    bool\n        Whether the lines are perpendicular.\n\n    Raises\n    ----------\n    TypeError\n        If other isn't of the correct type.\n    \"\"\"\n    \"\"\"Check whether two lines are perpendicular.\"\"\"\n    if not isinstance(other, LineSegment):\n        raise TypeError\n\n    d1 = self.delta_xy()\n    d2 = other.delta_xy()\n\n    slope1 = d1.y / d1.x if d1.x else math.inf\n    slope2 = d2.y / d2.x if d2.x else math.inf\n\n    if slope1 == 0 and math.fabs(slope2) == math.inf:\n        return True\n    elif math.fabs(slope1) == math.inf and slope2 == 0:\n        return True\n    elif slope2 == 0:\n        return False\n    else:\n        return math.isclose(slope1, -1.0 / slope2)\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.MultiPolygon","title":"<code>velour_api.schemas.geometry.MultiPolygon</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes a multipolygon in geometric space.</p> <p>Attributes:</p> Name Type Description <code>polygons</code> <code>List[Polygon]</code> <p>A list of polygons that make up the <code>MultiPolygon</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If less than three points are passed.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>class MultiPolygon(BaseModel):\n    \"\"\"\n    Describes a multipolygon in geometric space.\n\n    Attributes\n    ----------\n    polygons: List[Polygon]\n        A list of polygons that make up the `MultiPolygon`.\n\n    Raises\n    ------\n    ValueError\n        If less than three points are passed.\n    \"\"\"\n\n    polygons: list[Polygon]\n\n    def wkt(self) -&gt; str:\n        \"\"\"\n        Returns the well-known text (WKT) representation of the object`.\n\n        Returns\n        ----------\n        str\n            The WKT representation of the shape.\n        \"\"\"\n        plist = [polygon.wkt(partial=True) for polygon in self.polygons]\n        return f\"MULTIPOLYGON ({', '.join(plist)})\"\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.MultiPolygon-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.MultiPolygon.wkt","title":"<code>velour_api.schemas.geometry.MultiPolygon.wkt()</code>","text":"<p>Returns the well-known text (WKT) representation of the object`.</p> <p>Returns:</p> Type Description <code>str</code> <p>The WKT representation of the shape.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def wkt(self) -&gt; str:\n    \"\"\"\n    Returns the well-known text (WKT) representation of the object`.\n\n    Returns\n    ----------\n    str\n        The WKT representation of the shape.\n    \"\"\"\n    plist = [polygon.wkt(partial=True) for polygon in self.polygons]\n    return f\"MULTIPOLYGON ({', '.join(plist)})\"\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point","title":"<code>velour_api.schemas.geometry.Point</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes a point in geometric space.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>The x-coordinate of the point.</p> <code>y</code> <code>float</code> <p>The y-coordinate of the point.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an x or y-coordinate isn't passed.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>class Point(BaseModel):\n    \"\"\"\n    Describes a point in geometric space.\n\n    Attributes\n    ----------\n    x : float\n        The x-coordinate of the point.\n    y : float\n        The y-coordinate of the point.\n\n    Raises\n    ------\n    ValueError\n        If an x or y-coordinate isn't passed.\n    \"\"\"\n\n    x: float\n    y: float\n\n    @field_validator(\"x\")\n    @classmethod\n    def _has_x(cls, v):\n        \"\"\"Validate that the object has a x-coordinate\"\"\"\n\n        if not isinstance(v, float):\n            raise ValueError\n        return v\n\n    @field_validator(\"y\")\n    @classmethod\n    def _has_y(cls, v):\n        \"\"\"Validate that the object has a y-coordinate\"\"\"\n        if not isinstance(v, float):\n            raise ValueError\n        return v\n\n    def __str__(self) -&gt; str:\n        \"\"\"Converts the object into a string.\"\"\"\n        return f\"({self.x}, {self.y})\"\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hashes the object\"\"\"\n        return hash((self.x, self.y))\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        Checks if the `Point` is close to another point using `math.isclose`.\n\n        Parameters\n        ----------\n        other : Point\n            The object to compare against.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n\n        Raises\n        ----------\n        TypeError\n            If comparing an object of a different type.\n        \"\"\"\n        if not isinstance(other, Point):\n            raise TypeError\n        return math.isclose(self.x, other.x) and math.isclose(self.y, other.y)\n\n    def __neq__(self, other) -&gt; bool:\n        \"\"\"\n        Checks if the `Point` is not equal to another `Point`.\n\n        Parameters\n        ----------\n        other : Point\n            The object to compare against.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n\n        Raises\n        ----------\n        TypeError\n            If comparing an object of a different type.\n        \"\"\"\n        if not isinstance(other, Point):\n            raise TypeError\n        return not (self == other)\n\n    def __neg__(self):\n        \"\"\"\n        Return the inverse of the `Point` in coordinate space.\n\n        Returns\n        ----------\n        Point\n            A `Point` with inverse coordinates..\n        \"\"\"\n        return Point(x=-self.x, y=-self.y)\n\n    def __add__(self, other):\n        \"\"\"\n        Add the coordinates of two `Points` and return a new `Point`.\n\n        Parameters\n        ----------\n        other : Point\n            The object to add.\n\n        Returns\n        ----------\n        Point\n            A `Point`.\n\n        Raises\n        ----------\n        TypeError\n            If adding an object of a different type.\n        \"\"\"\n        if not isinstance(other, Point):\n            raise TypeError\n        newx = self.x + other.x\n        newy = self.y + other.y\n        return Point(x=newx, y=newy)\n\n    def __sub__(self, other):\n        \"\"\"\n        Subtract the coordinates of two `Points` and return a new `Point`.\n\n        Parameters\n        ----------\n        other : Point\n            The object to subtract.\n\n        Returns\n        ----------\n        Point\n            A `Point`.\n\n        Raises\n        ----------\n        TypeError\n            If subtracting an object of a different type.\n        \"\"\"\n        if not isinstance(other, Point):\n            raise TypeError\n        newx = self.x - other.x\n        newy = self.y - other.y\n        return Point(x=newx, y=newy)\n\n    def __iadd__(self, other):\n        \"\"\"\n        Add the coordinates of two `Points` and return a new `Point`.\n\n        Parameters\n        ----------\n        other : Point\n            The object to add.\n\n        Returns\n        ----------\n        Point\n            A `Point`.\n\n        Raises\n        ----------\n        TypeError\n            If adding an object of a different type.\n        \"\"\"\n        if not isinstance(other, Point):\n            raise TypeError\n        return self + other\n\n    def __isub__(self, other):\n        \"\"\"\n        Subtract the coordinates of two `Points` and return a new `Point`.\n\n        Parameters\n        ----------\n        other : Point\n            The object to subtract.\n\n        Returns\n        ----------\n        Point\n            A `Point`.\n\n        Raises\n        ----------\n        TypeError\n            If subtracting an object of a different type.\n        \"\"\"\n        if not isinstance(other, Point):\n            raise TypeError\n        return self - other\n\n    def dot(self, other):\n        \"\"\"\n        Multiply the x and y-coordinates of two `Points`.\n\n        Parameters\n        ----------\n        other : Point\n            The object to subtract.\n\n        Returns\n        ----------\n        Point\n            A `Point`.\n\n        Raises\n        ----------\n        TypeError\n            If multiplying an object of a different type.\n        \"\"\"\n        if not isinstance(other, Point):\n            raise TypeError\n        return (self.x * other.x) + (self.y * other.y)\n\n    def wkt(self) -&gt; str:\n        \"\"\"\n        Returns the well-known text (WKT) representation of the object.\n\n        Returns\n        ----------\n        str\n            The WKT representation of the shape.\n        \"\"\"\n        return f\"POINT ({self.x} {self.y})\"\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point.__add__","title":"<code>velour_api.schemas.geometry.Point.__add__(other)</code>","text":"<p>Add the coordinates of two <code>Points</code> and return a new <code>Point</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Point</code> <p>The object to add.</p> required <p>Returns:</p> Type Description <code>Point</code> <p>A <code>Point</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If adding an object of a different type.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def __add__(self, other):\n    \"\"\"\n    Add the coordinates of two `Points` and return a new `Point`.\n\n    Parameters\n    ----------\n    other : Point\n        The object to add.\n\n    Returns\n    ----------\n    Point\n        A `Point`.\n\n    Raises\n    ----------\n    TypeError\n        If adding an object of a different type.\n    \"\"\"\n    if not isinstance(other, Point):\n        raise TypeError\n    newx = self.x + other.x\n    newy = self.y + other.y\n    return Point(x=newx, y=newy)\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point.__eq__","title":"<code>velour_api.schemas.geometry.Point.__eq__(other)</code>","text":"<p>Checks if the <code>Point</code> is close to another point using <code>math.isclose</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Point</code> <p>The object to compare against.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If comparing an object of a different type.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Checks if the `Point` is close to another point using `math.isclose`.\n\n    Parameters\n    ----------\n    other : Point\n        The object to compare against.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n\n    Raises\n    ----------\n    TypeError\n        If comparing an object of a different type.\n    \"\"\"\n    if not isinstance(other, Point):\n        raise TypeError\n    return math.isclose(self.x, other.x) and math.isclose(self.y, other.y)\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point.__hash__","title":"<code>velour_api.schemas.geometry.Point.__hash__()</code>","text":"<p>Hashes the object</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hashes the object\"\"\"\n    return hash((self.x, self.y))\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point.__iadd__","title":"<code>velour_api.schemas.geometry.Point.__iadd__(other)</code>","text":"<p>Add the coordinates of two <code>Points</code> and return a new <code>Point</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Point</code> <p>The object to add.</p> required <p>Returns:</p> Type Description <code>Point</code> <p>A <code>Point</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If adding an object of a different type.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def __iadd__(self, other):\n    \"\"\"\n    Add the coordinates of two `Points` and return a new `Point`.\n\n    Parameters\n    ----------\n    other : Point\n        The object to add.\n\n    Returns\n    ----------\n    Point\n        A `Point`.\n\n    Raises\n    ----------\n    TypeError\n        If adding an object of a different type.\n    \"\"\"\n    if not isinstance(other, Point):\n        raise TypeError\n    return self + other\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point.__isub__","title":"<code>velour_api.schemas.geometry.Point.__isub__(other)</code>","text":"<p>Subtract the coordinates of two <code>Points</code> and return a new <code>Point</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Point</code> <p>The object to subtract.</p> required <p>Returns:</p> Type Description <code>Point</code> <p>A <code>Point</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If subtracting an object of a different type.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def __isub__(self, other):\n    \"\"\"\n    Subtract the coordinates of two `Points` and return a new `Point`.\n\n    Parameters\n    ----------\n    other : Point\n        The object to subtract.\n\n    Returns\n    ----------\n    Point\n        A `Point`.\n\n    Raises\n    ----------\n    TypeError\n        If subtracting an object of a different type.\n    \"\"\"\n    if not isinstance(other, Point):\n        raise TypeError\n    return self - other\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point.__neg__","title":"<code>velour_api.schemas.geometry.Point.__neg__()</code>","text":"<p>Return the inverse of the <code>Point</code> in coordinate space.</p> <p>Returns:</p> Type Description <code>Point</code> <p>A <code>Point</code> with inverse coordinates..</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def __neg__(self):\n    \"\"\"\n    Return the inverse of the `Point` in coordinate space.\n\n    Returns\n    ----------\n    Point\n        A `Point` with inverse coordinates..\n    \"\"\"\n    return Point(x=-self.x, y=-self.y)\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point.__neq__","title":"<code>velour_api.schemas.geometry.Point.__neq__(other)</code>","text":"<p>Checks if the <code>Point</code> is not equal to another <code>Point</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Point</code> <p>The object to compare against.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If comparing an object of a different type.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def __neq__(self, other) -&gt; bool:\n    \"\"\"\n    Checks if the `Point` is not equal to another `Point`.\n\n    Parameters\n    ----------\n    other : Point\n        The object to compare against.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n\n    Raises\n    ----------\n    TypeError\n        If comparing an object of a different type.\n    \"\"\"\n    if not isinstance(other, Point):\n        raise TypeError\n    return not (self == other)\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point.__str__","title":"<code>velour_api.schemas.geometry.Point.__str__()</code>","text":"<p>Converts the object into a string.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Converts the object into a string.\"\"\"\n    return f\"({self.x}, {self.y})\"\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point.__sub__","title":"<code>velour_api.schemas.geometry.Point.__sub__(other)</code>","text":"<p>Subtract the coordinates of two <code>Points</code> and return a new <code>Point</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Point</code> <p>The object to subtract.</p> required <p>Returns:</p> Type Description <code>Point</code> <p>A <code>Point</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If subtracting an object of a different type.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def __sub__(self, other):\n    \"\"\"\n    Subtract the coordinates of two `Points` and return a new `Point`.\n\n    Parameters\n    ----------\n    other : Point\n        The object to subtract.\n\n    Returns\n    ----------\n    Point\n        A `Point`.\n\n    Raises\n    ----------\n    TypeError\n        If subtracting an object of a different type.\n    \"\"\"\n    if not isinstance(other, Point):\n        raise TypeError\n    newx = self.x - other.x\n    newy = self.y - other.y\n    return Point(x=newx, y=newy)\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point.dot","title":"<code>velour_api.schemas.geometry.Point.dot(other)</code>","text":"<p>Multiply the x and y-coordinates of two <code>Points</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Point</code> <p>The object to subtract.</p> required <p>Returns:</p> Type Description <code>Point</code> <p>A <code>Point</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If multiplying an object of a different type.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def dot(self, other):\n    \"\"\"\n    Multiply the x and y-coordinates of two `Points`.\n\n    Parameters\n    ----------\n    other : Point\n        The object to subtract.\n\n    Returns\n    ----------\n    Point\n        A `Point`.\n\n    Raises\n    ----------\n    TypeError\n        If multiplying an object of a different type.\n    \"\"\"\n    if not isinstance(other, Point):\n        raise TypeError\n    return (self.x * other.x) + (self.y * other.y)\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Point.wkt","title":"<code>velour_api.schemas.geometry.Point.wkt()</code>","text":"<p>Returns the well-known text (WKT) representation of the object.</p> <p>Returns:</p> Type Description <code>str</code> <p>The WKT representation of the shape.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def wkt(self) -&gt; str:\n    \"\"\"\n    Returns the well-known text (WKT) representation of the object.\n\n    Returns\n    ----------\n    str\n        The WKT representation of the shape.\n    \"\"\"\n    return f\"POINT ({self.x} {self.y})\"\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Polygon","title":"<code>velour_api.schemas.geometry.Polygon</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes a polygon in geometric space.</p> <p>Attributes:</p> Name Type Description <code>boundary</code> <code>BasicPolygon</code> <p>The polygon itself.</p> <code>holes</code> <code>List[BasicPolygon]</code> <p>Any holes that exist within the polygon.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>class Polygon(BaseModel):\n    \"\"\"\n    Describes a polygon in geometric space.\n\n    Attributes\n    ----------\n    boundary : BasicPolygon\n        The polygon itself.\n    holes : List[BasicPolygon]\n        Any holes that exist within the polygon.\n    \"\"\"\n\n    boundary: BasicPolygon\n    holes: list[BasicPolygon] | None = Field(default=None)\n\n    def __str__(self):\n        \"\"\"Converts the object to a string.\"\"\"\n        polys = [str(self.boundary)]\n        if self.holes:\n            for hole in self.holes:\n                polys.append(str(hole))\n        return f\"({','.join(polys)})\"\n\n    def wkt(self, partial: bool = False) -&gt; str:\n        \"\"\"\n        Returns the well-known text (WKT) representation of the object.\n\n        Parameters\n        ----------\n        partial : bool\n            Whether to return the full WKT string or not.\n\n        Returns\n        ----------\n        str\n            The WKT representation of the shape.\n        \"\"\"\n        polys = [self.boundary.wkt(partial=True)]\n        if self.holes:\n            for hole in self.holes:\n                polys.append(hole.wkt(partial=True))\n        wkt_format = f\"({', '.join(polys)})\"\n        if partial:\n            return wkt_format\n        return f\"POLYGON {wkt_format}\"\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Polygon-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Polygon.__str__","title":"<code>velour_api.schemas.geometry.Polygon.__str__()</code>","text":"<p>Converts the object to a string.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def __str__(self):\n    \"\"\"Converts the object to a string.\"\"\"\n    polys = [str(self.boundary)]\n    if self.holes:\n        for hole in self.holes:\n            polys.append(str(hole))\n    return f\"({','.join(polys)})\"\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Polygon.wkt","title":"<code>velour_api.schemas.geometry.Polygon.wkt(partial=False)</code>","text":"<p>Returns the well-known text (WKT) representation of the object.</p> <p>Parameters:</p> Name Type Description Default <code>partial</code> <code>bool</code> <p>Whether to return the full WKT string or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The WKT representation of the shape.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def wkt(self, partial: bool = False) -&gt; str:\n    \"\"\"\n    Returns the well-known text (WKT) representation of the object.\n\n    Parameters\n    ----------\n    partial : bool\n        Whether to return the full WKT string or not.\n\n    Returns\n    ----------\n    str\n        The WKT representation of the shape.\n    \"\"\"\n    polys = [self.boundary.wkt(partial=True)]\n    if self.holes:\n        for hole in self.holes:\n            polys.append(hole.wkt(partial=True))\n    wkt_format = f\"({', '.join(polys)})\"\n    if partial:\n        return wkt_format\n    return f\"POLYGON {wkt_format}\"\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Raster","title":"<code>velour_api.schemas.geometry.Raster</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes a raster in geometric space.</p> <p>Attributes:</p> Name Type Description <code>mask</code> <code>str</code> <p>The mask describing the raster.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the image format is not PNG. If the image mode is not binary.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>class Raster(BaseModel):\n    \"\"\"\n    Describes a raster in geometric space.\n\n    Attributes\n    ----------\n    mask : str\n        The mask describing the raster.\n\n    Raises\n    ------\n    ValueError\n        If the image format is not PNG.\n        If the image mode is not binary.\n    \"\"\"\n\n    mask: str = Field(frozen=True)\n\n    @field_validator(\"mask\")\n    @classmethod\n    def _check_png_and_mode(cls, v):\n        \"\"\"Check that the bytes are for a png file and is binary\"\"\"\n        f = io.BytesIO(b64decode(v))\n        img = PIL.Image.open(f)\n        f.close()\n        if img.format != \"PNG\":\n            raise ValueError(\n                f\"Expected image format PNG but got {img.format}.\"\n            )\n        if img.mode != \"1\":\n            raise ValueError(\n                f\"Expected image mode to be binary but got mode {img.mode}.\"\n            )\n        return v\n\n    @property\n    def mask_bytes(self) -&gt; bytes:\n        \"\"\"\n        Serialize the mask into bytes.\n\n        Returns\n        ----------\n        bytes\n            A byte object.\n\n        \"\"\"\n        if not hasattr(self, \"_mask_bytes\"):\n            self._mask_bytes = b64decode(self.mask)\n        return self._mask_bytes\n\n    @property\n    def array(self) -&gt; np.ndarray:\n        \"\"\"\n        Convert the mask into an array.\n\n        Returns\n        ----------\n        np.ndarray\n            An array representing a mask.\n\n        \"\"\"\n        return self.to_numpy()\n\n    @classmethod\n    def from_numpy(cls, mask: np.ndarray):\n        \"\"\"\n        Create a mask from a numpy array.\n\n        Parameters\n        ----------\n        mask : np:ndarray\n            A numpy array.\n\n        Returns\n        ----------\n        Raster\n            The raster object.\n\n        Raises\n        ----------\n        ValueError\n            If the array has more than two dimensions.\n            If the array contains non-boolean elements.\n        \"\"\"\n        if len(mask.shape) != 2:\n            raise ValueError(\"raster currently only supports 2d arrays\")\n        if mask.dtype != bool:\n            raise ValueError(\n                f\"Expecting a binary mask (i.e. of dtype bool) but got dtype {mask.dtype}\"\n            )\n        f = io.BytesIO()\n        PIL.Image.fromarray(mask).save(f, format=\"PNG\")\n        f.seek(0)\n        mask_bytes = f.read()\n        f.close()\n        return cls(\n            mask=b64encode(mask_bytes).decode(),\n        )\n\n    def to_numpy(self) -&gt; np.ndarray:\n        \"\"\"\n        Convert the mask into an array.\n\n        Returns\n        ----------\n        np.ndarray\n            An array representing a mask.\n        \"\"\"\n        mask_bytes = b64decode(self.mask)\n        with io.BytesIO(mask_bytes) as f:\n            img = PIL.Image.open(f)\n            return np.array(img)\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Raster-attributes","title":"Attributes","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Raster.array","title":"<code>velour_api.schemas.geometry.Raster.array: np.ndarray</code>  <code>property</code>","text":"<p>Convert the mask into an array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array representing a mask.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Raster.mask_bytes","title":"<code>velour_api.schemas.geometry.Raster.mask_bytes: bytes</code>  <code>property</code>","text":"<p>Serialize the mask into bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>A byte object.</p>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Raster-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Raster.from_numpy","title":"<code>velour_api.schemas.geometry.Raster.from_numpy(mask)</code>  <code>classmethod</code>","text":"<p>Create a mask from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>np:ndarray</code> <p>A numpy array.</p> required <p>Returns:</p> Type Description <code>Raster</code> <p>The raster object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the array has more than two dimensions. If the array contains non-boolean elements.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>@classmethod\ndef from_numpy(cls, mask: np.ndarray):\n    \"\"\"\n    Create a mask from a numpy array.\n\n    Parameters\n    ----------\n    mask : np:ndarray\n        A numpy array.\n\n    Returns\n    ----------\n    Raster\n        The raster object.\n\n    Raises\n    ----------\n    ValueError\n        If the array has more than two dimensions.\n        If the array contains non-boolean elements.\n    \"\"\"\n    if len(mask.shape) != 2:\n        raise ValueError(\"raster currently only supports 2d arrays\")\n    if mask.dtype != bool:\n        raise ValueError(\n            f\"Expecting a binary mask (i.e. of dtype bool) but got dtype {mask.dtype}\"\n        )\n    f = io.BytesIO()\n    PIL.Image.fromarray(mask).save(f, format=\"PNG\")\n    f.seek(0)\n    mask_bytes = f.read()\n    f.close()\n    return cls(\n        mask=b64encode(mask_bytes).decode(),\n    )\n</code></pre>"},{"location":"references/API/Schemas/Geometry/#velour_api.schemas.geometry.Raster.to_numpy","title":"<code>velour_api.schemas.geometry.Raster.to_numpy()</code>","text":"<p>Convert the mask into an array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array representing a mask.</p> Source code in <code>api/velour_api/schemas/geometry.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n    \"\"\"\n    Convert the mask into an array.\n\n    Returns\n    ----------\n    np.ndarray\n        An array representing a mask.\n    \"\"\"\n    mask_bytes = b64decode(self.mask)\n    with io.BytesIO(mask_bytes) as f:\n        img = PIL.Image.open(f)\n        return np.array(img)\n</code></pre>"},{"location":"references/API/Schemas/Label/","title":"Label","text":""},{"location":"references/API/Schemas/Label/#velour_api.schemas.label-classes","title":"Classes","text":""},{"location":"references/API/Schemas/Label/#velour_api.schemas.label.Label","title":"<code>velour_api.schemas.label.Label</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object for labeling datasets, models, and annotations.</p> <p>Attributes:</p> Name Type Description <code>key</code> <code>str</code> <p>A key for the <code>Label</code>.</p> <code>value</code> <code>str</code> <p>A value for the <code>Label</code>.</p> <code>score</code> <code>float</code> <p>The score associated with the <code>Label</code> (where applicable).</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>A unique ID for the <code>Label</code>.</p> Source code in <code>api/velour_api/schemas/label.py</code> <pre><code>class Label(BaseModel):\n    \"\"\"\n    An object for labeling datasets, models, and annotations.\n\n    Attributes\n    ----------\n    key : str\n        A key for the `Label`.\n    value : str\n        A value for the `Label`.\n    score : float\n        The score associated with the `Label` (where applicable).\n\n    Attributes\n    ----------\n    id : int\n        A unique ID for the `Label`.\n    \"\"\"\n\n    key: str\n    value: str\n    score: float | None = None\n\n    def __eq__(self, other):\n        \"\"\"\n        Defines how `Labels` are compared to one another\n\n        Parameters\n        ----------\n        other : Label\n            The object to compare with the `Label`.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n        \"\"\"\n        if (\n            not hasattr(other, \"key\")\n            or not hasattr(other, \"key\")\n            or not hasattr(other, \"score\")\n        ):\n            return False\n\n        # if the scores aren't the same type return False\n        if (other.score is None) != (self.score is None):\n            return False\n\n        scores_equal = (other.score is None and self.score is None) or (\n            math.isclose(self.score, other.score)\n        )\n\n        return (\n            scores_equal\n            and self.key == other.key\n            and self.value == other.value\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Defines how a `Label` is hashed.\n\n        Returns\n        ----------\n        int\n            The hashed 'Label`.\n        \"\"\"\n        return hash(f\"key:{self.key},value:{self.value},score:{self.score}\")\n</code></pre>"},{"location":"references/API/Schemas/Label/#velour_api.schemas.label.Label-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Label/#velour_api.schemas.label.Label.__eq__","title":"<code>velour_api.schemas.label.Label.__eq__(other)</code>","text":"<p>Defines how <code>Labels</code> are compared to one another</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Label</code> <p>The object to compare with the <code>Label</code>.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> Source code in <code>api/velour_api/schemas/label.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Defines how `Labels` are compared to one another\n\n    Parameters\n    ----------\n    other : Label\n        The object to compare with the `Label`.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n    \"\"\"\n    if (\n        not hasattr(other, \"key\")\n        or not hasattr(other, \"key\")\n        or not hasattr(other, \"score\")\n    ):\n        return False\n\n    # if the scores aren't the same type return False\n    if (other.score is None) != (self.score is None):\n        return False\n\n    scores_equal = (other.score is None and self.score is None) or (\n        math.isclose(self.score, other.score)\n    )\n\n    return (\n        scores_equal\n        and self.key == other.key\n        and self.value == other.value\n    )\n</code></pre>"},{"location":"references/API/Schemas/Label/#velour_api.schemas.label.Label.__hash__","title":"<code>velour_api.schemas.label.Label.__hash__()</code>","text":"<p>Defines how a <code>Label</code> is hashed.</p> <p>Returns:</p> Type Description <code>int</code> <p>The hashed 'Label`.</p> Source code in <code>api/velour_api/schemas/label.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Defines how a `Label` is hashed.\n\n    Returns\n    ----------\n    int\n        The hashed 'Label`.\n    \"\"\"\n    return hash(f\"key:{self.key},value:{self.value},score:{self.score}\")\n</code></pre>"},{"location":"references/API/Schemas/Metadata/","title":"Metadata","text":""},{"location":"references/API/Schemas/Metadata/#velour_api.schemas.metadata-classes","title":"Classes","text":""},{"location":"references/API/Schemas/Metadata/#velour_api.schemas.metadata.DateTime","title":"<code>velour_api.schemas.metadata.DateTime</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object describing a date and time.</p> <p>Attributes:</p> Name Type Description <code>timestamp</code> <code>int</code> <p>The timestamp in UNIX format.</p> <code>timestamp_local</code> <code>int</code> <p>The local timestamp in UNIX format.</p> <code>date</code> <code>int</code> <p>The date in UNIX format.</p> <code>time</code> <code>int</code> <p>The time in UNIX format.</p> <code>time_local</code> <code>int</code> <p>The local time in UNIX format.</p> <code>interval</code> <code>int</code> <p>The interval between moments in time.</p> Source code in <code>api/velour_api/schemas/metadata.py</code> <pre><code>class DateTime(BaseModel):\n    \"\"\"\n    An object describing a date and time.\n\n    Attributes\n    ----------\n    timestamp : int\n        The timestamp in UNIX format.\n    timestamp_local : int\n        The local timestamp in UNIX format.\n    date : int\n        The date in UNIX format.\n    time : int\n        The time in UNIX format.\n    time_local : int\n        The local time in UNIX format.\n    interval : int\n        The interval between moments in time.\n    \"\"\"\n\n    timestamp: int\n    timestamp_local: int\n    date: int\n    time: int\n    time_local: int\n    interval: int\n</code></pre>"},{"location":"references/API/Schemas/Metadata/#velour_api.schemas.metadata.Metadatum","title":"<code>velour_api.schemas.metadata.Metadatum</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object describing metadata that can be attached to other objects.</p> <p>Attributes:</p> Name Type Description <code>key</code> <code>str</code> <p>The metadata key.</p> <code>value</code> <code>float | str | DateTime</code> <p>The metadata value.</p> Source code in <code>api/velour_api/schemas/metadata.py</code> <pre><code>class Metadatum(BaseModel):\n    \"\"\"\n    An object describing metadata that can be attached to other objects.\n\n    Attributes\n    ----------\n    key : str\n        The metadata key.\n    value : float | str | DateTime\n        The metadata value.\n    \"\"\"\n\n    key: str\n    value: float | str | DateTime\n</code></pre>"},{"location":"references/API/Schemas/Metrics/","title":"Metrics","text":""},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics-classes","title":"Classes","text":""},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.APMetric","title":"<code>velour_api.schemas.metrics.APMetric</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An AP metric response from the API.</p> <p>Attributes:</p> Name Type Description <code>iou</code> <code>float</code> <p>The intersect-over-union (IOU) value.</p> <code>value</code> <code>float</code> <p>The value of the metric.</p> <code>label</code> <code>Label</code> <p>The <code>Label</code> for the metric.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class APMetric(BaseModel):\n    \"\"\"\n    An AP metric response from the API.\n\n    Attributes\n    ----------\n    iou : float\n        The intersect-over-union (IOU) value.\n    value : float\n        The value of the metric.\n    label : Label\n        The `Label` for the metric.\n    \"\"\"\n\n    iou: float\n    value: float\n    label: Label\n\n    def db_mapping(self, label_id: int, evaluation_id: int) -&gt; dict:\n        \"\"\"\n        Creates a mapping for use when uploading the metric to the database.\n\n        Parameters\n        ----------\n        label_id : int\n            The id of the label.\n        evaluation_id : ind\n            The id of the evaluation.\n\n        Returns\n        ----------\n        A mapping dictionary.\n        \"\"\"\n        return {\n            \"value\": self.value,\n            \"label_id\": label_id,\n            \"type\": \"AP\",\n            \"evaluation_id\": evaluation_id,\n            \"parameters\": {\"iou\": self.iou},\n        }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.APMetric-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.APMetric.db_mapping","title":"<code>velour_api.schemas.metrics.APMetric.db_mapping(label_id, evaluation_id)</code>","text":"<p>Creates a mapping for use when uploading the metric to the database.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>int</code> <p>The id of the label.</p> required <code>evaluation_id</code> <code>ind</code> <p>The id of the evaluation.</p> required <p>Returns:</p> Type Description <code>A mapping dictionary.</code> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>def db_mapping(self, label_id: int, evaluation_id: int) -&gt; dict:\n    \"\"\"\n    Creates a mapping for use when uploading the metric to the database.\n\n    Parameters\n    ----------\n    label_id : int\n        The id of the label.\n    evaluation_id : ind\n        The id of the evaluation.\n\n    Returns\n    ----------\n    A mapping dictionary.\n    \"\"\"\n    return {\n        \"value\": self.value,\n        \"label_id\": label_id,\n        \"type\": \"AP\",\n        \"evaluation_id\": evaluation_id,\n        \"parameters\": {\"iou\": self.iou},\n    }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.APMetricAveragedOverIOUs","title":"<code>velour_api.schemas.metrics.APMetricAveragedOverIOUs</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An averaged AP metric response from the API.</p> <p>Attributes:</p> Name Type Description <code>ious</code> <code>set[float]</code> <p>A set of intersect-over-union (IOU) values.</p> <code>value</code> <code>float</code> <p>The value of the metric.</p> <code>label</code> <code>Label</code> <p>The <code>Label</code> for the metric.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class APMetricAveragedOverIOUs(BaseModel):\n    \"\"\"\n    An averaged AP metric response from the API.\n\n    Attributes\n    ----------\n    ious : set[float]\n        A set of intersect-over-union (IOU) values.\n    value : float\n        The value of the metric.\n    label : Label\n        The `Label` for the metric.\n    \"\"\"\n\n    ious: set[float]\n    value: float\n    label: Label\n\n    def db_mapping(self, label_id: int, evaluation_id: int) -&gt; dict:\n        \"\"\"\n        Creates a mapping for use when uploading the metric to the database.\n\n        Parameters\n        ----------\n        label_id : int\n            The id of the label.\n        evaluation_id : ind\n            The id of the evaluation.\n\n        Returns\n        ----------\n        A mapping dictionary.\n        \"\"\"\n        return {\n            \"value\": self.value,\n            \"label_id\": label_id,\n            \"type\": \"APAveragedOverIOUs\",\n            \"evaluation_id\": evaluation_id,\n            \"parameters\": {\"ious\": list(self.ious)},\n        }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.APMetricAveragedOverIOUs-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.APMetricAveragedOverIOUs.db_mapping","title":"<code>velour_api.schemas.metrics.APMetricAveragedOverIOUs.db_mapping(label_id, evaluation_id)</code>","text":"<p>Creates a mapping for use when uploading the metric to the database.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>int</code> <p>The id of the label.</p> required <code>evaluation_id</code> <code>ind</code> <p>The id of the evaluation.</p> required <p>Returns:</p> Type Description <code>A mapping dictionary.</code> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>def db_mapping(self, label_id: int, evaluation_id: int) -&gt; dict:\n    \"\"\"\n    Creates a mapping for use when uploading the metric to the database.\n\n    Parameters\n    ----------\n    label_id : int\n        The id of the label.\n    evaluation_id : ind\n        The id of the evaluation.\n\n    Returns\n    ----------\n    A mapping dictionary.\n    \"\"\"\n    return {\n        \"value\": self.value,\n        \"label_id\": label_id,\n        \"type\": \"APAveragedOverIOUs\",\n        \"evaluation_id\": evaluation_id,\n        \"parameters\": {\"ious\": list(self.ious)},\n    }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.AccuracyMetric","title":"<code>velour_api.schemas.metrics.AccuracyMetric</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes an accuracy metric.</p> <p>Attributes:</p> Name Type Description <code>label_key</code> <code>str</code> <p>A label for the metric.</p> <code>value</code> <code>float</code> <p>The metric value.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class AccuracyMetric(BaseModel):\n    \"\"\"\n    Describes an accuracy metric.\n\n    Attributes\n    ----------\n    label_key : str\n        A label for the metric.\n    value : float\n        The metric value.\n    \"\"\"\n\n    label_key: str\n    value: float\n\n    def db_mapping(self, evaluation_id: int) -&gt; dict:\n        \"\"\"\n        Creates a mapping for use when uploading the metric to the database.\n\n        Parameters\n        ----------\n        evaluation_id : int\n            The evaluation id.\n\n        Returns\n        ----------\n        A mapping dictionary.\n        \"\"\"\n        return {\n            \"value\": self.value,\n            \"type\": \"Accuracy\",\n            \"evaluation_id\": evaluation_id,\n            \"parameters\": {\"label_key\": self.label_key},\n        }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.AccuracyMetric-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.AccuracyMetric.db_mapping","title":"<code>velour_api.schemas.metrics.AccuracyMetric.db_mapping(evaluation_id)</code>","text":"<p>Creates a mapping for use when uploading the metric to the database.</p> <p>Parameters:</p> Name Type Description Default <code>evaluation_id</code> <code>int</code> <p>The evaluation id.</p> required <p>Returns:</p> Type Description <code>A mapping dictionary.</code> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>def db_mapping(self, evaluation_id: int) -&gt; dict:\n    \"\"\"\n    Creates a mapping for use when uploading the metric to the database.\n\n    Parameters\n    ----------\n    evaluation_id : int\n        The evaluation id.\n\n    Returns\n    ----------\n    A mapping dictionary.\n    \"\"\"\n    return {\n        \"value\": self.value,\n        \"type\": \"Accuracy\",\n        \"evaluation_id\": evaluation_id,\n        \"parameters\": {\"label_key\": self.label_key},\n    }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.ConfusionMatrix","title":"<code>velour_api.schemas.metrics.ConfusionMatrix</code>","text":"<p>             Bases: <code>_BaseConfusionMatrix</code></p> <p>Describes a cconfusion matrix.</p> <p>Attributes:</p> Name Type Description <code>label_ley</code> <code>str</code> <p>A label for the matrix.</p> <code>entries</code> <code>List[ConfusionMatrixEntry]</code> <p>A list of entries for the matrix.</p> <p>Attributes:</p> Name Type Description <code>matrix</code> <code>zeroes</code> <p>A sparse matrix representing the confusion matrix.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class ConfusionMatrix(_BaseConfusionMatrix):\n    \"\"\"\n    Describes a cconfusion matrix.\n\n    Attributes\n    ----------\n    label_ley : str\n        A label for the matrix.\n    entries : List[ConfusionMatrixEntry]\n        A list of entries for the matrix.\n\n    Attributes\n    ----------\n    matrix : np.zeroes\n        A sparse matrix representing the confusion matrix.\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        label_values = set(\n            [entry.prediction for entry in self.entries]\n            + [entry.groundtruth for entry in self.entries]\n        )\n        self.label_map = {\n            label_value: i\n            for i, label_value in enumerate(sorted(label_values))\n        }\n        n_label_values = len(self.label_map)\n\n        matrix = np.zeros((n_label_values, n_label_values), dtype=int)\n        for entry in self.entries:\n            matrix[\n                self.label_map[entry.groundtruth],\n                self.label_map[entry.prediction],\n            ] = entry.count\n\n        self.matrix = matrix\n\n    def db_mapping(self, evaluation_id: int) -&gt; dict:\n        \"\"\"\n        Creates a mapping for use when uploading the confusion matrix to the database.\n\n        Parameters\n        ----------\n        evaluation_id : int\n            The evaluation id.\n\n        Returns\n        ----------\n        A mapping dictionary.\n        \"\"\"\n        return {\n            \"label_key\": self.label_key,\n            \"value\": [entry.model_dump() for entry in self.entries],\n            \"evaluation_id\": evaluation_id,\n        }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.ConfusionMatrix-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.ConfusionMatrix.db_mapping","title":"<code>velour_api.schemas.metrics.ConfusionMatrix.db_mapping(evaluation_id)</code>","text":"<p>Creates a mapping for use when uploading the confusion matrix to the database.</p> <p>Parameters:</p> Name Type Description Default <code>evaluation_id</code> <code>int</code> <p>The evaluation id.</p> required <p>Returns:</p> Type Description <code>A mapping dictionary.</code> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>def db_mapping(self, evaluation_id: int) -&gt; dict:\n    \"\"\"\n    Creates a mapping for use when uploading the confusion matrix to the database.\n\n    Parameters\n    ----------\n    evaluation_id : int\n        The evaluation id.\n\n    Returns\n    ----------\n    A mapping dictionary.\n    \"\"\"\n    return {\n        \"label_key\": self.label_key,\n        \"value\": [entry.model_dump() for entry in self.entries],\n        \"evaluation_id\": evaluation_id,\n    }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.ConfusionMatrixEntry","title":"<code>velour_api.schemas.metrics.ConfusionMatrixEntry</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes one element in a confusion matrix.</p> <p>Attributes:</p> Name Type Description <code>prediction</code> <code>str</code> <p>The prediction.</p> <code>groundtruth</code> <code>str</code> <p>The groundtruth.</p> <code>count</code> <code>int</code> <p>The value of the element in the matrix.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class ConfusionMatrixEntry(BaseModel):\n    \"\"\"\n    Describes one element in a confusion matrix.\n\n    Attributes\n    ----------\n    prediction : str\n        The prediction.\n    groundtruth : str\n        The groundtruth.\n    count : int\n        The value of the element in the matrix.\n    \"\"\"\n\n    prediction: str\n    groundtruth: str\n    count: int\n    # TODO[pydantic]: The following keys were removed: `allow_mutation`.\n    # Check https://docs.pydantic.dev/dev-v2/migration/#changes-to-config for more information.\n    model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.ConfusionMatrixResponse","title":"<code>velour_api.schemas.metrics.ConfusionMatrixResponse</code>","text":"<p>             Bases: <code>_BaseConfusionMatrix</code></p> <p>A response object used for HTTP responses since they won't contain matrix or label map attributes.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class ConfusionMatrixResponse(_BaseConfusionMatrix):\n    \"\"\"\n    A response object used for HTTP responses since they won't contain matrix or label map attributes.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.CreateClfMetricsResponse","title":"<code>velour_api.schemas.metrics.CreateClfMetricsResponse</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The response from a job that creates classification metrics.</p> <p>Attributes:</p> Name Type Description <code>missing_pred_labels</code> <code>list[Label]</code> <p>A list of missing prediction labels.</p> <code>ignored_pred_labels</code> <code>list[Label]</code> <p>A list of ignored preiction labels.</p> <code>job_id</code> <code>int</code> <p>The job ID.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class CreateClfMetricsResponse(BaseModel):\n    \"\"\"\n    The response from a job that creates classification metrics.\n\n    Attributes\n    ----------\n    missing_pred_labels: list[Label]\n        A list of missing prediction labels.\n    ignored_pred_labels: list[Label]\n        A list of ignored preiction labels.\n    job_id: int\n        The job ID.\n    \"\"\"\n\n    missing_pred_keys: list[str]\n    ignored_pred_keys: list[str]\n    job_id: int\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.CreateDetectionMetricsResponse","title":"<code>velour_api.schemas.metrics.CreateDetectionMetricsResponse</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The response from a job that creates AP metrics.</p> <p>Attributes:</p> Name Type Description <code>missing_pred_labels</code> <code>list[Label]</code> <p>A list of missing prediction labels.</p> <code>ignored_pred_labels</code> <code>list[Label]</code> <p>A list of ignored preiction labels.</p> <code>job_id</code> <code>int</code> <p>The job ID.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class CreateDetectionMetricsResponse(BaseModel):\n    \"\"\"\n    The response from a job that creates AP metrics.\n\n    Attributes\n    ----------\n    missing_pred_labels: list[Label]\n        A list of missing prediction labels.\n    ignored_pred_labels: list[Label]\n        A list of ignored preiction labels.\n    job_id: int\n        The job ID.\n    \"\"\"\n\n    missing_pred_labels: list[Label]\n    ignored_pred_labels: list[Label]\n    job_id: int\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.CreateSemanticSegmentationMetricsResponse","title":"<code>velour_api.schemas.metrics.CreateSemanticSegmentationMetricsResponse</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The response from a job that creates segmentation metrics.</p> <p>Attributes:</p> Name Type Description <code>missing_pred_labels</code> <code>list[Label]</code> <p>A list of missing prediction labels.</p> <code>ignored_pred_labels</code> <code>list[Label]</code> <p>A list of ignored preiction labels.</p> <code>job_id</code> <code>int</code> <p>The job ID.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class CreateSemanticSegmentationMetricsResponse(BaseModel):\n    \"\"\"\n    The response from a job that creates segmentation metrics.\n\n    Attributes\n    ----------\n    missing_pred_labels: list[Label]\n        A list of missing prediction labels.\n    ignored_pred_labels: list[Label]\n        A list of ignored preiction labels.\n    job_id: int\n        The job ID.\n    \"\"\"\n\n    missing_pred_labels: list[Label]\n    ignored_pred_labels: list[Label]\n    job_id: int\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.DetectionParameters","title":"<code>velour_api.schemas.metrics.DetectionParameters</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Defines important attributes to use when evaluating an object detection model.</p> <p>Attributes:</p> Name Type Description <code>iou_thresholds_to_compute</code> <code>List[float]</code> <p>A list of floats describing which Intersection over Unions (IoUs) to use when calculating metrics (i.e., mAP).</p> <code>iou_thresholds_to_keep</code> <code>List[float]</code> <p>A list of floats describing which Intersection over Union (IoUs) thresholds to calculate a metric for. Must be a subset of <code>iou_thresholds_to_compute</code>.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class DetectionParameters(BaseModel):\n    \"\"\"\n    Defines important attributes to use when evaluating an object detection model.\n\n    Attributes\n    ----------\n    iou_thresholds_to_compute : List[float]\n        A list of floats describing which Intersection over Unions (IoUs) to use when calculating metrics (i.e., mAP).\n    iou_thresholds_to_keep: List[float]\n        A list of floats describing which Intersection over Union (IoUs) thresholds to calculate a metric for. Must be a subset of `iou_thresholds_to_compute`.\n    \"\"\"\n\n    # thresholds to iterate over (mutable defaults are ok for pydantic models)\n    iou_thresholds_to_compute: list[float] | None = [\n        round(0.5 + 0.05 * i, 2) for i in range(10)\n    ]\n    iou_thresholds_to_keep: list[float] | None = [0.5, 0.75]\n\n    # pydantic setting\n    model_config = ConfigDict(extra=\"forbid\")\n\n    @model_validator(mode=\"after\")\n    @classmethod\n    def _check_ious(cls, values):\n        \"\"\"Validate the IOU thresholds.\"\"\"\n        for iou in values.iou_thresholds_to_keep:\n            if iou not in values.iou_thresholds_to_compute:\n                raise ValueError(\n                    \"`iou_thresholds_to_keep` must be contained in `iou_thresholds_to_compute`\"\n                )\n        return values\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.Evaluation","title":"<code>velour_api.schemas.metrics.Evaluation</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object for storing the returned results of a model evaluation (where groundtruths are compared with predictions to measure performance).</p> <p>Attributes:</p> Name Type Description <code>dataset</code> <code>str</code> <p>The name of the dataset.</p> <code>model</code> <code>str</code> <p>The name of the model.</p> <code>settings</code> <code>EvaluationSettings</code> <p>Settings for the evaluation.</p> <code>job_id</code> <code>int</code> <p>The ID of the evaluation job.</p> <code>status</code> <code>str</code> <p>The status of the evaluation.</p> <code>metrics</code> <code>List[Metric]</code> <p>A list of metrics associated with the evaluation.</p> <code>confusion_matrices</code> <code>List[ConfusionMatrixResponse]</code> <p>A list of confusion matrices associated with the evaluation.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class Evaluation(BaseModel):\n    \"\"\"\n    An object for storing the returned results of a model evaluation (where groundtruths are compared with predictions to measure performance).\n\n    Attributes\n    ----------\n    dataset : str\n        The name of the dataset.\n    model : str\n        The name of the model.\n    settings : EvaluationSettings\n        Settings for the evaluation.\n    job_id : int\n        The ID of the evaluation job.\n    status : str\n        The status of the evaluation.\n    metrics : List[Metric]\n        A list of metrics associated with the evaluation.\n    confusion_matrices: List[ConfusionMatrixResponse]\n        A list of confusion matrices associated with the evaluation.\n\n    \"\"\"\n\n    dataset: str\n    model: str\n    settings: EvaluationSettings\n    job_id: int\n    status: str\n    metrics: list[Metric]\n    confusion_matrices: list[ConfusionMatrixResponse]\n\n    # pydantic setting\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.EvaluationJob","title":"<code>velour_api.schemas.metrics.EvaluationJob</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Defines important attributes of an evaluation job.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>The name of the <code>Model</code> invoked during the evaluation.</p> <code>dataset</code> <code>str</code> <p>The name of the <code>Dataset</code> invoked during the evaluation.</p> <code>task_type</code> <code>TaskType</code> <p>The task type of the evaluation.</p> <code>settings</code> <code>EvaluationSettings</code> <p>The <code>EvaluationSettings</code> object used to configurate the <code>EvaluationJob</code>.</p> <code>id</code> <code>int</code> <p>The id of the job.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class EvaluationJob(BaseModel):\n    \"\"\"\n    Defines important attributes of an evaluation job.\n\n    Attributes\n    ----------\n    model : str\n        The name of the `Model` invoked during the evaluation.\n    dataset : str\n        The name of the `Dataset` invoked during the evaluation.\n    task_type : TaskType\n        The task type of the evaluation.\n    settings : EvaluationSettings\n        The `EvaluationSettings` object used to configurate the `EvaluationJob`.\n    id : int\n        The id of the job.\n    \"\"\"\n\n    model: str\n    dataset: str\n    task_type: TaskType\n    settings: EvaluationSettings = Field(default=EvaluationSettings())\n    id: int | None = None\n\n    # pydantic setting\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.EvaluationSettings","title":"<code>velour_api.schemas.metrics.EvaluationSettings</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Defines important attributes of an evaluation's settings.</p> <p>Attributes:</p> Name Type Description <code>parameters</code> <code>DetectionParameters</code> <p>The parameter object (e.g., `DetectionParameters) to use when creating an evaluation.</p> <code>filters</code> <code>Filter</code> <p>The <code>Filter</code>object to use when creating an evaluation.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class EvaluationSettings(BaseModel):\n    \"\"\"\n    Defines important attributes of an evaluation's settings.\n\n    Attributes\n    ----------\n    parameters : DetectionParameters\n        The parameter object (e.g., `DetectionParameters) to use when creating an evaluation.\n    filters: Filter\n        The `Filter`object to use when creating an evaluation.\n    \"\"\"\n\n    parameters: DetectionParameters | None = None\n    filters: Filter | None = None\n\n    # pydantic setting\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.F1Metric","title":"<code>velour_api.schemas.metrics.F1Metric</code>","text":"<p>             Bases: <code>_PrecisionRecallF1Base</code></p> <p>Describes an F1 metric.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class F1Metric(_PrecisionRecallF1Base):\n    \"\"\"Describes an F1 metric.\"\"\"\n\n    __type__ = \"F1\"\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.IOUMetric","title":"<code>velour_api.schemas.metrics.IOUMetric</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes an intersection-over-union (IOU) metric.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>The metric value.</p> <code>label</code> <code>Label</code> <p>A label for the metric.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class IOUMetric(BaseModel):\n    \"\"\"\n    Describes an intersection-over-union (IOU) metric.\n\n    Attributes\n    ----------\n    value : float\n        The metric value.\n    label : Label\n        A label for the metric.\n    \"\"\"\n\n    value: float\n    label: Label\n\n    def db_mapping(self, label_id: int, evaluation_id: int) -&gt; dict:\n        \"\"\"\n        Creates a mapping for use when uploading the metric to the database.\n\n        Parameters\n        ----------\n        evaluation_id : int\n            The evaluation id.\n\n        Returns\n        ----------\n        A mapping dictionary.\n        \"\"\"\n        return {\n            \"value\": self.value,\n            \"label_id\": label_id,\n            \"type\": \"IOU\",\n            \"evaluation_id\": evaluation_id,\n        }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.IOUMetric-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.IOUMetric.db_mapping","title":"<code>velour_api.schemas.metrics.IOUMetric.db_mapping(label_id, evaluation_id)</code>","text":"<p>Creates a mapping for use when uploading the metric to the database.</p> <p>Parameters:</p> Name Type Description Default <code>evaluation_id</code> <code>int</code> <p>The evaluation id.</p> required <p>Returns:</p> Type Description <code>A mapping dictionary.</code> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>def db_mapping(self, label_id: int, evaluation_id: int) -&gt; dict:\n    \"\"\"\n    Creates a mapping for use when uploading the metric to the database.\n\n    Parameters\n    ----------\n    evaluation_id : int\n        The evaluation id.\n\n    Returns\n    ----------\n    A mapping dictionary.\n    \"\"\"\n    return {\n        \"value\": self.value,\n        \"label_id\": label_id,\n        \"type\": \"IOU\",\n        \"evaluation_id\": evaluation_id,\n    }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.Job","title":"<code>velour_api.schemas.metrics.Job</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Defines important attributes for a job.</p> <p>Attributes:</p> Name Type Description <code>uid</code> <code>str</code> <p>The UID of the job.</p> <code>status</code> <code>JobStatus</code> <p>The status of the job.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class Job(BaseModel):\n    \"\"\"\n    Defines important attributes for a job.\n\n    Attributes\n    ----------\n    uid : str\n        The UID of the job.\n    status : JobStatus\n        The status of the job.\n    \"\"\"\n\n    uid: str = Field(default_factory=lambda: str(uuid4()))\n    status: JobStatus = JobStatus.PENDING\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.Metric","title":"<code>velour_api.schemas.metrics.Metric</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A metric response from the API.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>The type of metric.</p> <code>parameters</code> <code>dict</code> <p>The parameters of the metric.</p> <code>value</code> <code>float</code> <p>The value of the metric.</p> <code>label</code> <code>Label</code> <p>The <code>Label</code> for the metric.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class Metric(BaseModel):\n    \"\"\"\n    A metric response from the API.\n\n    Attributes\n    ----------\n    type : str\n        The type of metric.\n    parameters : dict\n        The parameters of the metric.\n    value : float\n        The value of the metric.\n    label : Label\n        The `Label` for the metric.\n    \"\"\"\n\n    type: str\n    parameters: dict | None = None\n    value: float | dict | None = None\n    label: Label | None = None\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.PrecisionMetric","title":"<code>velour_api.schemas.metrics.PrecisionMetric</code>","text":"<p>             Bases: <code>_PrecisionRecallF1Base</code></p> <p>Describes an precision metric.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class PrecisionMetric(_PrecisionRecallF1Base):\n    \"\"\"Describes an precision metric.\"\"\"\n\n    __type__ = \"Precision\"\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.ROCAUCMetric","title":"<code>velour_api.schemas.metrics.ROCAUCMetric</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes an ROC AUC metric.</p> <p>Attributes:</p> Name Type Description <code>label_key</code> <code>str</code> <p>A label for the metric.</p> <code>value</code> <code>float</code> <p>The metric value.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class ROCAUCMetric(BaseModel):\n    \"\"\"\n    Describes an ROC AUC metric.\n\n    Attributes\n    ----------\n    label_key : str\n        A label for the metric.\n    value : float\n        The metric value.\n    \"\"\"\n\n    label_key: str\n    value: float\n\n    def db_mapping(self, evaluation_id: int) -&gt; dict:\n        \"\"\"\n        Creates a mapping for use when uploading the metric to the database.\n\n        Parameters\n        ----------\n        evaluation_id : int\n            The evaluation id.\n\n        Returns\n        ----------\n        A mapping dictionary.\n        \"\"\"\n        return {\n            \"value\": self.value,\n            \"type\": \"ROCAUC\",\n            \"parameters\": {\"label_key\": self.label_key},\n            \"evaluation_id\": evaluation_id,\n        }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.ROCAUCMetric-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.ROCAUCMetric.db_mapping","title":"<code>velour_api.schemas.metrics.ROCAUCMetric.db_mapping(evaluation_id)</code>","text":"<p>Creates a mapping for use when uploading the metric to the database.</p> <p>Parameters:</p> Name Type Description Default <code>evaluation_id</code> <code>int</code> <p>The evaluation id.</p> required <p>Returns:</p> Type Description <code>A mapping dictionary.</code> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>def db_mapping(self, evaluation_id: int) -&gt; dict:\n    \"\"\"\n    Creates a mapping for use when uploading the metric to the database.\n\n    Parameters\n    ----------\n    evaluation_id : int\n        The evaluation id.\n\n    Returns\n    ----------\n    A mapping dictionary.\n    \"\"\"\n    return {\n        \"value\": self.value,\n        \"type\": \"ROCAUC\",\n        \"parameters\": {\"label_key\": self.label_key},\n        \"evaluation_id\": evaluation_id,\n    }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.RecallMetric","title":"<code>velour_api.schemas.metrics.RecallMetric</code>","text":"<p>             Bases: <code>_PrecisionRecallF1Base</code></p> <p>Describes a recall metric.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class RecallMetric(_PrecisionRecallF1Base):\n    \"\"\"Describes a recall metric.\"\"\"\n\n    __type__ = \"Recall\"\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.mAPMetric","title":"<code>velour_api.schemas.metrics.mAPMetric</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A mAP metric response from the API.</p> <p>Attributes:</p> Name Type Description <code>iou</code> <code>float</code> <p>The intersect-over-union (IOU) value.</p> <code>value</code> <code>float</code> <p>The value of the metric.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class mAPMetric(BaseModel):\n    \"\"\"\n    A mAP metric response from the API.\n\n    Attributes\n    ----------\n    iou : float\n        The intersect-over-union (IOU) value.\n    value : float\n        The value of the metric.\n    \"\"\"\n\n    iou: float\n    value: float\n\n    def db_mapping(self, evaluation_id: int) -&gt; dict:\n        \"\"\"\n        Creates a mapping for use when uploading the metric to the database.\n\n        Parameters\n        ----------\n        evaluation_id : ind\n            The id of the evaluation.\n\n        Returns\n        ----------\n        A mapping dictionary.\n        \"\"\"\n        return {\n            \"value\": self.value,\n            \"type\": \"mAP\",\n            \"evaluation_id\": evaluation_id,\n            \"parameters\": {\"iou\": self.iou},\n        }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.mAPMetric-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.mAPMetric.db_mapping","title":"<code>velour_api.schemas.metrics.mAPMetric.db_mapping(evaluation_id)</code>","text":"<p>Creates a mapping for use when uploading the metric to the database.</p> <p>Parameters:</p> Name Type Description Default <code>evaluation_id</code> <code>ind</code> <p>The id of the evaluation.</p> required <p>Returns:</p> Type Description <code>A mapping dictionary.</code> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>def db_mapping(self, evaluation_id: int) -&gt; dict:\n    \"\"\"\n    Creates a mapping for use when uploading the metric to the database.\n\n    Parameters\n    ----------\n    evaluation_id : ind\n        The id of the evaluation.\n\n    Returns\n    ----------\n    A mapping dictionary.\n    \"\"\"\n    return {\n        \"value\": self.value,\n        \"type\": \"mAP\",\n        \"evaluation_id\": evaluation_id,\n        \"parameters\": {\"iou\": self.iou},\n    }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.mAPMetricAveragedOverIOUs","title":"<code>velour_api.schemas.metrics.mAPMetricAveragedOverIOUs</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An averaged mAP metric response from the API.</p> <p>Attributes:</p> Name Type Description <code>ious</code> <code>set[float]</code> <p>A set of intersect-over-union (IOU) values.</p> <code>value</code> <code>float</code> <p>The value of the metric.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class mAPMetricAveragedOverIOUs(BaseModel):\n    \"\"\"\n    An averaged mAP metric response from the API.\n\n    Attributes\n    ----------\n    ious : set[float]\n        A set of intersect-over-union (IOU) values.\n    value : float\n        The value of the metric.\n    \"\"\"\n\n    ious: set[float]\n    value: float\n\n    def db_mapping(self, evaluation_id: int) -&gt; dict:\n        \"\"\"\n        Creates a mapping for use when uploading the metric to the database.\n\n        Parameters\n        ----------\n        evaluation_id : ind\n            The id of the evaluation.\n\n        Returns\n        ----------\n        A mapping dictionary.\n        \"\"\"\n        return {\n            \"value\": self.value,\n            \"type\": \"mAPAveragedOverIOUs\",\n            \"evaluation_id\": evaluation_id,\n            \"parameters\": {\"ious\": list(self.ious)},\n        }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.mAPMetricAveragedOverIOUs-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.mAPMetricAveragedOverIOUs.db_mapping","title":"<code>velour_api.schemas.metrics.mAPMetricAveragedOverIOUs.db_mapping(evaluation_id)</code>","text":"<p>Creates a mapping for use when uploading the metric to the database.</p> <p>Parameters:</p> Name Type Description Default <code>evaluation_id</code> <code>ind</code> <p>The id of the evaluation.</p> required <p>Returns:</p> Type Description <code>A mapping dictionary.</code> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>def db_mapping(self, evaluation_id: int) -&gt; dict:\n    \"\"\"\n    Creates a mapping for use when uploading the metric to the database.\n\n    Parameters\n    ----------\n    evaluation_id : ind\n        The id of the evaluation.\n\n    Returns\n    ----------\n    A mapping dictionary.\n    \"\"\"\n    return {\n        \"value\": self.value,\n        \"type\": \"mAPAveragedOverIOUs\",\n        \"evaluation_id\": evaluation_id,\n        \"parameters\": {\"ious\": list(self.ious)},\n    }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.mIOUMetric","title":"<code>velour_api.schemas.metrics.mIOUMetric</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describes a mean intersection-over-union (IOU) metric.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>The metric value.</p> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>class mIOUMetric(BaseModel):\n    \"\"\"\n    Describes a mean intersection-over-union (IOU) metric.\n\n    Attributes\n    ----------\n    value : float\n        The metric value.\n    \"\"\"\n\n    value: float\n\n    def db_mapping(self, evaluation_id: int) -&gt; dict:\n        \"\"\"\n        Creates a mapping for use when uploading the metric to the database.\n\n        Parameters\n        ----------\n        evaluation_id : int\n            The evaluation id.\n\n        Returns\n        ----------\n        A mapping dictionary.\n        \"\"\"\n        return {\n            \"value\": self.value,\n            \"type\": \"mIOU\",\n            \"evaluation_id\": evaluation_id,\n        }\n</code></pre>"},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.mIOUMetric-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Metrics/#velour_api.schemas.metrics.mIOUMetric.db_mapping","title":"<code>velour_api.schemas.metrics.mIOUMetric.db_mapping(evaluation_id)</code>","text":"<p>Creates a mapping for use when uploading the metric to the database.</p> <p>Parameters:</p> Name Type Description Default <code>evaluation_id</code> <code>int</code> <p>The evaluation id.</p> required <p>Returns:</p> Type Description <code>A mapping dictionary.</code> Source code in <code>api/velour_api/schemas/metrics.py</code> <pre><code>def db_mapping(self, evaluation_id: int) -&gt; dict:\n    \"\"\"\n    Creates a mapping for use when uploading the metric to the database.\n\n    Parameters\n    ----------\n    evaluation_id : int\n        The evaluation id.\n\n    Returns\n    ----------\n    A mapping dictionary.\n    \"\"\"\n    return {\n        \"value\": self.value,\n        \"type\": \"mIOU\",\n        \"evaluation_id\": evaluation_id,\n    }\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/","title":"Stateflow","text":"<p>             Bases: <code>BaseModel</code></p> <p>Stores the state of the broader velour system.</p> <p>Attributes:</p> Name Type Description <code>datasets</code> <code>Dict[str, DatasetState]</code> <p>The datasets available in velour.</p> <code>key_to_values</code> <code>Dict[int, list[str]]</code> <p>A dictionary of stored states.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>class Stateflow(BaseModel):\n    \"\"\"\n    Stores the state of the broader velour system.\n\n    Attributes\n    ----------\n    datasets: Dict[str, DatasetState]\n        The datasets available in velour.\n    key_to_values: Dict[int, list[str]]\n        A dictionary of stored states.\n    \"\"\"\n\n    datasets: dict[str, DatasetState] = Field(default_factory=dict)\n    key_to_values: dict[int, list[str]] = Field(default_factory=dict)\n\n    \"\"\" DATASET \"\"\"\n\n    def set_dataset_status(self, dataset_name: str, status: State):\n        \"\"\"\n        Sets the status of a dataset.\n\n        Parameters\n        ----------\n        dataset_name: str\n            The name of the dataset.\n        status : State\n            The status of the dataset.\n\n        Raises\n        ----------\n        DatasetDoesNotExistError\n            If the dataset doesn't exist.\n        \"\"\"\n        if dataset_name not in self.datasets:\n            if status not in [State.NONE, State.CREATE]:\n                raise DatasetDoesNotExistError(dataset_name)\n            self.datasets[dataset_name] = DatasetState()\n        elif (\n            self.datasets[dataset_name].evaluating and status != State.EVALUATE\n        ):\n            raise StateflowError(\n                f\"cannot transition to {status} as an evaluation is running.\"\n            )\n        elif status not in self.datasets[dataset_name].status.next():\n            raise _state_transition_error(\n                before=self.datasets[dataset_name].status,\n                after=status,\n                dataset_name=dataset_name,\n            )\n        self.datasets[dataset_name].status = status\n\n    def get_dataset_status(self, dataset_name: str) -&gt; State:\n        \"\"\"\n        Gets the status of a dataset.\n\n        Parameters\n        ----------\n        dataset_name: str\n            The name of the dataset.\n\n\n        Returns\n        ----------\n        State\n            The state of the dataset.\n\n        Raises\n        ----------\n        DatasetDoesNotExistError\n            If the dataset doesn't exist.\n        \"\"\"\n        if dataset_name not in self.datasets:\n            raise DatasetDoesNotExistError(dataset_name)\n        return self.datasets[dataset_name].status\n\n    def remove_dataset(self, dataset_name: str):\n        \"\"\"\n        Remove a dataset.\n\n        Parameters\n        ----------\n        dataset_name: str\n            The name of the dataset.\n\n        Raises\n        ----------\n        DatasetDoesNotExistError\n            If the dataset doesn't exist.\n        \"\"\"\n        if dataset_name not in self.datasets:\n            raise DatasetDoesNotExistError(dataset_name)\n\n        models = list(self.datasets[dataset_name].models)\n        for model_name in models:\n            self.remove_inference(dataset_name, model_name)\n        # delete dataset\n        del self.datasets[dataset_name]\n\n    \"\"\" MODEL \"\"\"\n\n    def set_model_status(self, model_name: str, status: State):\n        \"\"\"\n        Sets the status of a model.\n\n        Parameters\n        ----------\n        model_name: str\n            The name of the model.\n        status : State\n            The status of the model.\n        \"\"\"\n        for dataset_name in self.datasets:\n            if model_name in self.datasets[dataset_name].models:\n                self.datasets[dataset_name].set_inference_status(\n                    dataset_name, model_name, status=status\n                )\n\n    def remove_model(self, model_name: str):\n        \"\"\"\n        Remove a model.\n\n        Parameters\n        ----------\n        model_name: str\n            The name of the model.\n        \"\"\"\n        for dataset_name, dataset in self.datasets.items():\n            if model_name in dataset.models:\n                # purge key_to_values\n                for job_id in dataset.models[model_name].jobs:\n                    del self.key_to_values[job_id]\n                # remove inference\n                dataset.remove_inference(dataset_name, model_name)\n\n    \"\"\" INFERENCE \"\"\"\n\n    def get_inference_status(\n        self, dataset_name: str, model_name: str\n    ) -&gt; State:\n        \"\"\"\n        Gets the status of an inference.\n\n        Parameters\n        ----------\n        dataset_name: str\n            The name of the dataset.\n        model_name: str\n            The name of the model.\n\n\n        Returns\n        ----------\n        State\n            The state of the inference.\n\n        Raises\n        ----------\n        DatasetDoesNotExistError\n            If the dataset doesn't exist.\n        \"\"\"\n        if dataset_name not in self.datasets:\n            raise DatasetDoesNotExistError(dataset_name)\n        return self.datasets[dataset_name].get_inference_status(\n            dataset_name, model_name\n        )\n\n    def set_inference_status(\n        self, dataset_name: str, model_name: str, status: State\n    ):\n        \"\"\"\n        Sets the status of an inference.\n\n        Parameters\n        ----------\n        dataset_name: str\n            The name of the dataset.\n        model_name: str\n            The name of the model.\n        status : State\n            The status of the inference.\n\n        Raises\n        ----------\n        DatasetDoesNotExistError\n            If the dataset doesn't exist.\n        \"\"\"\n        if dataset_name not in self.datasets:\n            raise DatasetDoesNotExistError(dataset_name)\n\n        if self.datasets[dataset_name].status == State.CREATE:\n            if status not in [State.NONE, State.CREATE, State.DELETE]:\n                raise DatasetNotFinalizedError(dataset_name)\n            self.datasets[dataset_name].set_inference_status(\n                dataset_name=dataset_name,\n                model_name=model_name,\n                status=status,\n            )\n        elif self.datasets[dataset_name].status in [\n            State.READY,\n            State.EVALUATE,\n        ]:\n            self.datasets[dataset_name].set_inference_status(\n                dataset_name=dataset_name,\n                model_name=model_name,\n                status=status,\n            )\n            self.set_dataset_status(\n                dataset_name=dataset_name,\n                status=State.EVALUATE\n                if self.datasets[dataset_name].evaluating\n                else State.READY,\n            )\n        else:\n            raise StateflowError(\n                f\"dataset `{dataset_name}` does not support model operations in its current state `{self.datasets[dataset_name].status}`\"\n            )\n\n    def remove_inference(self, dataset_name: str, model_name: str):\n        \"\"\"\n        Remove an inference.\n\n        Parameters\n        ----------\n        dataset_name: str\n            The name of the dataset.\n        model_name: str\n            The name of the model.\n\n\n        Raises\n        ----------\n        DatasetDoesNotExistError\n            If the dataset doesn't exist.\n        \"\"\"\n        if dataset_name not in self.datasets:\n            raise DatasetDoesNotExistError(dataset_name)\n        # purge key_to_values\n        for job_id in self.datasets[dataset_name].models[model_name].jobs:\n            del self.key_to_values[job_id]\n        # remove inference\n        self.datasets[dataset_name].remove_inference(dataset_name, model_name)\n\n    \"\"\" JOBS \"\"\"\n\n    def set_job_status(\n        self,\n        dataset_name: str,\n        model_name: str,\n        job_id: int,\n        status: JobStatus,\n    ):\n        \"\"\"\n        Sets the status of a job.\n\n        Parameters\n        ----------\n        dataset_name: str\n            The name of the dataset.\n        model_name: str\n            The name of the model.\n        job_id: int\n            The id of the job.\n        status : State\n            The status of the job.\n\n        Raises\n        ----------\n        DatasetDoesNotExistError\n            If the dataset doesn't exist.\n        ModelDoesNotExistError\n            If the model doesn't exist.\n        \"\"\"\n        if dataset_name not in self.datasets:\n            raise DatasetDoesNotExistError(dataset_name)\n        elif model_name not in self.datasets[dataset_name].models:\n            raise ModelDoesNotExistError(model_name)\n        self.datasets[dataset_name].models[model_name].set_job_status(\n            job_id, status\n        )\n        if job_id not in self.key_to_values:\n            self.key_to_values[job_id] = [dataset_name, model_name]\n\n    def get_job_status(\n        self,\n        job_id: int,\n    ) -&gt; JobStatus | None:\n        \"\"\"\n        Gets the status of an job.\n\n        Parameters\n        ----------\n        job_id: int\n            The id of the job.\n\n        Returns\n        ----------\n        JobStatus\n            The state of the job.\n        \"\"\"\n        if job_id not in self.key_to_values:\n            return None\n        dataset_name, model_name = self.key_to_values[job_id]\n        return (\n            self.datasets[dataset_name]\n            .models[model_name]\n            .get_job_status(job_id)\n        )\n\n    def remove_job(\n        self,\n        dataset_name: str,\n        model_name: str,\n        job_id: int,\n    ):\n        \"\"\"\n        Remove a job.\n\n        Parameters\n        ----------\n        dataset_name: str\n            The name of the dataset.\n        model_name: str\n            The name of the model.\n        job_id: int\n            The id of the job.\n\n        Raises\n        ----------\n        DatasetDoesNotExistError\n            If the dataset doesn't exist.\n        ModelDoesNotExistError\n            If the model doesn't exist.\n        \"\"\"\n        if dataset_name not in self.datasets:\n            raise DatasetDoesNotExistError(dataset_name)\n        elif model_name not in self.datasets[dataset_name].models:\n            raise ModelDoesNotExistError(model_name)\n        self.datasets[dataset_name].models[model_name].remove_job(job_id)\n\n    def get_dataset_jobs(\n        self,\n        dataset_name: str,\n    ) -&gt; dict[str, list[int]]:\n        \"\"\"\n        Gets all jobs associated with a dataset.\n\n        Parameters\n        ----------\n        dataset_name: str\n            The name of the dataset.\n\n        Returns\n        ----------\n        Dict[str, List[int]]\n            A dictionary of jobs.\n\n        Raises\n        ----------\n        DatasetDoesNotExistError\n            If the dataset doesn't exist.\n        \"\"\"\n        if dataset_name not in self.datasets:\n            raise DatasetDoesNotExistError(dataset_name)\n        return {\n            model_name: [\n                job_id\n                for job_id in self.datasets[dataset_name]\n                .models[model_name]\n                .jobs\n            ]\n            for model_name in self.datasets[dataset_name].models\n        }\n\n    def get_model_jobs(\n        self,\n        model_name: str,\n    ) -&gt; dict[str, list[int]]:\n        \"\"\"\n        Gets all jobs associated with a model.\n\n        Parameters\n        ----------\n        model_name: str\n            The name of the model.\n\n        Returns\n        ----------\n        Dict[str, List[int]]\n            A dictionary of jobs.\n        \"\"\"\n        return {\n            dataset_name: [\n                job_id\n                for job_id in self.datasets[dataset_name]\n                .models[model_name]\n                .jobs\n            ]\n            for dataset_name in self.datasets\n            if model_name in self.datasets[dataset_name].models\n        }\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow-attributes","title":"Attributes","text":""},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.key_to_values","title":"<code>velour_api.schemas.Stateflow.key_to_values: dict[int, list[str]] = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>DATASET</p>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow-functions","title":"Functions","text":""},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.get_dataset_jobs","title":"<code>velour_api.schemas.Stateflow.get_dataset_jobs(dataset_name)</code>","text":"<p>Gets all jobs associated with a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <p>Returns:</p> Type Description <code>Dict[str, List[int]]</code> <p>A dictionary of jobs.</p> <p>Raises:</p> Type Description <code>DatasetDoesNotExistError</code> <p>If the dataset doesn't exist.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def get_dataset_jobs(\n    self,\n    dataset_name: str,\n) -&gt; dict[str, list[int]]:\n    \"\"\"\n    Gets all jobs associated with a dataset.\n\n    Parameters\n    ----------\n    dataset_name: str\n        The name of the dataset.\n\n    Returns\n    ----------\n    Dict[str, List[int]]\n        A dictionary of jobs.\n\n    Raises\n    ----------\n    DatasetDoesNotExistError\n        If the dataset doesn't exist.\n    \"\"\"\n    if dataset_name not in self.datasets:\n        raise DatasetDoesNotExistError(dataset_name)\n    return {\n        model_name: [\n            job_id\n            for job_id in self.datasets[dataset_name]\n            .models[model_name]\n            .jobs\n        ]\n        for model_name in self.datasets[dataset_name].models\n    }\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.get_dataset_status","title":"<code>velour_api.schemas.Stateflow.get_dataset_status(dataset_name)</code>","text":"<p>Gets the status of a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <p>Returns:</p> Type Description <code>State</code> <p>The state of the dataset.</p> <p>Raises:</p> Type Description <code>DatasetDoesNotExistError</code> <p>If the dataset doesn't exist.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def get_dataset_status(self, dataset_name: str) -&gt; State:\n    \"\"\"\n    Gets the status of a dataset.\n\n    Parameters\n    ----------\n    dataset_name: str\n        The name of the dataset.\n\n\n    Returns\n    ----------\n    State\n        The state of the dataset.\n\n    Raises\n    ----------\n    DatasetDoesNotExistError\n        If the dataset doesn't exist.\n    \"\"\"\n    if dataset_name not in self.datasets:\n        raise DatasetDoesNotExistError(dataset_name)\n    return self.datasets[dataset_name].status\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.get_inference_status","title":"<code>velour_api.schemas.Stateflow.get_inference_status(dataset_name, model_name)</code>","text":"<p>Gets the status of an inference.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <p>Returns:</p> Type Description <code>State</code> <p>The state of the inference.</p> <p>Raises:</p> Type Description <code>DatasetDoesNotExistError</code> <p>If the dataset doesn't exist.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def get_inference_status(\n    self, dataset_name: str, model_name: str\n) -&gt; State:\n    \"\"\"\n    Gets the status of an inference.\n\n    Parameters\n    ----------\n    dataset_name: str\n        The name of the dataset.\n    model_name: str\n        The name of the model.\n\n\n    Returns\n    ----------\n    State\n        The state of the inference.\n\n    Raises\n    ----------\n    DatasetDoesNotExistError\n        If the dataset doesn't exist.\n    \"\"\"\n    if dataset_name not in self.datasets:\n        raise DatasetDoesNotExistError(dataset_name)\n    return self.datasets[dataset_name].get_inference_status(\n        dataset_name, model_name\n    )\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.get_job_status","title":"<code>velour_api.schemas.Stateflow.get_job_status(job_id)</code>","text":"<p>Gets the status of an job.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>int</code> <p>The id of the job.</p> required <p>Returns:</p> Type Description <code>JobStatus</code> <p>The state of the job.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def get_job_status(\n    self,\n    job_id: int,\n) -&gt; JobStatus | None:\n    \"\"\"\n    Gets the status of an job.\n\n    Parameters\n    ----------\n    job_id: int\n        The id of the job.\n\n    Returns\n    ----------\n    JobStatus\n        The state of the job.\n    \"\"\"\n    if job_id not in self.key_to_values:\n        return None\n    dataset_name, model_name = self.key_to_values[job_id]\n    return (\n        self.datasets[dataset_name]\n        .models[model_name]\n        .get_job_status(job_id)\n    )\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.get_model_jobs","title":"<code>velour_api.schemas.Stateflow.get_model_jobs(model_name)</code>","text":"<p>Gets all jobs associated with a model.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <p>Returns:</p> Type Description <code>Dict[str, List[int]]</code> <p>A dictionary of jobs.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def get_model_jobs(\n    self,\n    model_name: str,\n) -&gt; dict[str, list[int]]:\n    \"\"\"\n    Gets all jobs associated with a model.\n\n    Parameters\n    ----------\n    model_name: str\n        The name of the model.\n\n    Returns\n    ----------\n    Dict[str, List[int]]\n        A dictionary of jobs.\n    \"\"\"\n    return {\n        dataset_name: [\n            job_id\n            for job_id in self.datasets[dataset_name]\n            .models[model_name]\n            .jobs\n        ]\n        for dataset_name in self.datasets\n        if model_name in self.datasets[dataset_name].models\n    }\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.remove_dataset","title":"<code>velour_api.schemas.Stateflow.remove_dataset(dataset_name)</code>","text":"<p>Remove a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <p>Raises:</p> Type Description <code>DatasetDoesNotExistError</code> <p>If the dataset doesn't exist.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def remove_dataset(self, dataset_name: str):\n    \"\"\"\n    Remove a dataset.\n\n    Parameters\n    ----------\n    dataset_name: str\n        The name of the dataset.\n\n    Raises\n    ----------\n    DatasetDoesNotExistError\n        If the dataset doesn't exist.\n    \"\"\"\n    if dataset_name not in self.datasets:\n        raise DatasetDoesNotExistError(dataset_name)\n\n    models = list(self.datasets[dataset_name].models)\n    for model_name in models:\n        self.remove_inference(dataset_name, model_name)\n    # delete dataset\n    del self.datasets[dataset_name]\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.remove_inference","title":"<code>velour_api.schemas.Stateflow.remove_inference(dataset_name, model_name)</code>","text":"<p>Remove an inference.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <p>Raises:</p> Type Description <code>DatasetDoesNotExistError</code> <p>If the dataset doesn't exist.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def remove_inference(self, dataset_name: str, model_name: str):\n    \"\"\"\n    Remove an inference.\n\n    Parameters\n    ----------\n    dataset_name: str\n        The name of the dataset.\n    model_name: str\n        The name of the model.\n\n\n    Raises\n    ----------\n    DatasetDoesNotExistError\n        If the dataset doesn't exist.\n    \"\"\"\n    if dataset_name not in self.datasets:\n        raise DatasetDoesNotExistError(dataset_name)\n    # purge key_to_values\n    for job_id in self.datasets[dataset_name].models[model_name].jobs:\n        del self.key_to_values[job_id]\n    # remove inference\n    self.datasets[dataset_name].remove_inference(dataset_name, model_name)\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.remove_job","title":"<code>velour_api.schemas.Stateflow.remove_job(dataset_name, model_name, job_id)</code>","text":"<p>Remove a job.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <code>job_id</code> <code>int</code> <p>The id of the job.</p> required <p>Raises:</p> Type Description <code>DatasetDoesNotExistError</code> <p>If the dataset doesn't exist.</p> <code>ModelDoesNotExistError</code> <p>If the model doesn't exist.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def remove_job(\n    self,\n    dataset_name: str,\n    model_name: str,\n    job_id: int,\n):\n    \"\"\"\n    Remove a job.\n\n    Parameters\n    ----------\n    dataset_name: str\n        The name of the dataset.\n    model_name: str\n        The name of the model.\n    job_id: int\n        The id of the job.\n\n    Raises\n    ----------\n    DatasetDoesNotExistError\n        If the dataset doesn't exist.\n    ModelDoesNotExistError\n        If the model doesn't exist.\n    \"\"\"\n    if dataset_name not in self.datasets:\n        raise DatasetDoesNotExistError(dataset_name)\n    elif model_name not in self.datasets[dataset_name].models:\n        raise ModelDoesNotExistError(model_name)\n    self.datasets[dataset_name].models[model_name].remove_job(job_id)\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.remove_model","title":"<code>velour_api.schemas.Stateflow.remove_model(model_name)</code>","text":"<p>Remove a model.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model.</p> required Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def remove_model(self, model_name: str):\n    \"\"\"\n    Remove a model.\n\n    Parameters\n    ----------\n    model_name: str\n        The name of the model.\n    \"\"\"\n    for dataset_name, dataset in self.datasets.items():\n        if model_name in dataset.models:\n            # purge key_to_values\n            for job_id in dataset.models[model_name].jobs:\n                del self.key_to_values[job_id]\n            # remove inference\n            dataset.remove_inference(dataset_name, model_name)\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.set_dataset_status","title":"<code>velour_api.schemas.Stateflow.set_dataset_status(dataset_name, status)</code>","text":"<p>Sets the status of a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>status</code> <code>State</code> <p>The status of the dataset.</p> required <p>Raises:</p> Type Description <code>DatasetDoesNotExistError</code> <p>If the dataset doesn't exist.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def set_dataset_status(self, dataset_name: str, status: State):\n    \"\"\"\n    Sets the status of a dataset.\n\n    Parameters\n    ----------\n    dataset_name: str\n        The name of the dataset.\n    status : State\n        The status of the dataset.\n\n    Raises\n    ----------\n    DatasetDoesNotExistError\n        If the dataset doesn't exist.\n    \"\"\"\n    if dataset_name not in self.datasets:\n        if status not in [State.NONE, State.CREATE]:\n            raise DatasetDoesNotExistError(dataset_name)\n        self.datasets[dataset_name] = DatasetState()\n    elif (\n        self.datasets[dataset_name].evaluating and status != State.EVALUATE\n    ):\n        raise StateflowError(\n            f\"cannot transition to {status} as an evaluation is running.\"\n        )\n    elif status not in self.datasets[dataset_name].status.next():\n        raise _state_transition_error(\n            before=self.datasets[dataset_name].status,\n            after=status,\n            dataset_name=dataset_name,\n        )\n    self.datasets[dataset_name].status = status\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.set_inference_status","title":"<code>velour_api.schemas.Stateflow.set_inference_status(dataset_name, model_name, status)</code>","text":"<p>Sets the status of an inference.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <code>status</code> <code>State</code> <p>The status of the inference.</p> required <p>Raises:</p> Type Description <code>DatasetDoesNotExistError</code> <p>If the dataset doesn't exist.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def set_inference_status(\n    self, dataset_name: str, model_name: str, status: State\n):\n    \"\"\"\n    Sets the status of an inference.\n\n    Parameters\n    ----------\n    dataset_name: str\n        The name of the dataset.\n    model_name: str\n        The name of the model.\n    status : State\n        The status of the inference.\n\n    Raises\n    ----------\n    DatasetDoesNotExistError\n        If the dataset doesn't exist.\n    \"\"\"\n    if dataset_name not in self.datasets:\n        raise DatasetDoesNotExistError(dataset_name)\n\n    if self.datasets[dataset_name].status == State.CREATE:\n        if status not in [State.NONE, State.CREATE, State.DELETE]:\n            raise DatasetNotFinalizedError(dataset_name)\n        self.datasets[dataset_name].set_inference_status(\n            dataset_name=dataset_name,\n            model_name=model_name,\n            status=status,\n        )\n    elif self.datasets[dataset_name].status in [\n        State.READY,\n        State.EVALUATE,\n    ]:\n        self.datasets[dataset_name].set_inference_status(\n            dataset_name=dataset_name,\n            model_name=model_name,\n            status=status,\n        )\n        self.set_dataset_status(\n            dataset_name=dataset_name,\n            status=State.EVALUATE\n            if self.datasets[dataset_name].evaluating\n            else State.READY,\n        )\n    else:\n        raise StateflowError(\n            f\"dataset `{dataset_name}` does not support model operations in its current state `{self.datasets[dataset_name].status}`\"\n        )\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.set_job_status","title":"<code>velour_api.schemas.Stateflow.set_job_status(dataset_name, model_name, job_id, status)</code>","text":"<p>Sets the status of a job.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <code>job_id</code> <code>int</code> <p>The id of the job.</p> required <code>status</code> <code>State</code> <p>The status of the job.</p> required <p>Raises:</p> Type Description <code>DatasetDoesNotExistError</code> <p>If the dataset doesn't exist.</p> <code>ModelDoesNotExistError</code> <p>If the model doesn't exist.</p> Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def set_job_status(\n    self,\n    dataset_name: str,\n    model_name: str,\n    job_id: int,\n    status: JobStatus,\n):\n    \"\"\"\n    Sets the status of a job.\n\n    Parameters\n    ----------\n    dataset_name: str\n        The name of the dataset.\n    model_name: str\n        The name of the model.\n    job_id: int\n        The id of the job.\n    status : State\n        The status of the job.\n\n    Raises\n    ----------\n    DatasetDoesNotExistError\n        If the dataset doesn't exist.\n    ModelDoesNotExistError\n        If the model doesn't exist.\n    \"\"\"\n    if dataset_name not in self.datasets:\n        raise DatasetDoesNotExistError(dataset_name)\n    elif model_name not in self.datasets[dataset_name].models:\n        raise ModelDoesNotExistError(model_name)\n    self.datasets[dataset_name].models[model_name].set_job_status(\n        job_id, status\n    )\n    if job_id not in self.key_to_values:\n        self.key_to_values[job_id] = [dataset_name, model_name]\n</code></pre>"},{"location":"references/API/Schemas/Stateflow/#velour_api.schemas.Stateflow.set_model_status","title":"<code>velour_api.schemas.Stateflow.set_model_status(model_name, status)</code>","text":"<p>Sets the status of a model.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model.</p> required <code>status</code> <code>State</code> <p>The status of the model.</p> required Source code in <code>api/velour_api/schemas/stateflow.py</code> <pre><code>def set_model_status(self, model_name: str, status: State):\n    \"\"\"\n    Sets the status of a model.\n\n    Parameters\n    ----------\n    model_name: str\n        The name of the model.\n    status : State\n        The status of the model.\n    \"\"\"\n    for dataset_name in self.datasets:\n        if model_name in self.datasets[dataset_name].models:\n            self.datasets[dataset_name].set_inference_status(\n                dataset_name, model_name, status=status\n            )\n</code></pre>"},{"location":"references/Python%20Client/Data%20Generation/","title":"Data Generation","text":""},{"location":"references/Python%20Client/Data%20Generation/#velour.data_generation-classes","title":"Classes","text":""},{"location":"references/Python%20Client/Data%20Generation/#velour.data_generation-functions","title":"Functions","text":""},{"location":"references/Python%20Client/Data%20Generation/#velour.data_generation.generate_prediction_data","title":"<code>velour.data_generation.generate_prediction_data(client, dataset, model_name, n_predictions=10, n_annotations=10, n_labels=2)</code>","text":"<p>Generate an arbitrary number of predictions for a previously-generated dataset.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Session</code> <p>The Client object used to access your velour instance.</p> required <code>dataset</code> <code>Dataset</code> <p>The dataset object to create predictions for.</p> required <code>model_name</code> <code>str</code> <p>The name of your model.</p> required <code>n_predictions</code> <code>int</code> <p>The number of images you'd like your dataset to contain.</p> <code>10</code> <code>n_annotations</code> <code>int</code> <p>The number of annotations per prediction you'd like your dataset to contain.</p> <code>10</code> <code>n_labels</code> <code>int</code> <p>The number of labels per annotation you'd like your dataset to contain.</p> <code>2</code> Source code in <code>client/velour/data_generation.py</code> <pre><code>def generate_prediction_data(\n    client: Client,\n    dataset: Dataset,\n    model_name: str,\n    n_predictions: int = 10,\n    n_annotations: int = 10,\n    n_labels: int = 2,\n):\n    \"\"\"\n    Generate an arbitrary number of predictions for a previously-generated dataset.\n\n    Parameters\n    ----------\n    client : Session\n        The Client object used to access your velour instance.\n    dataset : Dataset\n        The dataset object to create predictions for.\n    model_name : str\n        The name of your model.\n    n_predictions : int\n        The number of images you'd like your dataset to contain.\n    n_annotations : int\n        The number of annotations per prediction you'd like your dataset to contain.\n    n_labels : int\n        The number of labels per annotation you'd like your dataset to contain.\n    \"\"\"\n    model = Model.create(client, model_name)\n\n    datums = dataset.get_datums()\n\n    for datum in datums:\n        height, width = (datum.metadata[\"height\"], datum.metadata[\"width\"])\n\n        for _ in range(n_predictions):\n            prediction = _generate_prediction(\n                model_name=model_name,\n                datum=datum,\n                height=height,\n                width=width,\n                n_annotations=n_annotations,\n                n_labels=n_labels,\n            )\n            model.add_prediction(prediction)\n\n    model.finalize_inferences(dataset)\n    return model\n</code></pre>"},{"location":"references/Python%20Client/Data%20Generation/#velour.data_generation.generate_segmentation_data","title":"<code>velour.data_generation.generate_segmentation_data(client, dataset_name, n_images=10, n_annotations=10, n_labels=2)</code>","text":"<p>Generate a synthetic velour dataset given a set of input images.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Session</code> <p>The Client object used to access your velour instance.</p> required <code>dataset_name</code> <code>str</code> <p>The name of the dataset you want to generate in velour.</p> required <code>n_images</code> <code>int</code> <p>The number of images you'd like your dataset to contain.</p> <code>10</code> <code>n_annotations</code> <code>int</code> <p>The number of annotations per image you'd like your dataset to contain.</p> <code>10</code> <code>n_labels</code> <code>int</code> <p>The number of labels per annotation you'd like your dataset to contain.</p> <code>2</code> Source code in <code>client/velour/data_generation.py</code> <pre><code>def generate_segmentation_data(\n    client: Client,\n    dataset_name: str,\n    n_images: int = 10,\n    n_annotations: int = 10,\n    n_labels: int = 2,\n) -&gt; Dataset:\n    \"\"\"\n    Generate a synthetic velour dataset given a set of input images.\n\n    Parameters\n    ----------\n    client : Session\n        The Client object used to access your velour instance.\n    dataset_name : str\n        The name of the dataset you want to generate in velour.\n    n_images : int\n        The number of images you'd like your dataset to contain.\n    n_annotations : int\n        The number of annotations per image you'd like your dataset to contain.\n    n_labels : int\n        The number of labels per annotation you'd like your dataset to contain.\n    \"\"\"\n    dataset = Dataset.create(client, dataset_name)\n\n    unique_image_ids = list(range(n_images))\n    for _ in tqdm(range(n_images)):\n        gt = _generate_ground_truth(\n            unique_image_id=str(\n                _sample_without_replacement(unique_image_ids, 1)[0]\n            ),\n            n_annotations=n_annotations,\n            n_labels=n_labels,\n        )\n        dataset.add_groundtruth(gt)\n\n    dataset.finalize()\n\n    return dataset\n</code></pre>"},{"location":"references/Python%20Client/ImageMetadata/","title":"ImageMetadata","text":"<p>A class describing the metadata for a particular image.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The UID of the image.</p> required <code>height</code> <code>int</code> <p>The height of the image.</p> required <code>width</code> <code>int</code> <p>The width of the image.</p> required <code>dataset</code> <code>str</code> <p>The name of the dataset associated with the image.</p> <code>''</code> <code>metadata</code> <code>dict</code> <p>A dictionary of metadata that describes the image.</p> <code>None</code> <code>geospatial</code> <code> dict</code> <p>A GeoJSON-style dictionary describing the geospatial coordinates of the image.</p> <code>None</code> Source code in <code>client/velour/metatypes.py</code> <pre><code>class ImageMetadata:\n    \"\"\"\n    A class describing the metadata for a particular image.\n\n    Parameters\n    ----------\n    uid : str\n        The UID of the image.\n    height : int\n        The height of the image.\n    width : int\n        The width of the image.\n    dataset : str\n        The name of the dataset associated with the image.\n    metadata : dict\n        A dictionary of metadata that describes the image.\n    geospatial :  dict\n        A GeoJSON-style dictionary describing the geospatial coordinates of the image.\n    \"\"\"\n\n    def __init__(\n        self,\n        uid: str,\n        height: int,\n        width: int,\n        dataset: str = \"\",\n        metadata: Dict[str, Union[int, float, str]] = None,\n        geospatial: Dict[\n            str,\n            Union[\n                List[List[List[List[Union[float, int]]]]],\n                List[List[List[Union[float, int]]]],\n                List[Union[float, int]],\n                str,\n            ],\n        ] = None,\n    ):\n        self.uid = uid\n        self.dataset = dataset\n        self.height = height\n        self.width = width\n        self.metadata = metadata if metadata else {}\n        self.geospatial = geospatial if geospatial else {}\n\n        if not isinstance(self.dataset, str):\n            raise TypeError(\"ImageMetadata dataset name must be a string.\")\n        if not isinstance(self.uid, str):\n            raise TypeError(\"ImageMetadata uid must be a string.\")\n        if not isinstance(self.height, int):\n            raise TypeError(\"ImageMetadata height must be a int.\")\n        if not isinstance(self.width, int):\n            raise TypeError(\"ImageMetadata height must be a int.\")\n        validate_metadata(self.metadata)\n\n    @staticmethod\n    def valid(datum: Datum) -&gt; bool:\n        \"\"\"\n        Asserts wehether the `Datum's` height and width is a valid subset of the image's height and width.\n\n        Parameters\n        ----------\n        datum : Datum\n            The `Datum` to check validity for.\n        \"\"\"\n        return {\"height\", \"width\"}.issubset(datum.metadata)\n\n    @classmethod\n    def from_datum(cls, datum: Datum):\n        \"\"\"\n        Creates an `ImageMetadata` object from a `Datum`.\n\n        Parameters\n        ----------\n        datum : Datum\n            The `Datum` to extract metadata from.\n        \"\"\"\n        if not cls.valid(datum):\n            raise ValueError(\n                f\"`datum` does not contain height and/or width in metadata `{datum.metadata}`\"\n            )\n        metadata = datum.metadata.copy()\n        return cls(\n            dataset=datum.dataset,\n            uid=datum.uid,\n            height=int(metadata.pop(\"height\")),\n            width=int(metadata.pop(\"width\")),\n            metadata=metadata,\n        )\n\n    @classmethod\n    def from_pil(cls, uid: str, image: PIL.Image.Image):\n        \"\"\"\n        Creates an `ImageMetadata` object from an image.\n\n        Parameters\n        ----------\n        uid : str\n            The UID of the image.\n        image : PIL.Image.Image\n            The image to create metadata for.\n        \"\"\"\n        width, height = image.size\n        return cls(\n            uid=uid,\n            height=int(height),\n            width=int(width),\n        )\n\n    def to_datum(self) -&gt; Datum:\n        \"\"\"\n        Converts an `ImageMetadata` object into a `Datum`.\n        \"\"\"\n        metadata = self.metadata.copy() if self.metadata else {}\n        geospatial = self.geospatial.copy() if self.geospatial else {}\n\n        metadata[\"height\"] = self.height\n        metadata[\"width\"] = self.width\n        return Datum(\n            dataset=self.dataset,\n            uid=self.uid,\n            metadata=metadata,\n            geospatial=geospatial,\n        )\n</code></pre>"},{"location":"references/Python%20Client/ImageMetadata/#velour.metatypes.ImageMetadata-functions","title":"Functions","text":""},{"location":"references/Python%20Client/ImageMetadata/#velour.metatypes.ImageMetadata.from_datum","title":"<code>velour.metatypes.ImageMetadata.from_datum(datum)</code>  <code>classmethod</code>","text":"<p>Creates an <code>ImageMetadata</code> object from a <code>Datum</code>.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>Datum</code> <p>The <code>Datum</code> to extract metadata from.</p> required Source code in <code>client/velour/metatypes.py</code> <pre><code>@classmethod\ndef from_datum(cls, datum: Datum):\n    \"\"\"\n    Creates an `ImageMetadata` object from a `Datum`.\n\n    Parameters\n    ----------\n    datum : Datum\n        The `Datum` to extract metadata from.\n    \"\"\"\n    if not cls.valid(datum):\n        raise ValueError(\n            f\"`datum` does not contain height and/or width in metadata `{datum.metadata}`\"\n        )\n    metadata = datum.metadata.copy()\n    return cls(\n        dataset=datum.dataset,\n        uid=datum.uid,\n        height=int(metadata.pop(\"height\")),\n        width=int(metadata.pop(\"width\")),\n        metadata=metadata,\n    )\n</code></pre>"},{"location":"references/Python%20Client/ImageMetadata/#velour.metatypes.ImageMetadata.from_pil","title":"<code>velour.metatypes.ImageMetadata.from_pil(uid, image)</code>  <code>classmethod</code>","text":"<p>Creates an <code>ImageMetadata</code> object from an image.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The UID of the image.</p> required <code>image</code> <code>Image</code> <p>The image to create metadata for.</p> required Source code in <code>client/velour/metatypes.py</code> <pre><code>@classmethod\ndef from_pil(cls, uid: str, image: PIL.Image.Image):\n    \"\"\"\n    Creates an `ImageMetadata` object from an image.\n\n    Parameters\n    ----------\n    uid : str\n        The UID of the image.\n    image : PIL.Image.Image\n        The image to create metadata for.\n    \"\"\"\n    width, height = image.size\n    return cls(\n        uid=uid,\n        height=int(height),\n        width=int(width),\n    )\n</code></pre>"},{"location":"references/Python%20Client/ImageMetadata/#velour.metatypes.ImageMetadata.to_datum","title":"<code>velour.metatypes.ImageMetadata.to_datum()</code>","text":"<p>Converts an <code>ImageMetadata</code> object into a <code>Datum</code>.</p> Source code in <code>client/velour/metatypes.py</code> <pre><code>def to_datum(self) -&gt; Datum:\n    \"\"\"\n    Converts an `ImageMetadata` object into a `Datum`.\n    \"\"\"\n    metadata = self.metadata.copy() if self.metadata else {}\n    geospatial = self.geospatial.copy() if self.geospatial else {}\n\n    metadata[\"height\"] = self.height\n    metadata[\"width\"] = self.width\n    return Datum(\n        dataset=self.dataset,\n        uid=self.uid,\n        metadata=metadata,\n        geospatial=geospatial,\n    )\n</code></pre>"},{"location":"references/Python%20Client/ImageMetadata/#velour.metatypes.ImageMetadata.valid","title":"<code>velour.metatypes.ImageMetadata.valid(datum)</code>  <code>staticmethod</code>","text":"<p>Asserts wehether the <code>Datum's</code> height and width is a valid subset of the image's height and width.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>Datum</code> <p>The <code>Datum</code> to check validity for.</p> required Source code in <code>client/velour/metatypes.py</code> <pre><code>@staticmethod\ndef valid(datum: Datum) -&gt; bool:\n    \"\"\"\n    Asserts wehether the `Datum's` height and width is a valid subset of the image's height and width.\n\n    Parameters\n    ----------\n    datum : Datum\n        The `Datum` to check validity for.\n    \"\"\"\n    return {\"height\", \"width\"}.issubset(datum.metadata)\n</code></pre>"},{"location":"references/Python%20Client/VideoFrameMetadata/","title":"VideoFrameMetadata","text":"<p>A class describing the metadata for the frame of a video.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ImageMetadata</code> <p>Metadata describing the frame of the video.</p> required <code>frame</code> <code>int</code> <p>The number of seconds into the video that the frame was taken.</p> required Source code in <code>client/velour/metatypes.py</code> <pre><code>class VideoFrameMetadata:\n    \"\"\"\n    A class describing the metadata for the frame of a video.\n\n    Parameters\n    ----------\n    image : ImageMetadata\n        Metadata describing the frame of the video.\n    frame: int\n        The number of seconds into the video that the frame was taken.\n    \"\"\"\n\n    def __init__(\n        self,\n        image: ImageMetadata,\n        frame: int,\n    ):\n        self.image = image\n        self.frame = frame\n\n        if not isinstance(self.image, ImageMetadata):\n            raise SchemaTypeError(\"image\", ImageMetadata, self.image)\n        if not isinstance(self.frame, int):\n            raise SchemaTypeError(\"frame\", int, self.frame)\n\n    @staticmethod\n    def valid(datum: Datum) -&gt; bool:\n        \"\"\"\n        Asserts wehether the `Datum's` height and width is a valid subset of the image's height and width.\n\n        Parameters\n        ----------\n        datum : Datum\n            The `Datum` to check validity for.\n        \"\"\"\n        return {\"height\", \"width\", \"frame\"}.issubset(datum.metadata)\n\n    @classmethod\n    def from_datum(cls, datum: Datum):\n        \"\"\"\n        Creates an `VideoFrameMetadata` object from a `Datum`.\n\n        Parameters\n        ----------\n        datum : Datum\n            The `Datum` to extract metadata from.\n        \"\"\"\n        if not cls.valid(datum):\n            raise ValueError(\n                f\"`datum` does not contain height, width and/or frame in metadata `{datum.metadata}`\"\n            )\n        image = ImageMetadata.from_datum(datum)\n        frame = image.metadata.pop(\"frame\")\n        return cls(\n            image=image,\n            frame=frame,\n        )\n\n    def to_datum(self) -&gt; Datum:\n        \"\"\"\n        Converts an `VideoFrameMetadata` object into a `Datum`.\n        \"\"\"\n        datum = self.image.to_datum()\n        datum.metadata[\"frame\"] = self.frame\n        return datum\n</code></pre>"},{"location":"references/Python%20Client/VideoFrameMetadata/#velour.metatypes.VideoFrameMetadata-functions","title":"Functions","text":""},{"location":"references/Python%20Client/VideoFrameMetadata/#velour.metatypes.VideoFrameMetadata.from_datum","title":"<code>velour.metatypes.VideoFrameMetadata.from_datum(datum)</code>  <code>classmethod</code>","text":"<p>Creates an <code>VideoFrameMetadata</code> object from a <code>Datum</code>.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>Datum</code> <p>The <code>Datum</code> to extract metadata from.</p> required Source code in <code>client/velour/metatypes.py</code> <pre><code>@classmethod\ndef from_datum(cls, datum: Datum):\n    \"\"\"\n    Creates an `VideoFrameMetadata` object from a `Datum`.\n\n    Parameters\n    ----------\n    datum : Datum\n        The `Datum` to extract metadata from.\n    \"\"\"\n    if not cls.valid(datum):\n        raise ValueError(\n            f\"`datum` does not contain height, width and/or frame in metadata `{datum.metadata}`\"\n        )\n    image = ImageMetadata.from_datum(datum)\n    frame = image.metadata.pop(\"frame\")\n    return cls(\n        image=image,\n        frame=frame,\n    )\n</code></pre>"},{"location":"references/Python%20Client/VideoFrameMetadata/#velour.metatypes.VideoFrameMetadata.to_datum","title":"<code>velour.metatypes.VideoFrameMetadata.to_datum()</code>","text":"<p>Converts an <code>VideoFrameMetadata</code> object into a <code>Datum</code>.</p> Source code in <code>client/velour/metatypes.py</code> <pre><code>def to_datum(self) -&gt; Datum:\n    \"\"\"\n    Converts an `VideoFrameMetadata` object into a `Datum`.\n    \"\"\"\n    datum = self.image.to_datum()\n    datum.metadata[\"frame\"] = self.frame\n    return datum\n</code></pre>"},{"location":"references/Python%20Client/VideoFrameMetadata/#velour.metatypes.VideoFrameMetadata.valid","title":"<code>velour.metatypes.VideoFrameMetadata.valid(datum)</code>  <code>staticmethod</code>","text":"<p>Asserts wehether the <code>Datum's</code> height and width is a valid subset of the image's height and width.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>Datum</code> <p>The <code>Datum</code> to check validity for.</p> required Source code in <code>client/velour/metatypes.py</code> <pre><code>@staticmethod\ndef valid(datum: Datum) -&gt; bool:\n    \"\"\"\n    Asserts wehether the `Datum's` height and width is a valid subset of the image's height and width.\n\n    Parameters\n    ----------\n    datum : Datum\n        The `Datum` to check validity for.\n    \"\"\"\n    return {\"height\", \"width\", \"frame\"}.issubset(datum.metadata)\n</code></pre>"},{"location":"references/Python%20Client/Viz/","title":"Viz","text":""},{"location":"references/Python%20Client/Viz/#velour.viz-classes","title":"Classes","text":""},{"location":"references/Python%20Client/Viz/#velour.viz-functions","title":"Functions","text":""},{"location":"references/Python%20Client/Viz/#velour.viz.create_combined_segmentation_mask","title":"<code>velour.viz.create_combined_segmentation_mask(annotated_datums, label_key, task_type=None)</code>","text":"<p>Creates a combined segmentation mask from a list of segmentations.</p> <p>Parameters:</p> Name Type Description Default <code>annotated_datums</code> <code>List[Union[GroundTruth, Prediction]]</code> <p>A list of segmentations. These all must have the same <code>image</code> attribute.</p> required <code>label_key</code> <code>str</code> <p>The label key to use.</p> required <code>task_type</code> <code>TaskType</code> <p>The associated task type.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>The first element of the tuple is the combined mask, as an RGB PIL image. The second element is a color legend: it's a dict with keys the unique values of the labels and the values of the dict are PIL image swatches of the color corresponding to the label value.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If all segmentations don't belong to the same image, or there is a segmentation that doesn't have <code>label_key</code> as the key of one of its labels.</p> <code>ValueError</code> <p>If there aren't any segmentations.</p> Source code in <code>client/velour/viz.py</code> <pre><code>def create_combined_segmentation_mask(\n    annotated_datums: List[Union[GroundTruth, Prediction]],\n    label_key: str,\n    task_type: Union[enums.TaskType, None] = None,\n) -&gt; Tuple[Image.Image, Dict[str, Image.Image]]:\n    \"\"\"\n    Creates a combined segmentation mask from a list of segmentations.\n\n    Parameters\n    -------\n    annotated_datums : List[Union[GroundTruth, Prediction]]\n        A list of segmentations. These all must have the same `image` attribute.\n    label_key : str\n        The label key to use.\n    task_type : enums.TaskType\n        The associated task type.\n\n\n    Returns\n    -------\n    tuple\n        The first element of the tuple is the combined mask, as an RGB PIL image. The second\n        element is a color legend: it's a dict with keys the unique values of the labels and the\n        values of the dict are PIL image swatches of the color corresponding to the label value.\n\n    Raises\n    ------\n    RuntimeError\n        If all segmentations don't belong to the same image, or there is a\n        segmentation that doesn't have `label_key` as the key of one of its labels.\n    ValueError\n        If there aren't any segmentations.\n    \"\"\"\n\n    if len(annotated_datums) == 0:\n        raise ValueError(\"`segs` cannot be empty.\")\n\n    if (\n        len(\n            set(\n                [\n                    annotated_datum.datum.uid\n                    for annotated_datum in annotated_datums\n                ]\n            )\n        )\n        &gt; 1\n    ):\n        raise RuntimeError(\n            \"Expected all segmentation to belong to the same image\"\n        )\n\n    # Validate task type\n    if task_type is not None and task_type not in [\n        enums.TaskType.DETECTION,\n        enums.TaskType.SEGMENTATION,\n    ]:\n        raise RuntimeError(\n            \"Expected either Instance or Semantic segmentation task_type.\"\n        )\n\n    # Create valid task type list\n    if task_type is None:\n        task_types = [\n            enums.TaskType.DETECTION,\n            enums.TaskType.SEGMENTATION,\n        ]\n    else:\n        task_types = [task_type]\n\n    # unpack raster annotations\n    annotations: List[Annotation] = []\n    for annotated_datum in annotated_datums:\n        for annotation in annotated_datum.annotations:\n            if annotation.task_type in task_types:\n                annotations.append(annotation)\n\n    label_values = []\n    for annotation in annotations:\n        for label in annotation.labels:\n            if label.key == label_key:\n                label_values.append(label.value)\n    if not label_values:\n        raise RuntimeError(\n            \"Annoation doesn't have a label with key `{label.key}`\"\n        )\n\n    unique_label_values = list(set(label_values))\n    label_value_to_color = {\n        v: COLOR_MAP[i] for i, v in enumerate(unique_label_values)\n    }\n    seg_colors = [label_value_to_color[v] for v in label_values]\n\n    image = ImageMetadata.from_datum(annotated_datums[0].datum)\n    img_w, img_h = image.width, image.height\n\n    combined_mask = np.zeros((img_h, img_w, 3), dtype=np.uint8)\n    for annotation, color in zip(annotations, seg_colors):\n        if annotation.raster is not None:\n            mask = annotation.raster.to_numpy()\n        elif annotation.multipolygon is not None:\n            mask = _polygons_to_binary_mask(\n                annotation.multipolygon.polygons,\n                img_w=img_w,\n                img_h=img_h,\n            )\n        else:\n            continue\n\n        combined_mask[np.where(mask)] = color\n\n    legend = {\n        v: Image.new(\"RGB\", (20, 20), color)\n        for v, color in label_value_to_color.items()\n    }\n\n    return Image.fromarray(combined_mask), legend\n</code></pre>"},{"location":"references/Python%20Client/Viz/#velour.viz.draw_detections_on_image","title":"<code>velour.viz.draw_detections_on_image(detections, img)</code>","text":"<p>Draws detections (bounding boxes and labels) on an image.</p> <p>Parameters:</p> Name Type Description Default <code>detections</code> <code>List[Union[GroundTruth, Prediction]]</code> <p>A list of <code>GroundTruths</code> or <code>Predictions</code> to draw on the image.</p> required <code>img</code> <code>Image</code> <p>The image to draw the detections on.</p> required <p>Returns:</p> Name Type Description <code>img</code> <code>Image</code> <p>An image with the detections drawn on.</p> Source code in <code>client/velour/viz.py</code> <pre><code>def draw_detections_on_image(\n    detections: List[Union[GroundTruth, Prediction]],\n    img: Image.Image,\n) -&gt; Image.Image:\n    \"\"\"\n    Draws detections (bounding boxes and labels) on an image.\n\n    Parameters\n    -------\n    detections : List[Union[GroundTruth, Prediction]]\n        A list of `GroundTruths` or `Predictions` to draw on the image.\n    img : Image.Image\n        The image to draw the detections on.\n\n\n    Returns\n    -------\n    img : Image.Image\n        An image with the detections drawn on.\n    \"\"\"\n\n    annotations = []\n    for datum in detections:\n        annotations.extend(datum.annotations)\n\n    for i, detection in enumerate(annotations):\n        if detection.task_type in [enums.TaskType.DETECTION]:\n            img = _draw_detection_on_image(detection, img, inplace=i != 0)\n    return img\n</code></pre>"},{"location":"references/Python%20Client/annotation/","title":"Annotation","text":"<p>A class used to annotate <code>GroundTruths</code> and <code>Predictions</code>.</p> <p>Parameters:</p> Name Type Description Default <code>task_type</code> <code>TaskType</code> <p>The task type associated with the <code>Annotation</code>.</p> required <code>labels</code> <code>List[Label]</code> <p>A list of labels to use for the <code>Annotation</code>.</p> required <code>metadata</code> <code>Dict[str, Union[int, float, str]]</code> <p>A dictionary of metadata that describes the <code>Annotation</code>.</p> <code>None</code> <code>bounding_box</code> <code>BoundingBox</code> <p>A bounding box to assign to the <code>Annotation</code>.</p> <code>None</code> <code>polygon</code> <code>Polygon</code> <p>A polygon to assign to the <code>Annotation</code>.</p> <code>None</code> <code>multipolygon</code> <code>MultiPolygon</code> <p>A multipolygon to assign to the <code>Annotation</code>.</p> <code>None</code> <code>raster</code> <code>Raster</code> <p>A raster to assign to the <code>Annotation</code>.</p> <code>None</code> <code>jsonb</code> <code>Dict</code> <p>A jsonb to assign to the <code>Annotation</code>.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>geometric_area</code> <code>float</code> <p>The area of the annotation.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>class Annotation:\n    \"\"\"\n    A class used to annotate `GroundTruths` and `Predictions`.\n\n    Parameters\n    ----------\n    task_type: TaskType\n        The task type associated with the `Annotation`.\n    labels: List[Label]\n        A list of labels to use for the `Annotation`.\n    metadata: Dict[str, Union[int, float, str]]\n        A dictionary of metadata that describes the `Annotation`.\n    bounding_box: BoundingBox\n        A bounding box to assign to the `Annotation`.\n    polygon: Polygon\n        A polygon to assign to the `Annotation`.\n    multipolygon: MultiPolygon\n        A multipolygon to assign to the `Annotation`.\n    raster: Raster\n        A raster to assign to the `Annotation`.\n    jsonb: Dict\n        A jsonb to assign to the `Annotation`.\n\n    Attributes\n    ----------\n    geometric_area : float\n        The area of the annotation.\n    \"\"\"\n\n    task = DeclarativeMapper(\"task_types\", TaskType)\n    type = DeclarativeMapper(\"annotation_types\", AnnotationType)\n    geometric_area = DeclarativeMapper(\"annotation_geometric_area\", float)\n    metadata = DeclarativeMapper(\"annotation_metadata\", Union[int, float, str])\n    geospatial = DeclarativeMapper(\n        \"annotation_geospatial\",\n        Union[\n            List[List[List[List[Union[float, int]]]]],\n            List[List[List[Union[float, int]]]],\n            List[Union[float, int]],\n            str,\n        ],\n    )\n\n    def __init__(\n        self,\n        task_type: TaskType,\n        labels: List[Label],\n        metadata: Dict[str, Union[int, float, str]] = None,\n        bounding_box: BoundingBox = None,\n        polygon: Polygon = None,\n        multipolygon: MultiPolygon = None,\n        raster: Raster = None,\n        jsonb: Dict = None,\n    ):\n        self.task_type = task_type\n        self.labels = labels\n        self.metadata = metadata if metadata else {}\n        self.bounding_box = bounding_box\n        self.polygon = polygon\n        self.multipolygon = multipolygon\n        self.raster = raster\n        self.jsonb = jsonb\n        self._validate()\n\n    def _validate(self):\n        \"\"\"\n        Validates the parameters used to create a `Annotation` object.\n        \"\"\"\n\n        # task_type\n        if not isinstance(self.task_type, TaskType):\n            self.task_type = TaskType(self.task_type)\n\n        # labels\n        if not isinstance(self.labels, list):\n            raise SchemaTypeError(\"labels\", List[Label], self.labels)\n        for idx, label in enumerate(self.labels):\n            if isinstance(self.labels[idx], dict):\n                self.labels[idx] = Label(**label)\n            if not isinstance(self.labels[idx], Label):\n                raise SchemaTypeError(\"label\", Label, self.labels[idx])\n\n        # annotation data\n        if self.bounding_box:\n            if isinstance(self.bounding_box, dict):\n                self.bounding_box = BoundingBox(**self.bounding_box)\n            if not isinstance(self.bounding_box, BoundingBox):\n                raise SchemaTypeError(\n                    \"bounding_box\", BoundingBox, self.bounding_box\n                )\n        if self.polygon:\n            if isinstance(self.polygon, dict):\n                self.polygon = Polygon(**self.polygon)\n            if not isinstance(self.polygon, Polygon):\n                raise SchemaTypeError(\"polygon\", Polygon, self.polygon)\n        if self.multipolygon:\n            if isinstance(self.multipolygon, dict):\n                self.multipolygon = MultiPolygon(**self.multipolygon)\n            if not isinstance(self.multipolygon, MultiPolygon):\n                raise SchemaTypeError(\n                    \"multipolygon\", MultiPolygon, self.multipolygon\n                )\n        if self.raster:\n            if isinstance(self.raster, dict):\n                self.raster = Raster(**self.raster)\n            if not isinstance(self.raster, Raster):\n                raise SchemaTypeError(\"raster\", Raster, self.raster)\n\n        # metadata\n        validate_metadata(self.metadata)\n\n    def dict(self) -&gt; dict:\n        \"\"\"\n        Defines how a `Annotation` object is transformed into a dictionary.\n\n        Returns\n        ----------\n        dict\n            A dictionary of the `Annotation's` attributes.\n        \"\"\"\n        return {\n            \"task_type\": self.task_type.value,\n            \"labels\": [label.dict() for label in self.labels],\n            \"metadata\": self.metadata,\n            \"bounding_box\": asdict(self.bounding_box)\n            if self.bounding_box\n            else None,\n            \"polygon\": asdict(self.polygon) if self.polygon else None,\n            \"multipolygon\": asdict(self.multipolygon)\n            if self.multipolygon\n            else None,\n            \"raster\": asdict(self.raster) if self.raster else None,\n            \"jsonb\": self.jsonb,\n        }\n\n    def __eq__(self, other):\n        \"\"\"\n        Defines how `Annotations` are compared to one another\n\n        Parameters\n        ----------\n        other : Annotation\n            The object to compare with the `Annotation`.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n        \"\"\"\n        if not isinstance(other, Annotation):\n            raise TypeError(\n                f\"Expected type `{type(Annotation)}`, got `{other}`\"\n            )\n        return self.dict() == other.dict()\n</code></pre>"},{"location":"references/Python%20Client/annotation/#velour.Annotation-functions","title":"Functions","text":""},{"location":"references/Python%20Client/annotation/#velour.Annotation.__eq__","title":"<code>velour.Annotation.__eq__(other)</code>","text":"<p>Defines how <code>Annotations</code> are compared to one another</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Annotation</code> <p>The object to compare with the <code>Annotation</code>.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Defines how `Annotations` are compared to one another\n\n    Parameters\n    ----------\n    other : Annotation\n        The object to compare with the `Annotation`.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n    \"\"\"\n    if not isinstance(other, Annotation):\n        raise TypeError(\n            f\"Expected type `{type(Annotation)}`, got `{other}`\"\n        )\n    return self.dict() == other.dict()\n</code></pre>"},{"location":"references/Python%20Client/annotation/#velour.Annotation.dict","title":"<code>velour.Annotation.dict()</code>","text":"<p>Defines how a <code>Annotation</code> object is transformed into a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the <code>Annotation's</code> attributes.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def dict(self) -&gt; dict:\n    \"\"\"\n    Defines how a `Annotation` object is transformed into a dictionary.\n\n    Returns\n    ----------\n    dict\n        A dictionary of the `Annotation's` attributes.\n    \"\"\"\n    return {\n        \"task_type\": self.task_type.value,\n        \"labels\": [label.dict() for label in self.labels],\n        \"metadata\": self.metadata,\n        \"bounding_box\": asdict(self.bounding_box)\n        if self.bounding_box\n        else None,\n        \"polygon\": asdict(self.polygon) if self.polygon else None,\n        \"multipolygon\": asdict(self.multipolygon)\n        if self.multipolygon\n        else None,\n        \"raster\": asdict(self.raster) if self.raster else None,\n        \"jsonb\": self.jsonb,\n    }\n</code></pre>"},{"location":"references/Python%20Client/client/","title":"Client","text":"<p>Client for interacting with the velour backend.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host to connect to. Should start with \"http://\" or \"https://\".</p> required <code>access_token</code> <code>str</code> <p>The access token for the host (if the host requires authentication).</p> <code>None</code> Source code in <code>client/velour/client.py</code> <pre><code>class Client:\n    \"\"\"\n    Client for interacting with the velour backend.\n\n    Parameters\n    ----------\n    host : str\n        The host to connect to. Should start with \"http://\" or \"https://\".\n    access_token : str\n        The access token for the host (if the host requires authentication).\n    \"\"\"\n\n    def __init__(self, host: str, access_token: str = None):\n        if not (host.startswith(\"http://\") or host.startswith(\"https://\")):\n            raise ValueError(\n                f\"host must stat with 'http://' or 'https://' but got {host}\"\n            )\n\n        if not host.endswith(\"/\"):\n            host += \"/\"\n        self.host = host\n        self.access_token = os.getenv(\"VELOUR_ACCESS_TOKEN\", access_token)\n\n        # check the connection by hitting the users endpoint\n        email = self._get_users_email()\n        success_str = f\"Succesfully connected to {self.host}\"\n        success_str += f\" with user {email}.\" if email else \".\"\n        print(success_str)\n\n    def _get_users_email(\n        self,\n    ) -&gt; Union[str, None]:\n        \"\"\"\n        Gets the users e-mail address (in the case when auth is enabled)\n        or returns None in the case of a no-auth backend.\n        \"\"\"\n        resp = self._requests_get_rel_host(\"user\").json()\n        return resp[\"email\"]\n\n    def _requests_wrapper(\n        self, method_name: str, endpoint: str, *args, **kwargs\n    ):\n        \"\"\"\n        Wrapper for handling API requests.\n        \"\"\"\n        assert method_name in [\"get\", \"post\", \"put\", \"delete\"]\n\n        if endpoint[0] == \"/\":\n            raise ValueError(\n                \"`endpoint` should not start with a forward slash.\"\n            )\n\n        url = urljoin(self.host, endpoint)\n        requests_method = getattr(requests, method_name)\n\n        if self.access_token is not None:\n            headers = {\"Authorization\": f\"Bearer {self.access_token}\"}\n        else:\n            headers = None\n        resp = requests_method(url, headers=headers, *args, **kwargs)\n        if not resp.ok:\n            try:\n                raise ClientException(resp.json()[\"detail\"])\n            except (requests.exceptions.JSONDecodeError, KeyError):\n                resp.raise_for_status()\n\n        return resp\n\n    def _requests_post_rel_host(self, endpoint: str, *args, **kwargs):\n        \"\"\"\n        Helper for handling POST requests.\n        \"\"\"\n        return self._requests_wrapper(\n            method_name=\"post\", endpoint=endpoint, *args, **kwargs\n        )\n\n    def _requests_get_rel_host(self, endpoint: str, *args, **kwargs):\n        \"\"\"\n        Helper for handling GET requests.\n        \"\"\"\n        return self._requests_wrapper(\n            method_name=\"get\", endpoint=endpoint, *args, **kwargs\n        )\n\n    def _requests_put_rel_host(self, endpoint: str, *args, **kwargs):\n        \"\"\"\n        Helper for handling PUT requests.\n        \"\"\"\n        return self._requests_wrapper(\n            method_name=\"put\", endpoint=endpoint, *args, **kwargs\n        )\n\n    def _requests_delete_rel_host(self, endpoint: str, *args, **kwargs):\n        \"\"\"\n        Helper for handling DELETE requests.\n        \"\"\"\n        return self._requests_wrapper(\n            method_name=\"delete\", endpoint=endpoint, *args, **kwargs\n        )\n\n    def get_bulk_evaluations(\n        self,\n        models: Union[str, List[str], None] = None,\n        datasets: Union[str, List[str], None] = None,\n    ) -&gt; List[dict]:\n        \"\"\"\n        Returns all metrics associated with user-supplied dataset and/or model names.\n\n        Parameters\n        ----------\n        models : Union[str, List[str], None]\n            A list of model names that we want to return metrics for. If the user passes a string, it will automatically be converted to a list for convenience.\n        datasets : Union[str, List[str], None]\n            A list of dataset names that we want to return metrics for. If the user passes a string, it will automatically be converted to a list for convenience.\n\n        Returns\n        -------\n        List[dict]\n            List of dictionaries describing the returned evaluations.\n\n        \"\"\"\n\n        if not (models or datasets):\n            raise ValueError(\n                \"Please provide atleast one model name or dataset name\"\n            )\n\n        if models:\n            # let users just pass one name as a string\n            if isinstance(models, str):\n                models = [models]\n            model_params = \",\".join(models)\n        else:\n            model_params = None\n\n        if datasets:\n            if isinstance(datasets, str):\n                datasets = [datasets]\n            dataset_params = \",\".join(datasets)\n        else:\n            dataset_params = None\n\n        if model_params and dataset_params:\n            endpoint = (\n                f\"evaluations?models={model_params}&amp;datasets={dataset_params}\"\n            )\n        elif model_params:\n            endpoint = f\"evaluations?models={model_params}\"\n        else:\n            endpoint = f\"evaluations?datasets={dataset_params}\"\n\n        evals = self._requests_get_rel_host(endpoint).json()\n        return evals\n\n    def get_datasets(\n        self,\n    ) -&gt; List[dict]:\n        \"\"\"\n        Get all of the datasets associated with `Client`.\n\n        Returns\n        ------\n        List[dict]\n            A list of dictionaries describing all the datasets attributed to the `Client` object.\n        \"\"\"\n        return self._requests_get_rel_host(\"datasets\").json()\n\n    def get_models(\n        self,\n    ) -&gt; List[dict]:\n        \"\"\"\n        Get all of the models associated with `Client`.\n\n        Returns\n        ------\n        List[dict]\n            A list of dictionaries describing all the models attributed to the `Client` object.\n        \"\"\"\n        return self._requests_get_rel_host(\"models\").json()\n\n    def get_labels(\n        self,\n    ) -&gt; List[Label]:\n        \"\"\"\n        Get all of the labels associated with `Client`.\n\n        Returns\n        ------\n        List[Label]\n            A list of `Label` objects attributed to `Client`.\n        \"\"\"\n        return self._requests_get_rel_host(\"labels\").json()\n\n    def delete_dataset(self, name: str, timeout: int = 0) -&gt; None:\n        \"\"\"\n        Delete a dataset using FastAPI's `BackgroundProcess`.\n\n        Parameters\n        ----------\n        name : str\n            The name of the dataset to be deleted.\n        timeout : int\n            The number of seconds to wait in order to confirm that the dataset was deleted.\n        \"\"\"\n        self._requests_delete_rel_host(f\"datasets/{name}\")\n\n        if timeout:\n            for _ in range(timeout):\n                if self.get_dataset_status(name) == State.NONE:\n                    break\n                else:\n                    time.sleep(1)\n            else:\n                raise TimeoutError(\n                    \"Dataset wasn't deleted within timeout interval\"\n                )\n\n    def delete_model(self, name: str, timeout: int = 0) -&gt; None:\n        \"\"\"\n        Delete a model using FastAPI's `BackgroundProcess`.\n\n        Parameters\n        ----------\n        name : str\n            The name of the model to be deleted.\n        timeout : int\n            The number of seconds to wait in order to confirm that the model was deleted.\n        \"\"\"\n        self._requests_delete_rel_host(f\"models/{name}\")\n\n        if timeout:\n            for _ in range(timeout):\n                if self.get_dataset_status(name) == State.NONE:\n                    break\n                else:\n                    time.sleep(1)\n            else:\n                raise TimeoutError(\n                    \"Model wasn't deleted within timeout interval\"\n                )\n\n    def get_dataset_status(\n        self,\n        dataset_name: str,\n    ) -&gt; State:\n        \"\"\"\n        Get the state of a given dataset.\n\n        Parameters\n        ----------\n        dataset_name : str\n            The name of the dataset we want to fetch the state of.\n\n        Returns\n        ------\n        State\n            The state of the `Dataset`.\n        \"\"\"\n        try:\n            resp = self._requests_get_rel_host(\n                f\"datasets/{dataset_name}/status\"\n            ).json()\n        except Exception:\n            resp = State.NONE\n\n        return resp\n\n    def get_evaluation_status(\n        self,\n        job_id: int,\n    ) -&gt; State:\n        \"\"\"\n        Get the state of a given job ID.\n\n        Parameters\n        ----------\n        job_id : int\n            The job id of the evaluation that we want to fetch the state of.\n\n        Returns\n        ------\n        State\n            The state of the `Evaluation`.\n        \"\"\"\n        return self._requests_get_rel_host(\n            f\"evaluations/{job_id}/status\"\n        ).json()\n</code></pre>"},{"location":"references/Python%20Client/client/#velour.Client-functions","title":"Functions","text":""},{"location":"references/Python%20Client/client/#velour.Client.delete_dataset","title":"<code>velour.Client.delete_dataset(name, timeout=0)</code>","text":"<p>Delete a dataset using FastAPI's <code>BackgroundProcess</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset to be deleted.</p> required <code>timeout</code> <code>int</code> <p>The number of seconds to wait in order to confirm that the dataset was deleted.</p> <code>0</code> Source code in <code>client/velour/client.py</code> <pre><code>def delete_dataset(self, name: str, timeout: int = 0) -&gt; None:\n    \"\"\"\n    Delete a dataset using FastAPI's `BackgroundProcess`.\n\n    Parameters\n    ----------\n    name : str\n        The name of the dataset to be deleted.\n    timeout : int\n        The number of seconds to wait in order to confirm that the dataset was deleted.\n    \"\"\"\n    self._requests_delete_rel_host(f\"datasets/{name}\")\n\n    if timeout:\n        for _ in range(timeout):\n            if self.get_dataset_status(name) == State.NONE:\n                break\n            else:\n                time.sleep(1)\n        else:\n            raise TimeoutError(\n                \"Dataset wasn't deleted within timeout interval\"\n            )\n</code></pre>"},{"location":"references/Python%20Client/client/#velour.Client.delete_model","title":"<code>velour.Client.delete_model(name, timeout=0)</code>","text":"<p>Delete a model using FastAPI's <code>BackgroundProcess</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the model to be deleted.</p> required <code>timeout</code> <code>int</code> <p>The number of seconds to wait in order to confirm that the model was deleted.</p> <code>0</code> Source code in <code>client/velour/client.py</code> <pre><code>def delete_model(self, name: str, timeout: int = 0) -&gt; None:\n    \"\"\"\n    Delete a model using FastAPI's `BackgroundProcess`.\n\n    Parameters\n    ----------\n    name : str\n        The name of the model to be deleted.\n    timeout : int\n        The number of seconds to wait in order to confirm that the model was deleted.\n    \"\"\"\n    self._requests_delete_rel_host(f\"models/{name}\")\n\n    if timeout:\n        for _ in range(timeout):\n            if self.get_dataset_status(name) == State.NONE:\n                break\n            else:\n                time.sleep(1)\n        else:\n            raise TimeoutError(\n                \"Model wasn't deleted within timeout interval\"\n            )\n</code></pre>"},{"location":"references/Python%20Client/client/#velour.Client.get_bulk_evaluations","title":"<code>velour.Client.get_bulk_evaluations(models=None, datasets=None)</code>","text":"<p>Returns all metrics associated with user-supplied dataset and/or model names.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>Union[str, List[str], None]</code> <p>A list of model names that we want to return metrics for. If the user passes a string, it will automatically be converted to a list for convenience.</p> <code>None</code> <code>datasets</code> <code>Union[str, List[str], None]</code> <p>A list of dataset names that we want to return metrics for. If the user passes a string, it will automatically be converted to a list for convenience.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[dict]</code> <p>List of dictionaries describing the returned evaluations.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_bulk_evaluations(\n    self,\n    models: Union[str, List[str], None] = None,\n    datasets: Union[str, List[str], None] = None,\n) -&gt; List[dict]:\n    \"\"\"\n    Returns all metrics associated with user-supplied dataset and/or model names.\n\n    Parameters\n    ----------\n    models : Union[str, List[str], None]\n        A list of model names that we want to return metrics for. If the user passes a string, it will automatically be converted to a list for convenience.\n    datasets : Union[str, List[str], None]\n        A list of dataset names that we want to return metrics for. If the user passes a string, it will automatically be converted to a list for convenience.\n\n    Returns\n    -------\n    List[dict]\n        List of dictionaries describing the returned evaluations.\n\n    \"\"\"\n\n    if not (models or datasets):\n        raise ValueError(\n            \"Please provide atleast one model name or dataset name\"\n        )\n\n    if models:\n        # let users just pass one name as a string\n        if isinstance(models, str):\n            models = [models]\n        model_params = \",\".join(models)\n    else:\n        model_params = None\n\n    if datasets:\n        if isinstance(datasets, str):\n            datasets = [datasets]\n        dataset_params = \",\".join(datasets)\n    else:\n        dataset_params = None\n\n    if model_params and dataset_params:\n        endpoint = (\n            f\"evaluations?models={model_params}&amp;datasets={dataset_params}\"\n        )\n    elif model_params:\n        endpoint = f\"evaluations?models={model_params}\"\n    else:\n        endpoint = f\"evaluations?datasets={dataset_params}\"\n\n    evals = self._requests_get_rel_host(endpoint).json()\n    return evals\n</code></pre>"},{"location":"references/Python%20Client/client/#velour.Client.get_dataset_status","title":"<code>velour.Client.get_dataset_status(dataset_name)</code>","text":"<p>Get the state of a given dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset we want to fetch the state of.</p> required <p>Returns:</p> Type Description <code>State</code> <p>The state of the <code>Dataset</code>.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_dataset_status(\n    self,\n    dataset_name: str,\n) -&gt; State:\n    \"\"\"\n    Get the state of a given dataset.\n\n    Parameters\n    ----------\n    dataset_name : str\n        The name of the dataset we want to fetch the state of.\n\n    Returns\n    ------\n    State\n        The state of the `Dataset`.\n    \"\"\"\n    try:\n        resp = self._requests_get_rel_host(\n            f\"datasets/{dataset_name}/status\"\n        ).json()\n    except Exception:\n        resp = State.NONE\n\n    return resp\n</code></pre>"},{"location":"references/Python%20Client/client/#velour.Client.get_datasets","title":"<code>velour.Client.get_datasets()</code>","text":"<p>Get all of the datasets associated with <code>Client</code>.</p> <p>Returns:</p> Type Description <code>List[dict]</code> <p>A list of dictionaries describing all the datasets attributed to the <code>Client</code> object.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_datasets(\n    self,\n) -&gt; List[dict]:\n    \"\"\"\n    Get all of the datasets associated with `Client`.\n\n    Returns\n    ------\n    List[dict]\n        A list of dictionaries describing all the datasets attributed to the `Client` object.\n    \"\"\"\n    return self._requests_get_rel_host(\"datasets\").json()\n</code></pre>"},{"location":"references/Python%20Client/client/#velour.Client.get_evaluation_status","title":"<code>velour.Client.get_evaluation_status(job_id)</code>","text":"<p>Get the state of a given job ID.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>int</code> <p>The job id of the evaluation that we want to fetch the state of.</p> required <p>Returns:</p> Type Description <code>State</code> <p>The state of the <code>Evaluation</code>.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_evaluation_status(\n    self,\n    job_id: int,\n) -&gt; State:\n    \"\"\"\n    Get the state of a given job ID.\n\n    Parameters\n    ----------\n    job_id : int\n        The job id of the evaluation that we want to fetch the state of.\n\n    Returns\n    ------\n    State\n        The state of the `Evaluation`.\n    \"\"\"\n    return self._requests_get_rel_host(\n        f\"evaluations/{job_id}/status\"\n    ).json()\n</code></pre>"},{"location":"references/Python%20Client/client/#velour.Client.get_labels","title":"<code>velour.Client.get_labels()</code>","text":"<p>Get all of the labels associated with <code>Client</code>.</p> <p>Returns:</p> Type Description <code>List[Label]</code> <p>A list of <code>Label</code> objects attributed to <code>Client</code>.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_labels(\n    self,\n) -&gt; List[Label]:\n    \"\"\"\n    Get all of the labels associated with `Client`.\n\n    Returns\n    ------\n    List[Label]\n        A list of `Label` objects attributed to `Client`.\n    \"\"\"\n    return self._requests_get_rel_host(\"labels\").json()\n</code></pre>"},{"location":"references/Python%20Client/client/#velour.Client.get_models","title":"<code>velour.Client.get_models()</code>","text":"<p>Get all of the models associated with <code>Client</code>.</p> <p>Returns:</p> Type Description <code>List[dict]</code> <p>A list of dictionaries describing all the models attributed to the <code>Client</code> object.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_models(\n    self,\n) -&gt; List[dict]:\n    \"\"\"\n    Get all of the models associated with `Client`.\n\n    Returns\n    ------\n    List[dict]\n        A list of dictionaries describing all the models attributed to the `Client` object.\n    \"\"\"\n    return self._requests_get_rel_host(\"models\").json()\n</code></pre>"},{"location":"references/Python%20Client/dataset/","title":"Dataset","text":"<p>A class describing a given dataset.</p> <p>Attributes:</p> Name Type Description <code>client</code> <code>Client</code> <p>The <code>Client</code> object associated with the session.</p> <code>id</code> <code>int</code> <p>The ID of the dataset.</p> <code>name</code> <code>str</code> <p>The name of the dataset.</p> <code>metadata</code> <code>dict</code> <p>A dictionary of metadata that describes the dataset.</p> <code>geospatial</code> <code>dict</code> <p>A GeoJSON-style dictionary describing the geospatial coordinates of the dataset.</p> Source code in <code>client/velour/client.py</code> <pre><code>class Dataset:\n    \"\"\"\n    A class describing a given dataset.\n\n    Attributes\n    ----------\n    client : Client\n        The `Client` object associated with the session.\n    id : int\n        The ID of the dataset.\n    name : str\n        The name of the dataset.\n    metadata : dict\n        A dictionary of metadata that describes the dataset.\n    geospatial :  dict\n        A GeoJSON-style dictionary describing the geospatial coordinates of the dataset.\n    \"\"\"\n\n    name = DeclarativeMapper(\"dataset_names\", str)\n    metadata = DeclarativeMapper(\"dataset_metadata\", Union[int, float, str])\n    geospatial = DeclarativeMapper(\n        \"dataset_geospatial\",\n        Union[\n            List[List[List[List[Union[float, int]]]]],\n            List[List[List[Union[float, int]]]],\n            List[Union[float, int]],\n            str,\n        ],\n    )\n\n    def __init__(self):\n        self.client: Client = None\n        self.id: int = None\n        self.name: str = None\n        self.metadata: dict = None\n        self.geospatial: dict = None\n\n    @classmethod\n    def create(\n        cls,\n        client: Client,\n        name: str,\n        metadata: Dict[str, Union[int, float, str]] = None,\n        geospatial: Dict[\n            str,\n            Union[\n                List[List[List[List[Union[float, int]]]]],\n                List[List[List[Union[float, int]]]],\n                List[Union[float, int]],\n                str,\n            ],\n        ] = None,\n        id: Union[int, None] = None,\n    ):\n        \"\"\"\n        Create a new `Dataset` object.\n\n        Parameters\n        ----------\n        client : Client\n            The `Client` object associated with the session.\n        name : str\n            The name of the dataset.\n        metadata : dict\n            A dictionary of metadata that describes the dataset.\n        geospatial :  dict\n            A GeoJSON-style dictionary describing the geospatial coordinates of the dataset.\n\n\n        Returns\n        ----------\n        Dataset\n            The newly-created `Dataset`.\n        \"\"\"\n        dataset = cls()\n        dataset.client = client\n        dataset.name = name\n        dataset.metadata = metadata\n        dataset.geospatial = geospatial\n        dataset.id = id\n        dataset._validate()\n        client._requests_post_rel_host(\"datasets\", json=dataset.dict())\n        return cls.get(client, name)\n\n    @classmethod\n    def get(cls, client: Client, name: str):\n        \"\"\"\n        Fetches a given dataset from the backend.\n\n        Parameters\n        ----------\n        client : Client\n            The `Client` object associated with the session.\n        name : str\n            The name of the dataset.\n\n\n        Returns\n        ----------\n        Dataset\n            The requested `Dataset`.\n        \"\"\"\n        resp = client._requests_get_rel_host(f\"datasets/{name}\").json()\n        dataset = cls()\n        dataset.client = client\n        dataset.name = resp[\"name\"]\n        dataset.metadata = resp[\"metadata\"]\n        dataset.geospatial = resp[\"geospatial\"]\n        dataset.id = resp[\"id\"]\n        dataset._validate()\n        return dataset\n\n    def _validate(self):\n        \"\"\"\n        Validates the arguments used to create a `Dataset` object.\n        \"\"\"\n        # validation\n        if not isinstance(self.name, str):\n            raise TypeError(\"`name` should be of type `str`\")\n        if not isinstance(self.id, int) and self.id is not None:\n            raise TypeError(\"`id` should be of type `int`\")\n        if not self.metadata:\n            self.metadata = {}\n        if not self.geospatial:\n            self.geospatial = {}\n        validate_metadata(self.metadata)\n\n    def dict(self) -&gt; dict:\n        \"\"\"\n        Defines how a `Dataset` object is transformed into a dictionary.\n\n        Returns\n        ----------\n        dict\n            A dictionary of the `Dataset's` attributes.\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"metadata\": self.metadata,\n            \"geospatial\": self.geospatial,\n        }\n\n    def add_groundtruth(\n        self,\n        groundtruth: GroundTruth,\n    ):\n        \"\"\"\n        Add a groundtruth to a given dataset.\n\n        Parameters\n        ----------\n        groundtruth : GroundTruth\n            The `GroundTruth` object to add to the `Dataset`.\n        \"\"\"\n        if not isinstance(groundtruth, GroundTruth):\n            raise TypeError(f\"Invalid type `{type(groundtruth)}`\")\n\n        if len(groundtruth.annotations) == 0:\n            warnings.warn(\n                f\"GroundTruth for datum with uid `{groundtruth.datum.uid}` contains no annotations. Skipping...\"\n            )\n            return\n\n        groundtruth.datum.dataset = self.name\n        self.client._requests_post_rel_host(\n            \"groundtruths\",\n            json=groundtruth.dict(),\n        )\n\n    def get_groundtruth(self, uid: str) -&gt; GroundTruth:\n        \"\"\"\n        Fetches a given groundtruth from the backend.\n\n        Parameters\n        ----------\n        uid : str\n            The UID of the 'GroundTruth' to fetch.\n\n\n        Returns\n        ----------\n        GroundTruth\n            The requested `GroundTruth`.\n        \"\"\"\n        resp = self.client._requests_get_rel_host(\n            f\"groundtruths/dataset/{self.name}/datum/{uid}\"\n        ).json()\n        return GroundTruth(**resp)\n\n    def get_labels(\n        self,\n    ) -&gt; List[Label]:\n        \"\"\"\n        Get all labels associated with a given dataset.\n\n        Returns\n        ----------\n        List[Label]\n            A list of `Labels` associated with the dataset.\n        \"\"\"\n        labels = self.client._requests_get_rel_host(\n            f\"labels/dataset/{self.name}\"\n        ).json()\n\n        return [\n            Label(key=label[\"key\"], value=label[\"value\"]) for label in labels\n        ]\n\n    def get_datums(\n        self,\n    ) -&gt; List[Datum]:\n        \"\"\"\n        Get all datums associated with a given dataset.\n\n        Returns\n        ----------\n        List[Datum]\n            A list of `Datums` associated with the dataset.\n        \"\"\"\n        datums = self.client._requests_get_rel_host(\n            f\"data/dataset/{self.name}\"\n        ).json()\n        return [Datum(**datum) for datum in datums]\n\n    def get_images(\n        self,\n    ) -&gt; List[ImageMetadata]:\n        \"\"\"\n        Get all image metadata associated with a given dataset.\n\n        Returns\n        ----------\n        List[ImageMetadata]\n            A list of `ImageMetadata` associated with the dataset.\n        \"\"\"\n        return [\n            ImageMetadata.from_datum(datum)\n            for datum in self.get_datums()\n            if ImageMetadata.valid(datum)\n        ]\n\n    def get_evaluations(\n        self,\n    ) -&gt; List[Evaluation]:\n        \"\"\"\n        Get all evaluations associated with a given dataset.\n\n        Returns\n        ----------\n        List[Evaluation]\n            A list of `Evaluations` associated with the dataset.\n        \"\"\"\n        model_evaluations = self.client._requests_get_rel_host(\n            f\"evaluations/dataset/{self.name}\"\n        ).json()\n        return [\n            Evaluation(\n                client=self.client,\n                dataset=self.name,\n                model=model_name,\n                job_id=job_id,\n            )\n            for model_name in model_evaluations\n            for job_id in model_evaluations[model_name]\n        ]\n\n    def finalize(\n        self,\n    ):\n        \"\"\"\n        Finalize the `Dataset` object such that new `GroundTruths` cannot be added to it.\n        \"\"\"\n        return self.client._requests_put_rel_host(\n            f\"datasets/{self.name}/finalize\"\n        )\n\n    def delete(\n        self,\n    ):\n        \"\"\"\n        Delete the `Dataset` object from the backend.\n        \"\"\"\n        self.client._requests_delete_rel_host(f\"datasets/{self.name}\").json()\n        del self\n</code></pre>"},{"location":"references/Python%20Client/dataset/#velour.Dataset-functions","title":"Functions","text":""},{"location":"references/Python%20Client/dataset/#velour.Dataset.add_groundtruth","title":"<code>velour.Dataset.add_groundtruth(groundtruth)</code>","text":"<p>Add a groundtruth to a given dataset.</p> <p>Parameters:</p> Name Type Description Default <code>groundtruth</code> <code>GroundTruth</code> <p>The <code>GroundTruth</code> object to add to the <code>Dataset</code>.</p> required Source code in <code>client/velour/client.py</code> <pre><code>def add_groundtruth(\n    self,\n    groundtruth: GroundTruth,\n):\n    \"\"\"\n    Add a groundtruth to a given dataset.\n\n    Parameters\n    ----------\n    groundtruth : GroundTruth\n        The `GroundTruth` object to add to the `Dataset`.\n    \"\"\"\n    if not isinstance(groundtruth, GroundTruth):\n        raise TypeError(f\"Invalid type `{type(groundtruth)}`\")\n\n    if len(groundtruth.annotations) == 0:\n        warnings.warn(\n            f\"GroundTruth for datum with uid `{groundtruth.datum.uid}` contains no annotations. Skipping...\"\n        )\n        return\n\n    groundtruth.datum.dataset = self.name\n    self.client._requests_post_rel_host(\n        \"groundtruths\",\n        json=groundtruth.dict(),\n    )\n</code></pre>"},{"location":"references/Python%20Client/dataset/#velour.Dataset.create","title":"<code>velour.Dataset.create(client, name, metadata=None, geospatial=None, id=None)</code>  <code>classmethod</code>","text":"<p>Create a new <code>Dataset</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The <code>Client</code> object associated with the session.</p> required <code>name</code> <code>str</code> <p>The name of the dataset.</p> required <code>metadata</code> <code>dict</code> <p>A dictionary of metadata that describes the dataset.</p> <code>None</code> <code>geospatial</code> <code> dict</code> <p>A GeoJSON-style dictionary describing the geospatial coordinates of the dataset.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>The newly-created <code>Dataset</code>.</p> Source code in <code>client/velour/client.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    client: Client,\n    name: str,\n    metadata: Dict[str, Union[int, float, str]] = None,\n    geospatial: Dict[\n        str,\n        Union[\n            List[List[List[List[Union[float, int]]]]],\n            List[List[List[Union[float, int]]]],\n            List[Union[float, int]],\n            str,\n        ],\n    ] = None,\n    id: Union[int, None] = None,\n):\n    \"\"\"\n    Create a new `Dataset` object.\n\n    Parameters\n    ----------\n    client : Client\n        The `Client` object associated with the session.\n    name : str\n        The name of the dataset.\n    metadata : dict\n        A dictionary of metadata that describes the dataset.\n    geospatial :  dict\n        A GeoJSON-style dictionary describing the geospatial coordinates of the dataset.\n\n\n    Returns\n    ----------\n    Dataset\n        The newly-created `Dataset`.\n    \"\"\"\n    dataset = cls()\n    dataset.client = client\n    dataset.name = name\n    dataset.metadata = metadata\n    dataset.geospatial = geospatial\n    dataset.id = id\n    dataset._validate()\n    client._requests_post_rel_host(\"datasets\", json=dataset.dict())\n    return cls.get(client, name)\n</code></pre>"},{"location":"references/Python%20Client/dataset/#velour.Dataset.delete","title":"<code>velour.Dataset.delete()</code>","text":"<p>Delete the <code>Dataset</code> object from the backend.</p> Source code in <code>client/velour/client.py</code> <pre><code>def delete(\n    self,\n):\n    \"\"\"\n    Delete the `Dataset` object from the backend.\n    \"\"\"\n    self.client._requests_delete_rel_host(f\"datasets/{self.name}\").json()\n    del self\n</code></pre>"},{"location":"references/Python%20Client/dataset/#velour.Dataset.dict","title":"<code>velour.Dataset.dict()</code>","text":"<p>Defines how a <code>Dataset</code> object is transformed into a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the <code>Dataset's</code> attributes.</p> Source code in <code>client/velour/client.py</code> <pre><code>def dict(self) -&gt; dict:\n    \"\"\"\n    Defines how a `Dataset` object is transformed into a dictionary.\n\n    Returns\n    ----------\n    dict\n        A dictionary of the `Dataset's` attributes.\n    \"\"\"\n    return {\n        \"id\": self.id,\n        \"name\": self.name,\n        \"metadata\": self.metadata,\n        \"geospatial\": self.geospatial,\n    }\n</code></pre>"},{"location":"references/Python%20Client/dataset/#velour.Dataset.finalize","title":"<code>velour.Dataset.finalize()</code>","text":"<p>Finalize the <code>Dataset</code> object such that new <code>GroundTruths</code> cannot be added to it.</p> Source code in <code>client/velour/client.py</code> <pre><code>def finalize(\n    self,\n):\n    \"\"\"\n    Finalize the `Dataset` object such that new `GroundTruths` cannot be added to it.\n    \"\"\"\n    return self.client._requests_put_rel_host(\n        f\"datasets/{self.name}/finalize\"\n    )\n</code></pre>"},{"location":"references/Python%20Client/dataset/#velour.Dataset.get","title":"<code>velour.Dataset.get(client, name)</code>  <code>classmethod</code>","text":"<p>Fetches a given dataset from the backend.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The <code>Client</code> object associated with the session.</p> required <code>name</code> <code>str</code> <p>The name of the dataset.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>The requested <code>Dataset</code>.</p> Source code in <code>client/velour/client.py</code> <pre><code>@classmethod\ndef get(cls, client: Client, name: str):\n    \"\"\"\n    Fetches a given dataset from the backend.\n\n    Parameters\n    ----------\n    client : Client\n        The `Client` object associated with the session.\n    name : str\n        The name of the dataset.\n\n\n    Returns\n    ----------\n    Dataset\n        The requested `Dataset`.\n    \"\"\"\n    resp = client._requests_get_rel_host(f\"datasets/{name}\").json()\n    dataset = cls()\n    dataset.client = client\n    dataset.name = resp[\"name\"]\n    dataset.metadata = resp[\"metadata\"]\n    dataset.geospatial = resp[\"geospatial\"]\n    dataset.id = resp[\"id\"]\n    dataset._validate()\n    return dataset\n</code></pre>"},{"location":"references/Python%20Client/dataset/#velour.Dataset.get_datums","title":"<code>velour.Dataset.get_datums()</code>","text":"<p>Get all datums associated with a given dataset.</p> <p>Returns:</p> Type Description <code>List[Datum]</code> <p>A list of <code>Datums</code> associated with the dataset.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_datums(\n    self,\n) -&gt; List[Datum]:\n    \"\"\"\n    Get all datums associated with a given dataset.\n\n    Returns\n    ----------\n    List[Datum]\n        A list of `Datums` associated with the dataset.\n    \"\"\"\n    datums = self.client._requests_get_rel_host(\n        f\"data/dataset/{self.name}\"\n    ).json()\n    return [Datum(**datum) for datum in datums]\n</code></pre>"},{"location":"references/Python%20Client/dataset/#velour.Dataset.get_evaluations","title":"<code>velour.Dataset.get_evaluations()</code>","text":"<p>Get all evaluations associated with a given dataset.</p> <p>Returns:</p> Type Description <code>List[Evaluation]</code> <p>A list of <code>Evaluations</code> associated with the dataset.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_evaluations(\n    self,\n) -&gt; List[Evaluation]:\n    \"\"\"\n    Get all evaluations associated with a given dataset.\n\n    Returns\n    ----------\n    List[Evaluation]\n        A list of `Evaluations` associated with the dataset.\n    \"\"\"\n    model_evaluations = self.client._requests_get_rel_host(\n        f\"evaluations/dataset/{self.name}\"\n    ).json()\n    return [\n        Evaluation(\n            client=self.client,\n            dataset=self.name,\n            model=model_name,\n            job_id=job_id,\n        )\n        for model_name in model_evaluations\n        for job_id in model_evaluations[model_name]\n    ]\n</code></pre>"},{"location":"references/Python%20Client/dataset/#velour.Dataset.get_groundtruth","title":"<code>velour.Dataset.get_groundtruth(uid)</code>","text":"<p>Fetches a given groundtruth from the backend.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The UID of the 'GroundTruth' to fetch.</p> required <p>Returns:</p> Type Description <code>GroundTruth</code> <p>The requested <code>GroundTruth</code>.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_groundtruth(self, uid: str) -&gt; GroundTruth:\n    \"\"\"\n    Fetches a given groundtruth from the backend.\n\n    Parameters\n    ----------\n    uid : str\n        The UID of the 'GroundTruth' to fetch.\n\n\n    Returns\n    ----------\n    GroundTruth\n        The requested `GroundTruth`.\n    \"\"\"\n    resp = self.client._requests_get_rel_host(\n        f\"groundtruths/dataset/{self.name}/datum/{uid}\"\n    ).json()\n    return GroundTruth(**resp)\n</code></pre>"},{"location":"references/Python%20Client/dataset/#velour.Dataset.get_images","title":"<code>velour.Dataset.get_images()</code>","text":"<p>Get all image metadata associated with a given dataset.</p> <p>Returns:</p> Type Description <code>List[ImageMetadata]</code> <p>A list of <code>ImageMetadata</code> associated with the dataset.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_images(\n    self,\n) -&gt; List[ImageMetadata]:\n    \"\"\"\n    Get all image metadata associated with a given dataset.\n\n    Returns\n    ----------\n    List[ImageMetadata]\n        A list of `ImageMetadata` associated with the dataset.\n    \"\"\"\n    return [\n        ImageMetadata.from_datum(datum)\n        for datum in self.get_datums()\n        if ImageMetadata.valid(datum)\n    ]\n</code></pre>"},{"location":"references/Python%20Client/dataset/#velour.Dataset.get_labels","title":"<code>velour.Dataset.get_labels()</code>","text":"<p>Get all labels associated with a given dataset.</p> <p>Returns:</p> Type Description <code>List[Label]</code> <p>A list of <code>Labels</code> associated with the dataset.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_labels(\n    self,\n) -&gt; List[Label]:\n    \"\"\"\n    Get all labels associated with a given dataset.\n\n    Returns\n    ----------\n    List[Label]\n        A list of `Labels` associated with the dataset.\n    \"\"\"\n    labels = self.client._requests_get_rel_host(\n        f\"labels/dataset/{self.name}\"\n    ).json()\n\n    return [\n        Label(key=label[\"key\"], value=label[\"value\"]) for label in labels\n    ]\n</code></pre>"},{"location":"references/Python%20Client/datum/","title":"Datum","text":"<p>A class used to store datum about <code>GroundTruths</code> and <code>Predictions</code>.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The UID of the <code>Datum</code>.</p> required <code>metadata</code> <code>dict</code> <p>A dictionary of metadata that describes the <code>Datum</code>.</p> <code>None</code> <code>geospatial</code> <code> dict</code> <p>A GeoJSON-style dictionary describing the geospatial coordinates of the <code>Datum</code>.</p> <code>None</code> <code>dataset</code> <code>str</code> <p>The name of the dataset to associate the <code>Datum</code> with.</p> <code>''</code> Source code in <code>client/velour/coretypes.py</code> <pre><code>class Datum:\n    \"\"\"\n    A class used to store datum about `GroundTruths` and `Predictions`.\n\n    Parameters\n    ----------\n    uid : str\n        The UID of the `Datum`.\n    metadata : dict\n        A dictionary of metadata that describes the `Datum`.\n    geospatial :  dict\n        A GeoJSON-style dictionary describing the geospatial coordinates of the `Datum`.\n    dataset : str\n        The name of the dataset to associate the `Datum` with.\n    \"\"\"\n\n    uid = DeclarativeMapper(\"datum_uids\", str)\n    metadata = DeclarativeMapper(\"datum_metadata\", Union[int, float, str])\n    geospatial = DeclarativeMapper(\n        \"datum_geospatial\",\n        Union[\n            List[List[List[List[Union[float, int]]]]],\n            List[List[List[Union[float, int]]]],\n            List[Union[float, int]],\n            str,\n        ],\n    )\n\n    def __init__(\n        self,\n        uid: str,\n        metadata: Dict[str, Union[int, float, str]] = None,\n        geospatial: Dict[\n            str,\n            Union[\n                List[List[List[List[Union[float, int]]]]],\n                List[List[List[Union[float, int]]]],\n                List[Union[float, int]],\n                str,\n            ],\n        ] = None,\n        dataset: str = \"\",\n    ):\n        self.uid = uid\n        self.metadata = metadata if metadata else {}\n        self.geospatial = geospatial if geospatial else {}\n        self.dataset = dataset\n        self._validate()\n\n    def _validate(self):\n        \"\"\"\n        Validates the parameters used to create a `Datum` object.\n        \"\"\"\n        if not isinstance(self.dataset, str):\n            raise SchemaTypeError(\"dataset\", str, self.dataset)\n        if not isinstance(self.uid, str):\n            raise SchemaTypeError(\"uid\", str, self.uid)\n        validate_metadata(self.metadata)\n\n    def dict(self) -&gt; dict:\n        \"\"\"\n        Defines how a `Datum` object is transformed into a dictionary.\n\n        Returns\n        ----------\n        dict\n            A dictionary of the `Datum's` attributes.\n        \"\"\"\n        return {\n            \"dataset\": self.dataset,\n            \"uid\": self.uid,\n            \"metadata\": self.metadata,\n            \"geospatial\": self.geospatial,\n        }\n\n    def __eq__(self, other):\n        \"\"\"\n        Defines how `Datums` are compared to one another\n\n        Parameters\n        ----------\n        other : Datum\n            The object to compare with the `Datum`.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n        \"\"\"\n        if not isinstance(other, Datum):\n            raise TypeError(f\"Expected type `{type(Datum)}`, got `{other}`\")\n        return self.dict() == other.dict()\n</code></pre>"},{"location":"references/Python%20Client/datum/#velour.Datum-functions","title":"Functions","text":""},{"location":"references/Python%20Client/datum/#velour.Datum.__eq__","title":"<code>velour.Datum.__eq__(other)</code>","text":"<p>Defines how <code>Datums</code> are compared to one another</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Datum</code> <p>The object to compare with the <code>Datum</code>.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Defines how `Datums` are compared to one another\n\n    Parameters\n    ----------\n    other : Datum\n        The object to compare with the `Datum`.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n    \"\"\"\n    if not isinstance(other, Datum):\n        raise TypeError(f\"Expected type `{type(Datum)}`, got `{other}`\")\n    return self.dict() == other.dict()\n</code></pre>"},{"location":"references/Python%20Client/datum/#velour.Datum.dict","title":"<code>velour.Datum.dict()</code>","text":"<p>Defines how a <code>Datum</code> object is transformed into a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the <code>Datum's</code> attributes.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def dict(self) -&gt; dict:\n    \"\"\"\n    Defines how a `Datum` object is transformed into a dictionary.\n\n    Returns\n    ----------\n    dict\n        A dictionary of the `Datum's` attributes.\n    \"\"\"\n    return {\n        \"dataset\": self.dataset,\n        \"uid\": self.uid,\n        \"metadata\": self.metadata,\n        \"geospatial\": self.geospatial,\n    }\n</code></pre>"},{"location":"references/Python%20Client/evaluation/","title":"Evaluation","text":"<p>An object for storing the returned results of a model evaluation (where groundtruths are compared with predictions to measure performance).</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The <code>Client</code> object associated with the session.</p> required <code>job_id</code> <code>int</code> <p>The ID of the evaluation job.</p> required <code>dataset</code> <code>str</code> <p>The name of the dataset.</p> required <code>model</code> <code>str</code> <p>The name of the model.</p> required Source code in <code>client/velour/client.py</code> <pre><code>class Evaluation:\n    \"\"\"\n    An object for storing the returned results of a model evaluation (where groundtruths are compared with predictions to measure performance).\n\n    Parameters\n    ----------\n    client : Client\n        The `Client` object associated with the session.\n    job_id : int\n        The ID of the evaluation job.\n    dataset : str\n        The name of the dataset.\n    model : str\n        The name of the model.\n    \"\"\"\n\n    def __init__(\n        self,\n        client: Client,\n        job_id: int,\n        dataset: str,\n        model: str,\n        **kwargs,\n    ):\n        self._id: int = job_id\n        self._client: Client = client\n        self.dataset = dataset\n        self.model = model\n\n        settings = self._client._requests_get_rel_host(\n            f\"evaluations/{self._id}/settings\"\n        ).json()\n        self._settings = schemas.EvaluationJob(**settings)\n\n        for k, v in kwargs.items():\n            setattr(self, k, v)\n\n    @property\n    def id(\n        self,\n    ) -&gt; int:\n        \"\"\"\n        The ID of the evaluation job.\n\n        Returns\n        ----------\n        int:\n            The evaluation id.\n        \"\"\"\n        return self._id\n\n    @property\n    def settings(\n        self,\n    ) -&gt; schemas.EvaluationJob:\n        \"\"\"\n        The settings associated with the evaluation job.\n\n        Returns\n        ----------\n        schemas.EvaluationJob\n            An `EvaluationJob` object describing the evaluation's configuration.\n        \"\"\"\n        return self._settings\n\n    @property\n    def status(\n        self,\n    ) -&gt; str:\n        \"\"\"\n        The status of the evaluation job.\n\n        Returns\n        ----------\n        str\n            A status (e.g., \"done\").\n        \"\"\"\n        resp = self._client._requests_get_rel_host(\n            f\"evaluations/{self._id}/status\"\n        ).json()\n        return JobStatus(resp)\n\n    @property\n    def task_type(\n        self,\n    ) -&gt; enums.TaskType:\n        \"\"\"\n        The task type of the evaluation job.\n\n        Returns\n        ----------\n        enums.TaskType\n            The task type associated with the `Evaluation` object.\n        \"\"\"\n        return self._settings.task_type\n\n    @property\n    def results(\n        self,\n    ) -&gt; schemas.EvaluationResult:\n        \"\"\"\n        The results of the evaluation job.\n\n        Returns\n        ----------\n        schemas.EvaluationResult\n            The results from the evaluation.\n        \"\"\"\n        result = self._client._requests_get_rel_host(\n            f\"evaluations/{self._id}\"\n        ).json()\n        return schemas.EvaluationResult(**result)\n\n    def wait_for_completion(\n        self, *, interval: float = 1.0, timeout: int = None\n    ):\n        \"\"\"\n        Runs timeout logic to check when an evaluation is completed.\n\n        Parameters\n        ----------\n        interval : float\n            The number of seconds to waits between retries.\n        timeout : int\n            The total number of seconds to wait for the job to finish.\n\n\n        Raises\n        ----------\n        TimeoutError\n            If the job's status doesn't change to DONE or FAILED before the timeout expires\n        \"\"\"\n        if timeout:\n            timeout_counter = int(math.ceil(timeout / interval))\n        while self.status not in [JobStatus.DONE, JobStatus.FAILED]:\n            time.sleep(interval)\n            if timeout:\n                timeout_counter -= 1\n                if timeout_counter &lt; 0:\n                    raise TimeoutError\n</code></pre>"},{"location":"references/Python%20Client/evaluation/#velour.Evaluation-attributes","title":"Attributes","text":""},{"location":"references/Python%20Client/evaluation/#velour.Evaluation.id","title":"<code>velour.Evaluation.id: int</code>  <code>property</code>","text":"<p>The ID of the evaluation job.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The evaluation id.</p>"},{"location":"references/Python%20Client/evaluation/#velour.Evaluation.results","title":"<code>velour.Evaluation.results: schemas.EvaluationResult</code>  <code>property</code>","text":"<p>The results of the evaluation job.</p> <p>Returns:</p> Type Description <code>EvaluationResult</code> <p>The results from the evaluation.</p>"},{"location":"references/Python%20Client/evaluation/#velour.Evaluation.settings","title":"<code>velour.Evaluation.settings: schemas.EvaluationJob</code>  <code>property</code>","text":"<p>The settings associated with the evaluation job.</p> <p>Returns:</p> Type Description <code>EvaluationJob</code> <p>An <code>EvaluationJob</code> object describing the evaluation's configuration.</p>"},{"location":"references/Python%20Client/evaluation/#velour.Evaluation.status","title":"<code>velour.Evaluation.status: str</code>  <code>property</code>","text":"<p>The status of the evaluation job.</p> <p>Returns:</p> Type Description <code>str</code> <p>A status (e.g., \"done\").</p>"},{"location":"references/Python%20Client/evaluation/#velour.Evaluation.task_type","title":"<code>velour.Evaluation.task_type: enums.TaskType</code>  <code>property</code>","text":"<p>The task type of the evaluation job.</p> <p>Returns:</p> Type Description <code>TaskType</code> <p>The task type associated with the <code>Evaluation</code> object.</p>"},{"location":"references/Python%20Client/evaluation/#velour.Evaluation-functions","title":"Functions","text":""},{"location":"references/Python%20Client/evaluation/#velour.Evaluation.wait_for_completion","title":"<code>velour.Evaluation.wait_for_completion(*, interval=1.0, timeout=None)</code>","text":"<p>Runs timeout logic to check when an evaluation is completed.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float</code> <p>The number of seconds to waits between retries.</p> <code>1.0</code> <code>timeout</code> <code>int</code> <p>The total number of seconds to wait for the job to finish.</p> <code>None</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the job's status doesn't change to DONE or FAILED before the timeout expires</p> Source code in <code>client/velour/client.py</code> <pre><code>def wait_for_completion(\n    self, *, interval: float = 1.0, timeout: int = None\n):\n    \"\"\"\n    Runs timeout logic to check when an evaluation is completed.\n\n    Parameters\n    ----------\n    interval : float\n        The number of seconds to waits between retries.\n    timeout : int\n        The total number of seconds to wait for the job to finish.\n\n\n    Raises\n    ----------\n    TimeoutError\n        If the job's status doesn't change to DONE or FAILED before the timeout expires\n    \"\"\"\n    if timeout:\n        timeout_counter = int(math.ceil(timeout / interval))\n    while self.status not in [JobStatus.DONE, JobStatus.FAILED]:\n        time.sleep(interval)\n        if timeout:\n            timeout_counter -= 1\n            if timeout_counter &lt; 0:\n                raise TimeoutError\n</code></pre>"},{"location":"references/Python%20Client/groundtruth/","title":"Groundtruth","text":"<p>An object describing a groundtruth (e.g., a human-drawn bounding box on an image).</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>Datum</code> <p>The <code>Datum</code> associated with the <code>GroundTruth</code>.</p> required <code>annotations</code> <code>List[Annotation]</code> <p>The list of <code>Annotations</code> associated with the <code>GroundTruth</code>.</p> required Source code in <code>client/velour/coretypes.py</code> <pre><code>class GroundTruth:\n    \"\"\"\n    An object describing a groundtruth (e.g., a human-drawn bounding box on an image).\n\n    Parameters\n    ----------\n    datum : Datum\n        The `Datum` associated with the `GroundTruth`.\n    annotations : List[Annotation]\n        The list of `Annotations` associated with the `GroundTruth`.\n    \"\"\"\n\n    def __init__(\n        self,\n        datum: Datum,\n        annotations: List[Annotation],\n    ):\n        self.datum = datum\n        self.annotations = annotations\n        self._validate()\n\n    def _validate(self):\n        \"\"\"\n        Validate the inputs of the `GroundTruth`.\n        \"\"\"\n        # validate datum\n        if isinstance(self.datum, dict):\n            self.datum = Datum(**self.datum)\n        if not isinstance(self.datum, Datum):\n            raise SchemaTypeError(\"datum\", Datum, self.datum)\n\n        # validate annotations\n        if not isinstance(self.annotations, list):\n            raise SchemaTypeError(\n                \"annotations\", List[Annotation], self.annotations\n            )\n        for idx, annotation in enumerate(self.annotations):\n            if isinstance(self.annotations[idx], dict):\n                self.annotations[idx] = Annotation(**annotation)\n            if not isinstance(self.annotations[idx], Annotation):\n                raise SchemaTypeError(\n                    \"annotation\", Annotation, self.annotations[idx]\n                )\n\n    def dict(self) -&gt; dict:\n        \"\"\"\n        Defines how a `GroundTruth` is transformed into a dictionary.\n\n        Returns\n        ----------\n        dict\n            A dictionary of the `GroundTruth's` attributes.\n        \"\"\"\n        return {\n            \"datum\": self.datum.dict(),\n            \"annotations\": [\n                annotation.dict() for annotation in self.annotations\n            ],\n        }\n\n    def __eq__(self, other):\n        \"\"\"\n        Defines how `GroundTruths` are compared to one another\n\n        Parameters\n        ----------\n        other : GroundTruth\n            The object to compare with the `GroundTruth`.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n        \"\"\"\n        if not isinstance(other, GroundTruth):\n            raise TypeError(\n                f\"Expected type `{type(GroundTruth)}`, got `{other}`\"\n            )\n        return self.dict() == other.dict()\n</code></pre>"},{"location":"references/Python%20Client/groundtruth/#velour.GroundTruth-functions","title":"Functions","text":""},{"location":"references/Python%20Client/groundtruth/#velour.GroundTruth.__eq__","title":"<code>velour.GroundTruth.__eq__(other)</code>","text":"<p>Defines how <code>GroundTruths</code> are compared to one another</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>GroundTruth</code> <p>The object to compare with the <code>GroundTruth</code>.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Defines how `GroundTruths` are compared to one another\n\n    Parameters\n    ----------\n    other : GroundTruth\n        The object to compare with the `GroundTruth`.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n    \"\"\"\n    if not isinstance(other, GroundTruth):\n        raise TypeError(\n            f\"Expected type `{type(GroundTruth)}`, got `{other}`\"\n        )\n    return self.dict() == other.dict()\n</code></pre>"},{"location":"references/Python%20Client/groundtruth/#velour.GroundTruth.dict","title":"<code>velour.GroundTruth.dict()</code>","text":"<p>Defines how a <code>GroundTruth</code> is transformed into a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the <code>GroundTruth's</code> attributes.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def dict(self) -&gt; dict:\n    \"\"\"\n    Defines how a `GroundTruth` is transformed into a dictionary.\n\n    Returns\n    ----------\n    dict\n        A dictionary of the `GroundTruth's` attributes.\n    \"\"\"\n    return {\n        \"datum\": self.datum.dict(),\n        \"annotations\": [\n            annotation.dict() for annotation in self.annotations\n        ],\n    }\n</code></pre>"},{"location":"references/Python%20Client/label/","title":"Label","text":"<p>An object for labeling datasets, models, and annotations.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>A key for the <code>Label</code>.</p> required <code>value</code> <code>str</code> <p>A value for the <code>Label</code>.</p> required <code>score</code> <code>float</code> <p>The score associated with the <code>Label</code> (where applicable).</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>A unique ID for the <code>Label</code>.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>class Label:\n    \"\"\"\n    An object for labeling datasets, models, and annotations.\n\n    Parameters\n    ----------\n    key : str\n        A key for the `Label`.\n    value : str\n        A value for the `Label`.\n    score : float\n        The score associated with the `Label` (where applicable).\n\n    Attributes\n    ----------\n    id : int\n        A unique ID for the `Label`.\n    \"\"\"\n\n    id = DeclarativeMapper(\"label_ids\", int)\n    key = DeclarativeMapper(\"label_keys\", str)\n    label = DeclarativeMapper(\"labels\", str)\n\n    def __init__(self, key: str, value: str, score: Union[float, None] = None):\n        self.key = key\n        self.value = value\n        self.score = score\n        self._validate()\n\n    def _validate(self):\n        \"\"\"\n        Validate the inputs of the `Label`.\n        \"\"\"\n        if not isinstance(self.key, str):\n            raise TypeError(\"key should be of type `str`\")\n        if not isinstance(self.value, str):\n            raise TypeError(\"value should be of type `str`\")\n        if isinstance(self.score, int):\n            self.score = float(self.score)\n        if not isinstance(self.score, (float, type(None))):\n            raise TypeError(\"score should be of type `float`\")\n\n    def tuple(self) -&gt; Tuple[str, str, Union[float, None]]:\n        \"\"\"\n        Defines how the `Label` is turned into a tuple.\n\n        Returns\n        ----------\n        tuple\n            A tuple of the `Label's` arguments.\n        \"\"\"\n        return (self.key, self.value, self.score)\n\n    def __eq__(self, other):\n        \"\"\"\n        Defines how `Labels` are compared to one another\n\n        Parameters\n        ----------\n        other : Label\n            The object to compare with the `Label`.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n        \"\"\"\n        if (\n            not hasattr(other, \"key\")\n            or not hasattr(other, \"key\")\n            or not hasattr(other, \"score\")\n        ):\n            return False\n\n        # if the scores aren't the same type return False\n        if (other.score is None) != (self.score is None):\n            return False\n\n        scores_equal = (other.score is None and self.score is None) or (\n            math.isclose(self.score, other.score)\n        )\n\n        return (\n            scores_equal\n            and self.key == other.key\n            and self.value == other.value\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Defines how a `Label` is hashed.\n\n        Returns\n        ----------\n        int\n            The hashed 'Label`.\n        \"\"\"\n        return hash(f\"key:{self.key},value:{self.value},score:{self.score}\")\n\n    def dict(self) -&gt; dict:\n        \"\"\"\n        Defines how a `Label` is transformed into a dictionary.\n\n        Returns\n        ----------\n        dict\n            A dictionary of the `Label's` attributes.\n        \"\"\"\n        return {\n            \"key\": self.key,\n            \"value\": self.value,\n            \"score\": self.score,\n        }\n</code></pre>"},{"location":"references/Python%20Client/label/#velour.Label-functions","title":"Functions","text":""},{"location":"references/Python%20Client/label/#velour.Label.__eq__","title":"<code>velour.Label.__eq__(other)</code>","text":"<p>Defines how <code>Labels</code> are compared to one another</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Label</code> <p>The object to compare with the <code>Label</code>.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Defines how `Labels` are compared to one another\n\n    Parameters\n    ----------\n    other : Label\n        The object to compare with the `Label`.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n    \"\"\"\n    if (\n        not hasattr(other, \"key\")\n        or not hasattr(other, \"key\")\n        or not hasattr(other, \"score\")\n    ):\n        return False\n\n    # if the scores aren't the same type return False\n    if (other.score is None) != (self.score is None):\n        return False\n\n    scores_equal = (other.score is None and self.score is None) or (\n        math.isclose(self.score, other.score)\n    )\n\n    return (\n        scores_equal\n        and self.key == other.key\n        and self.value == other.value\n    )\n</code></pre>"},{"location":"references/Python%20Client/label/#velour.Label.__hash__","title":"<code>velour.Label.__hash__()</code>","text":"<p>Defines how a <code>Label</code> is hashed.</p> <p>Returns:</p> Type Description <code>int</code> <p>The hashed 'Label`.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Defines how a `Label` is hashed.\n\n    Returns\n    ----------\n    int\n        The hashed 'Label`.\n    \"\"\"\n    return hash(f\"key:{self.key},value:{self.value},score:{self.score}\")\n</code></pre>"},{"location":"references/Python%20Client/label/#velour.Label.dict","title":"<code>velour.Label.dict()</code>","text":"<p>Defines how a <code>Label</code> is transformed into a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the <code>Label's</code> attributes.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def dict(self) -&gt; dict:\n    \"\"\"\n    Defines how a `Label` is transformed into a dictionary.\n\n    Returns\n    ----------\n    dict\n        A dictionary of the `Label's` attributes.\n    \"\"\"\n    return {\n        \"key\": self.key,\n        \"value\": self.value,\n        \"score\": self.score,\n    }\n</code></pre>"},{"location":"references/Python%20Client/label/#velour.Label.tuple","title":"<code>velour.Label.tuple()</code>","text":"<p>Defines how the <code>Label</code> is turned into a tuple.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of the <code>Label's</code> arguments.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def tuple(self) -&gt; Tuple[str, str, Union[float, None]]:\n    \"\"\"\n    Defines how the `Label` is turned into a tuple.\n\n    Returns\n    ----------\n    tuple\n        A tuple of the `Label's` arguments.\n    \"\"\"\n    return (self.key, self.value, self.score)\n</code></pre>"},{"location":"references/Python%20Client/model/","title":"Model","text":"<p>A class describing a model that was trained on a particular dataset.</p> <p>Attributes:</p> Name Type Description <code>client</code> <code>Client</code> <p>The <code>Client</code> object associated with the session.</p> <code>id</code> <code>int</code> <p>The ID of the model.</p> <code>name</code> <code>str</code> <p>The name of the model.</p> <code>metadata</code> <code>dict</code> <p>A dictionary of metadata that describes the model.</p> <code>geospatial</code> <code>dict</code> <p>A GeoJSON-style dictionary describing the geospatial coordinates of the model.</p> Source code in <code>client/velour/client.py</code> <pre><code>class Model:\n    \"\"\"\n    A class describing a model that was trained on a particular dataset.\n\n    Attributes\n    ----------\n    client : Client\n        The `Client` object associated with the session.\n    id : int\n        The ID of the model.\n    name : str\n        The name of the model.\n    metadata : dict\n        A dictionary of metadata that describes the model.\n    geospatial :  dict\n        A GeoJSON-style dictionary describing the geospatial coordinates of the model.\n    \"\"\"\n\n    name = DeclarativeMapper(\"models_names\", str)\n    metadata = DeclarativeMapper(\"models_metadata\", Union[int, float, str])\n    geospatial = DeclarativeMapper(\n        \"model_geospatial\",\n        Union[\n            List[List[List[List[Union[float, int]]]]],\n            List[List[List[Union[float, int]]]],\n            List[Union[float, int]],\n            str,\n        ],\n    )\n\n    def __init__(self):\n        self.client: Client = None\n        self.id: int = None\n        self.name: str = \"\"\n        self.metadata: dict = None\n        self.geospatial: dict = None\n\n    @classmethod\n    def create(\n        cls,\n        client: Client,\n        name: str,\n        metadata: Dict[str, Union[int, float, str]] = None,\n        geospatial: Dict[\n            str,\n            Union[\n                List[List[List[List[Union[float, int]]]]],\n                List[List[List[Union[float, int]]]],\n                List[Union[float, int]],\n                str,\n            ],\n        ] = None,\n        id: Union[int, None] = None,\n    ):\n        \"\"\"\n        Create a new Model\n\n        Attributes\n        ----------\n        client : Client\n            The `Client` object associated with the session.\n        name : str\n            The name of the model.\n        metadata : dict\n            A dictionary of metadata that describes the model.\n        geospatial :  dict\n            A GeoJSON-style dictionary describing the geospatial coordinates of the model.\n        id : int\n            The ID of the model.\n\n\n        Returns\n        ----------\n        Model\n            The newly-created `Model` object.\n        \"\"\"\n        model = cls()\n        model.client = client\n        model.name = name\n        model.metadata = metadata\n        model.geospatial = geospatial\n        model.id = id\n        model._validate()\n        client._requests_post_rel_host(\"models\", json=model.dict())\n        return cls.get(client, name)\n\n    @classmethod\n    def get(cls, client: Client, name: str):\n        \"\"\"\n        Fetches a given model from the backend.\n\n        Parameters\n        ----------\n        client : Client\n            The `Client` object associated with the session.\n        name : str\n            The name of the model.\n\n\n        Returns\n        ----------\n        Model\n            The requested `Model`.\n        \"\"\"\n        resp = client._requests_get_rel_host(f\"models/{name}\").json()\n        model = cls()\n        model.client = client\n        model.name = resp[\"name\"]\n        model.metadata = resp[\"metadata\"]\n        model.geospatial = resp[\"geospatial\"]\n        model.id = resp[\"id\"]\n        model._validate()\n        return model\n\n    def _validate(self):\n        \"\"\"\n        Validates the arguments used to create a `Model` object.\n        \"\"\"\n        if not isinstance(self.name, str):\n            raise TypeError(\"`name` should be of type `str`\")\n        if not isinstance(self.id, int) and self.id is not None:\n            raise TypeError(\"`id` should be of type `int`\")\n        if not self.metadata:\n            self.metadata = {}\n        if not self.geospatial:\n            self.geospatial = {}\n        validate_metadata(self.metadata)\n\n    def dict(self) -&gt; dict:\n        \"\"\"\n        Defines how a `Model` object is transformed into a dictionary.\n\n        Returns\n        ----------\n        dict\n            A dictionary of the `Model's` attributes.\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"metadata\": self.metadata,\n            \"geospatial\": self.geospatial,\n        }\n\n    def add_prediction(self, prediction: Prediction):\n        \"\"\"\n        Add a prediction to a given model.\n\n        Parameters\n        ----------\n        prediction : Prediction\n            The `Prediction` object to add to the `Model`.\n        \"\"\"\n        if not isinstance(prediction, Prediction):\n            raise TypeError(\n                f\"Expected `velour.Prediction`, got `{type(prediction)}`\"\n            )\n\n        if len(prediction.annotations) == 0:\n            warnings.warn(\n                f\"Prediction for datum with uid `{prediction.datum.uid}` contains no annotations. Skipping...\"\n            )\n            return\n\n        prediction.model = self.name\n        return self.client._requests_post_rel_host(\n            \"predictions\",\n            json=prediction.dict(),\n        )\n\n    def finalize_inferences(self, dataset: \"Dataset\") -&gt; None:\n        \"\"\"\n        Finalize the `Model` object such that new `Predictions` cannot be added to it.\n        \"\"\"\n        return self.client._requests_put_rel_host(\n            f\"models/{self.name}/datasets/{dataset.name}/finalize\"\n        ).json()\n\n    def evaluate_classification(\n        self,\n        dataset: Dataset,\n        filters: Union[Dict, List[BinaryExpression]] = None,\n        timeout: Optional[int] = None,\n    ) -&gt; Evaluation:\n        \"\"\"\n        Start a classification evaluation job.\n\n        Parameters\n        ----------\n        dataset : Dataset\n            The dataset to evaluate against.\n        filters : Union[Dict, List[BinaryExpression]]\n            Optional set of filters to constrain evaluation by.\n        timeout : int\n            The number of seconds to wait for the job to finish. Used to ensure deterministic behavior when testing.\n\n        Returns\n        -------\n        Evaluation\n            A job object that can be used to track the status of the job and get the metrics of it upon completion.\n        \"\"\"\n\n        # If list[BinaryExpression], convert to filter object\n        if not isinstance(filters, dict) and filters is not None:\n            filters = Filter.create(filters)\n\n        evaluation = schemas.EvaluationJob(\n            model=self.name,\n            dataset=dataset.name,\n            task_type=enums.TaskType.CLASSIFICATION.value,\n            settings=schemas.EvaluationSettings(\n                filters=filters,\n            ),\n        )\n\n        resp = self.client._requests_post_rel_host(\n            \"evaluations\", json=asdict(evaluation)\n        ).json()\n\n        evaluation_job = Evaluation(\n            client=self.client,\n            dataset=dataset.name,\n            model=self.name,\n            **resp,\n        )\n\n        # blocking behavior\n        if timeout:\n            evaluation_job.wait_for_completion(interval=1.0, timeout=timeout)\n\n        return evaluation_job\n\n    def evaluate_detection(\n        self,\n        dataset: \"Dataset\",\n        iou_thresholds_to_compute: List[float] = None,\n        iou_thresholds_to_keep: List[float] = None,\n        filters: Union[Dict, List[BinaryExpression]] = None,\n        timeout: Optional[int] = None,\n    ) -&gt; Evaluation:\n        \"\"\"\n        Start a object-detection evaluation job.\n\n        Parameters\n        ----------\n        dataset : Dataset\n            The dataset to evaluate against.\n        iou_thresholds_to_compute : List[float]\n            Thresholds to compute mAP against.\n        iou_thresholds_to_keep : List[float]\n            Thresholds to return AP for. Must be subset of `iou_thresholds_to_compute`.\n        filters : Union[Dict, List[BinaryExpression]]\n            Optional set of filters to constrain evaluation by.\n        timeout : int\n            The number of seconds to wait for the job to finish. Used to ensure deterministic behavior when testing.\n\n        Returns\n        -------\n        Evaluation\n            A job object that can be used to track the status of the job and get the metrics of it upon completion.\n        \"\"\"\n\n        # Default iou thresholds\n        if iou_thresholds_to_compute is None:\n            iou_thresholds_to_compute = [\n                round(0.5 + 0.05 * i, 2) for i in range(10)\n            ]\n        if iou_thresholds_to_keep is None:\n            iou_thresholds_to_keep = [0.5, 0.75]\n\n        parameters = schemas.DetectionParameters(\n            iou_thresholds_to_compute=iou_thresholds_to_compute,\n            iou_thresholds_to_keep=iou_thresholds_to_keep,\n        )\n\n        if not isinstance(filters, dict) and filters is not None:\n            filters = Filter.create(filters)\n\n        evaluation = schemas.EvaluationJob(\n            model=self.name,\n            dataset=dataset.name,\n            task_type=enums.TaskType.DETECTION.value,\n            settings=schemas.EvaluationSettings(\n                parameters=parameters,\n                filters=filters,\n            ),\n        )\n\n        resp = self.client._requests_post_rel_host(\n            \"evaluations\", json=asdict(evaluation)\n        ).json()\n\n        # resp should have keys \"missing_pred_labels\", \"ignored_pred_labels\", with values\n        # list of label dicts. convert label dicts to Label objects\n\n        for k in [\"missing_pred_labels\", \"ignored_pred_labels\"]:\n            resp[k] = [Label(**la) for la in resp[k]]\n\n        evaluation_job = Evaluation(\n            client=self.client,\n            dataset=dataset.name,\n            model=self.name,\n            **resp,\n        )\n\n        # blocking behavior\n        if timeout:\n            evaluation_job.wait_for_completion(interval=1.0, timeout=timeout)\n\n        return evaluation_job\n\n    def evaluate_segmentation(\n        self,\n        dataset: Dataset,\n        filters: Union[Dict, List[BinaryExpression]] = None,\n        timeout: Optional[int] = None,\n    ) -&gt; Evaluation:\n        \"\"\"\n        Start a semantic-segmentation evaluation job.\n\n        Parameters\n        ----------\n        dataset : Dataset\n            The dataset to evaluate against.\n        filters : Union[Dict, List[BinaryExpression]]\n            Optional set of filters to constrain evaluation by.\n        timeout : int\n            The number of seconds to wait for the job to finish. Used to ensure deterministic behavior when testing.\n\n        Returns\n        -------\n        Evaluation\n            a job object that can be used to track the status of the job and get the metrics of it upon completion\n        \"\"\"\n\n        # if list[BinaryExpression], convert to filter object\n        if not isinstance(filters, dict) and filters is not None:\n            filters = Filter.create(filters)\n\n        # create evaluation job\n        evaluation = schemas.EvaluationJob(\n            model=self.name,\n            dataset=dataset.name,\n            task_type=enums.TaskType.SEGMENTATION.value,\n            settings=schemas.EvaluationSettings(\n                filters=filters,\n            ),\n        )\n        resp = self.client._requests_post_rel_host(\n            \"evaluations\",\n            json=asdict(evaluation),\n        ).json()\n\n        # create client-side evaluation handler\n        evaluation_job = Evaluation(\n            client=self.client,\n            dataset=dataset.name,\n            model=self.name,\n            **resp,\n        )\n\n        # blocking behavior\n        if timeout:\n            evaluation_job.wait_for_completion(interval=1.0, timeout=timeout)\n\n        return evaluation_job\n\n    def delete(\n        self,\n    ):\n        \"\"\"\n        Delete the `Model` object from the backend.\n        \"\"\"\n        self.client._requests_delete_rel_host(f\"models/{self.name}\").json()\n        del self\n\n    def get_prediction(self, datum: Datum) -&gt; Prediction:\n        \"\"\"\n        Fetch a particular prediction.\n\n        Parameters\n        ----------\n        datum : Datum\n            The `Datum` of the prediction to return.\n\n        Returns\n        ----------\n        Prediction\n            The requested `Prediction`.\n        \"\"\"\n        resp = self.client._requests_get_rel_host(\n            f\"predictions/model/{self.name}/dataset/{datum.dataset}/datum/{datum.uid}\",\n        ).json()\n        return Prediction(**resp)\n\n    def get_labels(\n        self,\n    ) -&gt; List[Label]:\n        \"\"\"\n        Get all labels associated with a given model.\n\n        Returns\n        ----------\n        List[Label]\n            A list of `Labels` associated with the model.\n        \"\"\"\n        labels = self.client._requests_get_rel_host(\n            f\"labels/model/{self.name}\"\n        ).json()\n\n        return [\n            Label(key=label[\"key\"], value=label[\"value\"]) for label in labels\n        ]\n\n    def get_evaluations(\n        self,\n    ) -&gt; List[Evaluation]:\n        \"\"\"\n        Get all evaluations associated with a given model.\n\n        Returns\n        ----------\n        List[Evaluation]\n            A list of `Evaluations` associated with the model.\n        \"\"\"\n        dataset_evaluations = self.client._requests_get_rel_host(\n            f\"evaluations/model/{self.name}\"\n        ).json()\n        return [\n            Evaluation(\n                client=self.client,\n                dataset=dataset_name,\n                model=self.name,\n                job_id=job_id,\n            )\n            for dataset_name in dataset_evaluations\n            for job_id in dataset_evaluations[dataset_name]\n        ]\n\n    def get_metric_dataframes(\n        self,\n    ) -&gt; dict:\n        \"\"\"\n        Get all metrics associated with a Model and return them in a `pd.DataFrame`.\n\n        Returns\n        ----------\n        dict\n            A dictionary of the `Model's` metrics and settings, with the metrics being displayed in a `pd.DataFrame`.\n        \"\"\"\n        try:\n            import pandas as pd\n        except ModuleNotFoundError:\n            raise ModuleNotFoundError(\n                \"Must have pandas installed to use `get_metric_dataframes`.\"\n            )\n\n        ret = []\n        for evaluation in self.get_evaluations():\n            metrics = [\n                {**metric, \"dataset\": evaluation.dataset}\n                for metric in evaluation.results.metrics\n            ]\n            df = pd.DataFrame(metrics)\n            for k in [\"label\", \"parameters\"]:\n                df[k] = df[k].fillna(\"n/a\")\n            df[\"parameters\"] = df[\"parameters\"].apply(json.dumps)\n            df[\"label\"] = df[\"label\"].apply(\n                lambda x: f\"{x['key']}: {x['value']}\" if x != \"n/a\" else x\n            )\n            df = df.pivot(\n                index=[\"type\", \"parameters\", \"label\"], columns=[\"dataset\"]\n            )\n            ret.append({\"settings\": evaluation.settings, \"df\": df})\n\n        return ret\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model-functions","title":"Functions","text":""},{"location":"references/Python%20Client/model/#velour.Model.add_prediction","title":"<code>velour.Model.add_prediction(prediction)</code>","text":"<p>Add a prediction to a given model.</p> <p>Parameters:</p> Name Type Description Default <code>prediction</code> <code>Prediction</code> <p>The <code>Prediction</code> object to add to the <code>Model</code>.</p> required Source code in <code>client/velour/client.py</code> <pre><code>def add_prediction(self, prediction: Prediction):\n    \"\"\"\n    Add a prediction to a given model.\n\n    Parameters\n    ----------\n    prediction : Prediction\n        The `Prediction` object to add to the `Model`.\n    \"\"\"\n    if not isinstance(prediction, Prediction):\n        raise TypeError(\n            f\"Expected `velour.Prediction`, got `{type(prediction)}`\"\n        )\n\n    if len(prediction.annotations) == 0:\n        warnings.warn(\n            f\"Prediction for datum with uid `{prediction.datum.uid}` contains no annotations. Skipping...\"\n        )\n        return\n\n    prediction.model = self.name\n    return self.client._requests_post_rel_host(\n        \"predictions\",\n        json=prediction.dict(),\n    )\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.create","title":"<code>velour.Model.create(client, name, metadata=None, geospatial=None, id=None)</code>  <code>classmethod</code>","text":"<p>Create a new Model</p> <p>Attributes:</p> Name Type Description <code>client</code> <code>Client</code> <p>The <code>Client</code> object associated with the session.</p> <code>name</code> <code>str</code> <p>The name of the model.</p> <code>metadata</code> <code>dict</code> <p>A dictionary of metadata that describes the model.</p> <code>geospatial</code> <code>dict</code> <p>A GeoJSON-style dictionary describing the geospatial coordinates of the model.</p> <code>id</code> <code>int</code> <p>The ID of the model.</p> <p>Returns:</p> Type Description <code>Model</code> <p>The newly-created <code>Model</code> object.</p> Source code in <code>client/velour/client.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    client: Client,\n    name: str,\n    metadata: Dict[str, Union[int, float, str]] = None,\n    geospatial: Dict[\n        str,\n        Union[\n            List[List[List[List[Union[float, int]]]]],\n            List[List[List[Union[float, int]]]],\n            List[Union[float, int]],\n            str,\n        ],\n    ] = None,\n    id: Union[int, None] = None,\n):\n    \"\"\"\n    Create a new Model\n\n    Attributes\n    ----------\n    client : Client\n        The `Client` object associated with the session.\n    name : str\n        The name of the model.\n    metadata : dict\n        A dictionary of metadata that describes the model.\n    geospatial :  dict\n        A GeoJSON-style dictionary describing the geospatial coordinates of the model.\n    id : int\n        The ID of the model.\n\n\n    Returns\n    ----------\n    Model\n        The newly-created `Model` object.\n    \"\"\"\n    model = cls()\n    model.client = client\n    model.name = name\n    model.metadata = metadata\n    model.geospatial = geospatial\n    model.id = id\n    model._validate()\n    client._requests_post_rel_host(\"models\", json=model.dict())\n    return cls.get(client, name)\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.delete","title":"<code>velour.Model.delete()</code>","text":"<p>Delete the <code>Model</code> object from the backend.</p> Source code in <code>client/velour/client.py</code> <pre><code>def delete(\n    self,\n):\n    \"\"\"\n    Delete the `Model` object from the backend.\n    \"\"\"\n    self.client._requests_delete_rel_host(f\"models/{self.name}\").json()\n    del self\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.dict","title":"<code>velour.Model.dict()</code>","text":"<p>Defines how a <code>Model</code> object is transformed into a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the <code>Model's</code> attributes.</p> Source code in <code>client/velour/client.py</code> <pre><code>def dict(self) -&gt; dict:\n    \"\"\"\n    Defines how a `Model` object is transformed into a dictionary.\n\n    Returns\n    ----------\n    dict\n        A dictionary of the `Model's` attributes.\n    \"\"\"\n    return {\n        \"id\": self.id,\n        \"name\": self.name,\n        \"metadata\": self.metadata,\n        \"geospatial\": self.geospatial,\n    }\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.evaluate_classification","title":"<code>velour.Model.evaluate_classification(dataset, filters=None, timeout=None)</code>","text":"<p>Start a classification evaluation job.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>The dataset to evaluate against.</p> required <code>filters</code> <code>Union[Dict, List[BinaryExpression]]</code> <p>Optional set of filters to constrain evaluation by.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>The number of seconds to wait for the job to finish. Used to ensure deterministic behavior when testing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Evaluation</code> <p>A job object that can be used to track the status of the job and get the metrics of it upon completion.</p> Source code in <code>client/velour/client.py</code> <pre><code>def evaluate_classification(\n    self,\n    dataset: Dataset,\n    filters: Union[Dict, List[BinaryExpression]] = None,\n    timeout: Optional[int] = None,\n) -&gt; Evaluation:\n    \"\"\"\n    Start a classification evaluation job.\n\n    Parameters\n    ----------\n    dataset : Dataset\n        The dataset to evaluate against.\n    filters : Union[Dict, List[BinaryExpression]]\n        Optional set of filters to constrain evaluation by.\n    timeout : int\n        The number of seconds to wait for the job to finish. Used to ensure deterministic behavior when testing.\n\n    Returns\n    -------\n    Evaluation\n        A job object that can be used to track the status of the job and get the metrics of it upon completion.\n    \"\"\"\n\n    # If list[BinaryExpression], convert to filter object\n    if not isinstance(filters, dict) and filters is not None:\n        filters = Filter.create(filters)\n\n    evaluation = schemas.EvaluationJob(\n        model=self.name,\n        dataset=dataset.name,\n        task_type=enums.TaskType.CLASSIFICATION.value,\n        settings=schemas.EvaluationSettings(\n            filters=filters,\n        ),\n    )\n\n    resp = self.client._requests_post_rel_host(\n        \"evaluations\", json=asdict(evaluation)\n    ).json()\n\n    evaluation_job = Evaluation(\n        client=self.client,\n        dataset=dataset.name,\n        model=self.name,\n        **resp,\n    )\n\n    # blocking behavior\n    if timeout:\n        evaluation_job.wait_for_completion(interval=1.0, timeout=timeout)\n\n    return evaluation_job\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.evaluate_detection","title":"<code>velour.Model.evaluate_detection(dataset, iou_thresholds_to_compute=None, iou_thresholds_to_keep=None, filters=None, timeout=None)</code>","text":"<p>Start a object-detection evaluation job.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>The dataset to evaluate against.</p> required <code>iou_thresholds_to_compute</code> <code>List[float]</code> <p>Thresholds to compute mAP against.</p> <code>None</code> <code>iou_thresholds_to_keep</code> <code>List[float]</code> <p>Thresholds to return AP for. Must be subset of <code>iou_thresholds_to_compute</code>.</p> <code>None</code> <code>filters</code> <code>Union[Dict, List[BinaryExpression]]</code> <p>Optional set of filters to constrain evaluation by.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>The number of seconds to wait for the job to finish. Used to ensure deterministic behavior when testing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Evaluation</code> <p>A job object that can be used to track the status of the job and get the metrics of it upon completion.</p> Source code in <code>client/velour/client.py</code> <pre><code>def evaluate_detection(\n    self,\n    dataset: \"Dataset\",\n    iou_thresholds_to_compute: List[float] = None,\n    iou_thresholds_to_keep: List[float] = None,\n    filters: Union[Dict, List[BinaryExpression]] = None,\n    timeout: Optional[int] = None,\n) -&gt; Evaluation:\n    \"\"\"\n    Start a object-detection evaluation job.\n\n    Parameters\n    ----------\n    dataset : Dataset\n        The dataset to evaluate against.\n    iou_thresholds_to_compute : List[float]\n        Thresholds to compute mAP against.\n    iou_thresholds_to_keep : List[float]\n        Thresholds to return AP for. Must be subset of `iou_thresholds_to_compute`.\n    filters : Union[Dict, List[BinaryExpression]]\n        Optional set of filters to constrain evaluation by.\n    timeout : int\n        The number of seconds to wait for the job to finish. Used to ensure deterministic behavior when testing.\n\n    Returns\n    -------\n    Evaluation\n        A job object that can be used to track the status of the job and get the metrics of it upon completion.\n    \"\"\"\n\n    # Default iou thresholds\n    if iou_thresholds_to_compute is None:\n        iou_thresholds_to_compute = [\n            round(0.5 + 0.05 * i, 2) for i in range(10)\n        ]\n    if iou_thresholds_to_keep is None:\n        iou_thresholds_to_keep = [0.5, 0.75]\n\n    parameters = schemas.DetectionParameters(\n        iou_thresholds_to_compute=iou_thresholds_to_compute,\n        iou_thresholds_to_keep=iou_thresholds_to_keep,\n    )\n\n    if not isinstance(filters, dict) and filters is not None:\n        filters = Filter.create(filters)\n\n    evaluation = schemas.EvaluationJob(\n        model=self.name,\n        dataset=dataset.name,\n        task_type=enums.TaskType.DETECTION.value,\n        settings=schemas.EvaluationSettings(\n            parameters=parameters,\n            filters=filters,\n        ),\n    )\n\n    resp = self.client._requests_post_rel_host(\n        \"evaluations\", json=asdict(evaluation)\n    ).json()\n\n    # resp should have keys \"missing_pred_labels\", \"ignored_pred_labels\", with values\n    # list of label dicts. convert label dicts to Label objects\n\n    for k in [\"missing_pred_labels\", \"ignored_pred_labels\"]:\n        resp[k] = [Label(**la) for la in resp[k]]\n\n    evaluation_job = Evaluation(\n        client=self.client,\n        dataset=dataset.name,\n        model=self.name,\n        **resp,\n    )\n\n    # blocking behavior\n    if timeout:\n        evaluation_job.wait_for_completion(interval=1.0, timeout=timeout)\n\n    return evaluation_job\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.evaluate_segmentation","title":"<code>velour.Model.evaluate_segmentation(dataset, filters=None, timeout=None)</code>","text":"<p>Start a semantic-segmentation evaluation job.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>The dataset to evaluate against.</p> required <code>filters</code> <code>Union[Dict, List[BinaryExpression]]</code> <p>Optional set of filters to constrain evaluation by.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>The number of seconds to wait for the job to finish. Used to ensure deterministic behavior when testing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Evaluation</code> <p>a job object that can be used to track the status of the job and get the metrics of it upon completion</p> Source code in <code>client/velour/client.py</code> <pre><code>def evaluate_segmentation(\n    self,\n    dataset: Dataset,\n    filters: Union[Dict, List[BinaryExpression]] = None,\n    timeout: Optional[int] = None,\n) -&gt; Evaluation:\n    \"\"\"\n    Start a semantic-segmentation evaluation job.\n\n    Parameters\n    ----------\n    dataset : Dataset\n        The dataset to evaluate against.\n    filters : Union[Dict, List[BinaryExpression]]\n        Optional set of filters to constrain evaluation by.\n    timeout : int\n        The number of seconds to wait for the job to finish. Used to ensure deterministic behavior when testing.\n\n    Returns\n    -------\n    Evaluation\n        a job object that can be used to track the status of the job and get the metrics of it upon completion\n    \"\"\"\n\n    # if list[BinaryExpression], convert to filter object\n    if not isinstance(filters, dict) and filters is not None:\n        filters = Filter.create(filters)\n\n    # create evaluation job\n    evaluation = schemas.EvaluationJob(\n        model=self.name,\n        dataset=dataset.name,\n        task_type=enums.TaskType.SEGMENTATION.value,\n        settings=schemas.EvaluationSettings(\n            filters=filters,\n        ),\n    )\n    resp = self.client._requests_post_rel_host(\n        \"evaluations\",\n        json=asdict(evaluation),\n    ).json()\n\n    # create client-side evaluation handler\n    evaluation_job = Evaluation(\n        client=self.client,\n        dataset=dataset.name,\n        model=self.name,\n        **resp,\n    )\n\n    # blocking behavior\n    if timeout:\n        evaluation_job.wait_for_completion(interval=1.0, timeout=timeout)\n\n    return evaluation_job\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.finalize_inferences","title":"<code>velour.Model.finalize_inferences(dataset)</code>","text":"<p>Finalize the <code>Model</code> object such that new <code>Predictions</code> cannot be added to it.</p> Source code in <code>client/velour/client.py</code> <pre><code>def finalize_inferences(self, dataset: \"Dataset\") -&gt; None:\n    \"\"\"\n    Finalize the `Model` object such that new `Predictions` cannot be added to it.\n    \"\"\"\n    return self.client._requests_put_rel_host(\n        f\"models/{self.name}/datasets/{dataset.name}/finalize\"\n    ).json()\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.get","title":"<code>velour.Model.get(client, name)</code>  <code>classmethod</code>","text":"<p>Fetches a given model from the backend.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The <code>Client</code> object associated with the session.</p> required <code>name</code> <code>str</code> <p>The name of the model.</p> required <p>Returns:</p> Type Description <code>Model</code> <p>The requested <code>Model</code>.</p> Source code in <code>client/velour/client.py</code> <pre><code>@classmethod\ndef get(cls, client: Client, name: str):\n    \"\"\"\n    Fetches a given model from the backend.\n\n    Parameters\n    ----------\n    client : Client\n        The `Client` object associated with the session.\n    name : str\n        The name of the model.\n\n\n    Returns\n    ----------\n    Model\n        The requested `Model`.\n    \"\"\"\n    resp = client._requests_get_rel_host(f\"models/{name}\").json()\n    model = cls()\n    model.client = client\n    model.name = resp[\"name\"]\n    model.metadata = resp[\"metadata\"]\n    model.geospatial = resp[\"geospatial\"]\n    model.id = resp[\"id\"]\n    model._validate()\n    return model\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.get_evaluations","title":"<code>velour.Model.get_evaluations()</code>","text":"<p>Get all evaluations associated with a given model.</p> <p>Returns:</p> Type Description <code>List[Evaluation]</code> <p>A list of <code>Evaluations</code> associated with the model.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_evaluations(\n    self,\n) -&gt; List[Evaluation]:\n    \"\"\"\n    Get all evaluations associated with a given model.\n\n    Returns\n    ----------\n    List[Evaluation]\n        A list of `Evaluations` associated with the model.\n    \"\"\"\n    dataset_evaluations = self.client._requests_get_rel_host(\n        f\"evaluations/model/{self.name}\"\n    ).json()\n    return [\n        Evaluation(\n            client=self.client,\n            dataset=dataset_name,\n            model=self.name,\n            job_id=job_id,\n        )\n        for dataset_name in dataset_evaluations\n        for job_id in dataset_evaluations[dataset_name]\n    ]\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.get_labels","title":"<code>velour.Model.get_labels()</code>","text":"<p>Get all labels associated with a given model.</p> <p>Returns:</p> Type Description <code>List[Label]</code> <p>A list of <code>Labels</code> associated with the model.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_labels(\n    self,\n) -&gt; List[Label]:\n    \"\"\"\n    Get all labels associated with a given model.\n\n    Returns\n    ----------\n    List[Label]\n        A list of `Labels` associated with the model.\n    \"\"\"\n    labels = self.client._requests_get_rel_host(\n        f\"labels/model/{self.name}\"\n    ).json()\n\n    return [\n        Label(key=label[\"key\"], value=label[\"value\"]) for label in labels\n    ]\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.get_metric_dataframes","title":"<code>velour.Model.get_metric_dataframes()</code>","text":"<p>Get all metrics associated with a Model and return them in a <code>pd.DataFrame</code>.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the <code>Model's</code> metrics and settings, with the metrics being displayed in a <code>pd.DataFrame</code>.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_metric_dataframes(\n    self,\n) -&gt; dict:\n    \"\"\"\n    Get all metrics associated with a Model and return them in a `pd.DataFrame`.\n\n    Returns\n    ----------\n    dict\n        A dictionary of the `Model's` metrics and settings, with the metrics being displayed in a `pd.DataFrame`.\n    \"\"\"\n    try:\n        import pandas as pd\n    except ModuleNotFoundError:\n        raise ModuleNotFoundError(\n            \"Must have pandas installed to use `get_metric_dataframes`.\"\n        )\n\n    ret = []\n    for evaluation in self.get_evaluations():\n        metrics = [\n            {**metric, \"dataset\": evaluation.dataset}\n            for metric in evaluation.results.metrics\n        ]\n        df = pd.DataFrame(metrics)\n        for k in [\"label\", \"parameters\"]:\n            df[k] = df[k].fillna(\"n/a\")\n        df[\"parameters\"] = df[\"parameters\"].apply(json.dumps)\n        df[\"label\"] = df[\"label\"].apply(\n            lambda x: f\"{x['key']}: {x['value']}\" if x != \"n/a\" else x\n        )\n        df = df.pivot(\n            index=[\"type\", \"parameters\", \"label\"], columns=[\"dataset\"]\n        )\n        ret.append({\"settings\": evaluation.settings, \"df\": df})\n\n    return ret\n</code></pre>"},{"location":"references/Python%20Client/model/#velour.Model.get_prediction","title":"<code>velour.Model.get_prediction(datum)</code>","text":"<p>Fetch a particular prediction.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>Datum</code> <p>The <code>Datum</code> of the prediction to return.</p> required <p>Returns:</p> Type Description <code>Prediction</code> <p>The requested <code>Prediction</code>.</p> Source code in <code>client/velour/client.py</code> <pre><code>def get_prediction(self, datum: Datum) -&gt; Prediction:\n    \"\"\"\n    Fetch a particular prediction.\n\n    Parameters\n    ----------\n    datum : Datum\n        The `Datum` of the prediction to return.\n\n    Returns\n    ----------\n    Prediction\n        The requested `Prediction`.\n    \"\"\"\n    resp = self.client._requests_get_rel_host(\n        f\"predictions/model/{self.name}/dataset/{datum.dataset}/datum/{datum.uid}\",\n    ).json()\n    return Prediction(**resp)\n</code></pre>"},{"location":"references/Python%20Client/prediction/","title":"Prediction","text":"<p>An object describing a prediction (e.g., a machine-drawn bounding box on an image).</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>Datum</code> <p>The <code>Datum</code> associated with the <code>Prediction</code>.</p> required <code>annotations</code> <code>List[Annotation]</code> <p>The list of <code>Annotations</code> associated with the <code>Prediction</code>.</p> <code>None</code> <code>model</code> <code>str</code> <p>The name of the model that produced the <code>Prediction</code>.</p> <code>''</code> <p>Attributes:</p> Name Type Description <code>score</code> <code>Union[float, int]</code> <p>The score assigned to the <code>Prediction</code>.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>class Prediction:\n    \"\"\"\n    An object describing a prediction (e.g., a machine-drawn bounding box on an image).\n\n    Parameters\n    ----------\n    datum : Datum\n        The `Datum` associated with the `Prediction`.\n    annotations : List[Annotation]\n        The list of `Annotations` associated with the `Prediction`.\n    model : str\n        The name of the model that produced the `Prediction`.\n\n    Attributes\n    ----------\n    score : Union[float, int]\n        The score assigned to the `Prediction`.\n    \"\"\"\n\n    score = DeclarativeMapper(\"prediction_scores\", Union[int, float])\n\n    def __init__(\n        self,\n        datum: Datum,\n        annotations: List[Annotation] = None,\n        model: str = \"\",\n    ):\n        self.datum = datum\n        self.annotations = annotations\n        self.model = model\n        self._validate()\n\n    def _validate(self):\n        \"\"\"\n        Validate the inputs of the `Prediction`.\n        \"\"\"\n        # validate datum\n        if isinstance(self.datum, dict):\n            self.datum = Datum(**self.datum)\n        if not isinstance(self.datum, Datum):\n            raise SchemaTypeError(\"datum\", Datum, self.datum)\n\n        # validate annotations\n        if not isinstance(self.annotations, list):\n            raise SchemaTypeError(\n                \"annotations\", List[Annotation], self.annotations\n            )\n        for idx, annotation in enumerate(self.annotations):\n            if isinstance(self.annotations[idx], dict):\n                self.annotations[idx] = Annotation(**annotation)\n            if not isinstance(self.annotations[idx], Annotation):\n                raise SchemaTypeError(\n                    \"annotation\", Annotation, self.annotations[idx]\n                )\n\n        # validate model\n        if not isinstance(self.model, str):\n            raise SchemaTypeError(\"model\", str, self.model)\n\n        # TaskType-specific validations\n        for annotation in self.annotations:\n            if annotation.task_type in [\n                TaskType.CLASSIFICATION,\n                TaskType.DETECTION,\n            ]:\n                for label in annotation.labels:\n                    if label.score is None:\n                        raise ValueError(\n                            f\"For task type `{annotation.task_type}` prediction labels must have scores, but got `None`\"\n                        )\n            if annotation.task_type == TaskType.CLASSIFICATION:\n                label_keys_to_sum = {}\n                for scored_label in annotation.labels:\n                    label_key = scored_label.key\n                    if label_key not in label_keys_to_sum:\n                        label_keys_to_sum[label_key] = 0.0\n                    label_keys_to_sum[label_key] += scored_label.score\n\n                for k, total_score in label_keys_to_sum.items():\n                    if abs(total_score - 1) &gt; 1e-5:\n                        raise ValueError(\n                            \"For each label key, prediction scores must sum to 1, but\"\n                            f\" for label key {k} got scores summing to {total_score}.\"\n                        )\n\n    def dict(self) -&gt; dict:\n        \"\"\"\n        Defines how a `Prediction` is transformed into a dictionary.\n\n        Returns\n        ----------\n        dict\n            A dictionary of the `Prediction's` attributes.\n        \"\"\"\n        return {\n            \"datum\": self.datum.dict(),\n            \"model\": self.model,\n            \"annotations\": [\n                annotation.dict() for annotation in self.annotations\n            ],\n        }\n\n    def __eq__(self, other):\n        \"\"\"\n        Defines how `Predictions` are compared to one another\n\n        Parameters\n        ----------\n        other : Prediction\n            The object to compare with the `Prediction`.\n\n        Returns\n        ----------\n        boolean\n            A boolean describing whether the two objects are equal.\n        \"\"\"\n        if not isinstance(other, Prediction):\n            raise TypeError(\n                f\"Expected type `{type(Prediction)}`, got `{other}`\"\n            )\n        return self.dict() == other.dict()\n</code></pre>"},{"location":"references/Python%20Client/prediction/#velour.Prediction-functions","title":"Functions","text":""},{"location":"references/Python%20Client/prediction/#velour.Prediction.__eq__","title":"<code>velour.Prediction.__eq__(other)</code>","text":"<p>Defines how <code>Predictions</code> are compared to one another</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Prediction</code> <p>The object to compare with the <code>Prediction</code>.</p> required <p>Returns:</p> Type Description <code>boolean</code> <p>A boolean describing whether the two objects are equal.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Defines how `Predictions` are compared to one another\n\n    Parameters\n    ----------\n    other : Prediction\n        The object to compare with the `Prediction`.\n\n    Returns\n    ----------\n    boolean\n        A boolean describing whether the two objects are equal.\n    \"\"\"\n    if not isinstance(other, Prediction):\n        raise TypeError(\n            f\"Expected type `{type(Prediction)}`, got `{other}`\"\n        )\n    return self.dict() == other.dict()\n</code></pre>"},{"location":"references/Python%20Client/prediction/#velour.Prediction.dict","title":"<code>velour.Prediction.dict()</code>","text":"<p>Defines how a <code>Prediction</code> is transformed into a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the <code>Prediction's</code> attributes.</p> Source code in <code>client/velour/coretypes.py</code> <pre><code>def dict(self) -&gt; dict:\n    \"\"\"\n    Defines how a `Prediction` is transformed into a dictionary.\n\n    Returns\n    ----------\n    dict\n        A dictionary of the `Prediction's` attributes.\n    \"\"\"\n    return {\n        \"datum\": self.datum.dict(),\n        \"model\": self.model,\n        \"annotations\": [\n            annotation.dict() for annotation in self.annotations\n        ],\n    }\n</code></pre>"},{"location":"references/Python%20Client/Schemas/evaluation/","title":"Evaluation","text":""},{"location":"references/Python%20Client/Schemas/evaluation/#velour.schemas.evaluation-classes","title":"Classes","text":""},{"location":"references/Python%20Client/Schemas/evaluation/#velour.schemas.evaluation.DetectionParameters","title":"<code>velour.schemas.evaluation.DetectionParameters</code>  <code>dataclass</code>","text":"<p>Defines important attributes to use when evaluating an object detection model.</p> <p>Attributes:</p> Name Type Description <code>iou_thresholds_to_compute</code> <code>List[float]</code> <p>A list of floats describing which Intersection over Unions (IoUs) to use when calculating metrics (i.e., mAP).</p> <code>iou_thresholds_to_keep</code> <code>List[float]</code> <p>A list of floats describing which Intersection over Union (IoUs) thresholds to calculate a metric for. Must be a subset of <code>iou_thresholds_to_compute</code>.</p> Source code in <code>client/velour/schemas/evaluation.py</code> <pre><code>@dataclass\nclass DetectionParameters:\n    \"\"\"\n    Defines important attributes to use when evaluating an object detection model.\n\n    Attributes\n    ----------\n    iou_thresholds_to_compute : List[float]\n        A list of floats describing which Intersection over Unions (IoUs) to use when calculating metrics (i.e., mAP).\n    iou_thresholds_to_keep: List[float]\n        A list of floats describing which Intersection over Union (IoUs) thresholds to calculate a metric for. Must be a subset of `iou_thresholds_to_compute`.\n    \"\"\"\n\n    iou_thresholds_to_compute: List[float] = None\n    iou_thresholds_to_keep: List[float] = None\n</code></pre>"},{"location":"references/Python%20Client/Schemas/evaluation/#velour.schemas.evaluation.EvaluationJob","title":"<code>velour.schemas.evaluation.EvaluationJob</code>  <code>dataclass</code>","text":"<p>Defines important attributes of the API's <code>EvaluationJob</code>.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>The name of the <code>Model</code> invoked during the evaluation.</p> <code>dataset</code> <code>str</code> <p>The name of the <code>Dataset</code> invoked during the evaluation.</p> <code>task_type</code> <code>str</code> <p>The task type of the evaluation.</p> <code>settings</code> <code>EvaluationSettings</code> <p>The <code>EvaluationSettings</code> object used to configurate the <code>EvaluationJob</code>.</p> <code>id</code> <code>int</code> <p>The id of the job.</p> Source code in <code>client/velour/schemas/evaluation.py</code> <pre><code>@dataclass\nclass EvaluationJob:\n    \"\"\"\n    Defines important attributes of the API's `EvaluationJob`.\n\n    Attributes\n    ----------\n    model : str\n        The name of the `Model` invoked during the evaluation.\n    dataset : str\n        The name of the `Dataset` invoked during the evaluation.\n    task_type : str\n        The task type of the evaluation.\n    settings : EvaluationSettings\n        The `EvaluationSettings` object used to configurate the `EvaluationJob`.\n    id : int\n        The id of the job.\n    \"\"\"\n\n    model: str\n    dataset: str\n    task_type: str\n    settings: EvaluationSettings = field(default_factory=EvaluationSettings)\n    id: int = None\n</code></pre>"},{"location":"references/Python%20Client/Schemas/evaluation/#velour.schemas.evaluation.EvaluationResult","title":"<code>velour.schemas.evaluation.EvaluationResult</code>  <code>dataclass</code>","text":"<p>Defines important attributes of the API's <code>EvaluationResult</code>.</p> <p>Attributes:</p> Name Type Description <code>dataset</code> <code>str</code> <p>The name of the <code>Dataset</code> invoked during the evaluation.</p> <code>model</code> <code>str</code> <p>The name of the <code>Model</code> invoked during the evaluation.</p> <code>settings</code> <code>EvaluationSettings</code> <p>The <code>EvaluationSettings</code> object used to configurate the <code>EvaluationJob</code>.</p> <code>job_id</code> <code>int</code> <p>The id of the job.</p> <code>status</code> <code>str</code> <p>The status of the <code>EvaluationJob</code>.</p> <code>metrics</code> <code>List[dict]</code> <p>A list of metric dictionaries returned by the job.</p> <code>confusion_matrices</code> <code>List[dict]</code> <p>A list of confusion matrix dictionaries returned by the job.</p> Source code in <code>client/velour/schemas/evaluation.py</code> <pre><code>@dataclass\nclass EvaluationResult:\n    \"\"\"\n    Defines important attributes of the API's `EvaluationResult`.\n\n    Attributes\n    ----------\n    dataset : str\n        The name of the `Dataset` invoked during the evaluation.\n    model : str\n        The name of the `Model` invoked during the evaluation.\n    settings : EvaluationSettings\n        The `EvaluationSettings` object used to configurate the `EvaluationJob`.\n    job_id : int\n        The id of the job.\n    status : str\n        The status of the `EvaluationJob`.\n    metrics : List[dict]\n        A list of metric dictionaries returned by the job.\n    confusion_matrices : List[dict]\n        A list of confusion matrix dictionaries returned by the job.\n    \"\"\"\n\n    dataset: str\n    model: str\n    settings: EvaluationSettings\n    job_id: int\n    status: str\n    metrics: List[dict]\n    confusion_matrices: List[dict]\n</code></pre>"},{"location":"references/Python%20Client/Schemas/evaluation/#velour.schemas.evaluation.EvaluationSettings","title":"<code>velour.schemas.evaluation.EvaluationSettings</code>  <code>dataclass</code>","text":"<p>Defines important attributes for evaluating a model.</p> <p>Attributes:</p> Name Type Description <code>parameters</code> <code>Union[DetectionParameters, None]</code> <p>The parameter object (e.g., `DetectionParameters) to use when creating an evaluation.</p> <code>filters</code> <code>Union[Filter, None]</code> <p>The <code>Filter</code>object to use when creating an evaluation.</p> Source code in <code>client/velour/schemas/evaluation.py</code> <pre><code>@dataclass\nclass EvaluationSettings:\n    \"\"\"\n    Defines important attributes for evaluating a model.\n\n    Attributes\n    ----------\n    parameters : Union[DetectionParameters, None]\n        The parameter object (e.g., `DetectionParameters) to use when creating an evaluation.\n    filters: Union[Filter, None]\n        The `Filter`object to use when creating an evaluation.\n    \"\"\"\n\n    parameters: Union[DetectionParameters, None] = None\n    filters: Union[Filter, None] = None\n</code></pre>"},{"location":"references/Python%20Client/Schemas/filters/","title":"Filters","text":""},{"location":"references/Python%20Client/Schemas/filters/#velour.schemas.filters-classes","title":"Classes","text":""},{"location":"references/Python%20Client/Schemas/filters/#velour.schemas.filters.Filter","title":"<code>velour.schemas.filters.Filter</code>  <code>dataclass</code>","text":"<p>Used to filter Evaluations according to specific, user-defined criteria.</p> <p>Attributes:</p> Name Type Description <code>dataset_names</code> <code>List[str]</code> <p>A list of <code>Dataset</code> names to filter on.</p> <code>dataset_metadata</code> <code>Dict[str, List[ValueFilter]]</code> <p>A dictionary of <code>Dataset</code> metadata to filter on.</p> <code>dataset_geospatial</code> <code>List[GeospatialFilter].</code> <p>A list of <code>Dataset</code> geospatial filters to filter on.</p> <code>models_names</code> <code>List[str]</code> <p>A list of <code>Model</code> names to filter on.</p> <code>models_metadata</code> <code>Dict[str, List[ValueFilter]]</code> <p>A dictionary of <code>Model</code> metadata to filter on.</p> <code>models_geospatial</code> <code>List[GeospatialFilter]</code> <p>A list of <code>Model</code> geospatial filters to filter on.</p> <code>datum_uids</code> <code>List[str]</code> <p>A list of <code>Datum</code> UIDs to filter on.</p> <code>datum_metadata</code> <code>Dict[str, List[ValueFilter]] = None</code> <p>A dictionary of <code>Datum</code> metadata to filter on.</p> <code>datum_geospatial</code> <code>List[GeospatialFilter]</code> <p>A list of <code>Datum</code> geospatial filters to filter on.</p> <code>task_types</code> <code>List[TaskType]</code> <p>A list of task types to filter on.</p> <code>annotation_types</code> <code>List[AnnotationType]</code> <p>A list of <code>Annotation</code> types to filter on.</p> <code>annotation_geometric_area</code> <code>List[ValueFilter]</code> <p>A list of <code>ValueFilters</code> which are used to filter <code>Evaluations</code> according to the <code>Annotation</code>'s geometric area.</p> <code>annotation_metadata</code> <code>Dict[str, List[ValueFilter]]</code> <p>A dictionary of <code>Annotation</code> metadata to filter on.</p> <code>annotation_geospatial</code> <code>List[GeospatialFilter]</code> <p>A list of <code>Annotation</code> geospatial filters to filter on.</p> <code>prediction_scores</code> <code>List[ValueFilter]</code> <p>A list of <code>ValueFilters</code> which are used to filter <code>Evaluations</code> according to the <code>Model</code>'s prediction scores.</p> <code>labels</code> <code>List[Dict[str, str]]</code> <p>A dictionary of `Labels' to filter on.</p> <code>label_ids</code> <code>List[int]</code> <p>A list of <code>Label</code> IDs to filter on.</p> <code>label_keys</code> <code>List[str] = None</code> <p>A list of <code>Label</code> keys to filter on.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>value</code> isn't of the correct type.</p> <code>ValueError</code> <p>If the <code>operator</code> doesn't match one of the allowed patterns.</p> Source code in <code>client/velour/schemas/filters.py</code> <pre><code>@dataclass\nclass Filter:\n    \"\"\"\n    Used to filter Evaluations according to specific, user-defined criteria.\n\n    Attributes\n    ----------\n    dataset_names: List[str]\n        A list of `Dataset` names to filter on.\n    dataset_metadata: Dict[str, List[ValueFilter]]\n        A dictionary of `Dataset` metadata to filter on.\n    dataset_geospatial: List[GeospatialFilter].\n        A list of `Dataset` geospatial filters to filter on.\n    models_names: List[str]\n        A list of `Model` names to filter on.\n    models_metadata: Dict[str, List[ValueFilter]]\n        A dictionary of `Model` metadata to filter on.\n    models_geospatial: List[GeospatialFilter]\n        A list of `Model` geospatial filters to filter on.\n    datum_uids: List[str]\n        A list of `Datum` UIDs to filter on.\n    datum_metadata: Dict[str, List[ValueFilter]] = None\n        A dictionary of `Datum` metadata to filter on.\n    datum_geospatial: List[GeospatialFilter]\n        A list of `Datum` geospatial filters to filter on.\n    task_types: List[TaskType]\n        A list of task types to filter on.\n    annotation_types: List[AnnotationType]\n        A list of `Annotation` types to filter on.\n    annotation_geometric_area: List[ValueFilter]\n        A list of `ValueFilters` which are used to filter `Evaluations` according to the `Annotation`'s geometric area.\n    annotation_metadata: Dict[str, List[ValueFilter]]\n        A dictionary of `Annotation` metadata to filter on.\n    annotation_geospatial: List[GeospatialFilter]\n        A list of `Annotation` geospatial filters to filter on.\n    prediction_scores: List[ValueFilter]\n        A list of `ValueFilters` which are used to filter `Evaluations` according to the `Model`'s prediction scores.\n    labels: List[Dict[str, str]]\n        A dictionary of `Labels' to filter on.\n    label_ids: List[int]\n        A list of `Label` IDs to filter on.\n    label_keys: List[str] = None\n        A list of `Label` keys to filter on.\n\n\n    Raises\n    ------\n    TypeError\n        If `value` isn't of the correct type.\n    ValueError\n        If the `operator` doesn't match one of the allowed patterns.\n    \"\"\"\n\n    # datasets\n    dataset_names: List[str] = None\n    dataset_metadata: Dict[str, List[ValueFilter]] = None\n    dataset_geospatial: List[GeospatialFilter] = None\n\n    # models\n    models_names: List[str] = None\n    models_metadata: Dict[str, List[ValueFilter]] = None\n    models_geospatial: List[GeospatialFilter] = None\n\n    # datums\n    datum_uids: List[str] = None\n    datum_metadata: Dict[str, List[ValueFilter]] = None\n    datum_geospatial: List[GeospatialFilter] = None\n\n    # annotations\n    task_types: List[TaskType] = None\n    annotation_types: List[AnnotationType] = None\n    annotation_geometric_area: List[ValueFilter] = None\n    annotation_metadata: Dict[str, List[ValueFilter]] = None\n    annotation_geospatial: List[GeospatialFilter] = None\n\n    # predictions\n    prediction_scores: List[ValueFilter] = None\n\n    # labels\n    labels: List[Dict[str, str]] = None\n    label_ids: List[int] = None\n    label_keys: List[str] = None\n\n    @classmethod\n    def create(cls, expressions: List[BinaryExpression]) -&gt; \"Filter\":\n        \"\"\"\n        Parses a list of `BinaryExpression` to create a `schemas.Filter` object.\n\n        Parameters\n        ----------\n        expressions: List[BinaryExpression]\n            A list of `BinaryExpressions' to parse into a `Filter` object.\n\n        Raises\n        ------\n        NotImplementedError\n            If the user passes the `dataset_geospatial`, `model_geospatial`, `datum_geospatial`, or `annotation_geospatial` arguments into this method.\n        \"\"\"\n\n        # expand nested expressions\n        expression_list = [\n            expr for expr in expressions if isinstance(expr, BinaryExpression)\n        ] + [\n            expr_\n            for expr in expressions\n            if isinstance(expr, list)\n            for expr_ in expr\n            if isinstance(expr_, BinaryExpression)\n        ]\n\n        # create dict using expr names as keys\n        expression_dict = {}\n        for expr in expression_list:\n            if expr.name not in expression_dict:\n                expression_dict[expr.name] = []\n            expression_dict[expr.name].append(expr)\n\n        # create filter\n        filter_request = cls()\n\n        # datasets\n        if \"dataset_names\" in expression_dict:\n            filter_request.dataset_names = [\n                expr.value for expr in expression_dict[\"dataset_names\"]\n            ]\n        if \"dataset_metadata\" in expression_dict:\n            filter_request.dataset_metadata = {\n                expr.key: ValueFilter(\n                    value=expr.value,\n                    operator=expr.operator,\n                )\n                for expr in expression_dict[\"dataset_metadata\"]\n            }\n        if \"dataset_geospatial\" in expression_dict:\n            raise NotImplementedError\n\n        # models\n        if \"models_names\" in expression_dict:\n            filter_request.models_names = [\n                expr.value for expr in expression_dict[\"models_names\"]\n            ]\n        if \"models_metadata\" in expression_dict:\n            filter_request.models_metadata = {\n                expr.key: ValueFilter(\n                    value=expr.value,\n                    operator=expr.operator,\n                )\n                for expr in expression_dict[\"models_metadata\"]\n            }\n        if \"model_geospatial\" in expression_dict:\n            raise NotImplementedError\n\n        # datums\n        if \"datum_uids\" in expression_dict:\n            filter_request.datum_uids = [\n                expr.value for expr in expression_dict[\"datum_uids\"]\n            ]\n        if \"datum_metadata\" in expression_dict:\n            filter_request.datum_metadata = {\n                expr.key: ValueFilter(\n                    value=expr.value,\n                    operator=expr.operator,\n                )\n                for expr in expression_dict[\"datum_metadata\"]\n            }\n        if \"datum_geospatial\" in expression_dict:\n            raise NotImplementedError\n\n        # annotations\n        if \"task_types\" in expression_dict:\n            filter_request.task_types = [\n                expr.value for expr in expression_dict[\"task_types\"]\n            ]\n        if \"annotation_types\" in expression_dict:\n            filter_request.annotation_types = [\n                expr.value for expr in expression_dict[\"annotation_types\"]\n            ]\n        if \"annotation_geometric_area\" in expression_dict:\n            filter_request.annotation_geometric_area = [\n                ValueFilter(\n                    value=expr.value,\n                    operator=expr.operator,\n                )\n                for expr in expression_dict[\"annotation_geometric_area\"]\n            ]\n        if \"annotation_metadata\" in expression_dict:\n            filter_request.annotation_metadata = {\n                expr.key: ValueFilter(\n                    value=expr.value,\n                    operator=expr.operator,\n                )\n                for expr in expression_dict[\"annotation_metadata\"]\n            }\n        if \"annotation_geospatial\" in expression_dict:\n            raise NotImplementedError\n\n        # predictions\n        if \"prediction_scores\" in expression_dict:\n            filter_request.prediction_scores = [\n                ValueFilter(\n                    value=expr.value,\n                    operator=expr.operator,\n                )\n                for expr in expression_dict[\"prediction_scores\"]\n            ]\n\n        # labels\n        if \"label_ids\" in expression_dict:\n            filter_request.label_ids = [\n                expr.value for expr in expression_dict[\"label_ids\"]\n            ]\n        if \"labels\" in expression_dict:\n            filter_request.labels = [\n                {expr.key: expr.value} for expr in expression_dict[\"labels\"]\n            ]\n        if \"label_keys\" in expression_dict:\n            filter_request.label_keys = [\n                expr.value for expr in expression_dict[\"label_keys\"]\n            ]\n\n        return filter_request\n</code></pre>"},{"location":"references/Python%20Client/Schemas/filters/#velour.schemas.filters.Filter-functions","title":"Functions","text":""},{"location":"references/Python%20Client/Schemas/filters/#velour.schemas.filters.Filter.create","title":"<code>velour.schemas.filters.Filter.create(expressions)</code>  <code>classmethod</code>","text":"<p>Parses a list of <code>BinaryExpression</code> to create a <code>schemas.Filter</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>expressions</code> <code>List[BinaryExpression]</code> <p>A list of <code>BinaryExpressions' to parse into a</code>Filter` object.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the user passes the <code>dataset_geospatial</code>, <code>model_geospatial</code>, <code>datum_geospatial</code>, or <code>annotation_geospatial</code> arguments into this method.</p> Source code in <code>client/velour/schemas/filters.py</code> <pre><code>@classmethod\ndef create(cls, expressions: List[BinaryExpression]) -&gt; \"Filter\":\n    \"\"\"\n    Parses a list of `BinaryExpression` to create a `schemas.Filter` object.\n\n    Parameters\n    ----------\n    expressions: List[BinaryExpression]\n        A list of `BinaryExpressions' to parse into a `Filter` object.\n\n    Raises\n    ------\n    NotImplementedError\n        If the user passes the `dataset_geospatial`, `model_geospatial`, `datum_geospatial`, or `annotation_geospatial` arguments into this method.\n    \"\"\"\n\n    # expand nested expressions\n    expression_list = [\n        expr for expr in expressions if isinstance(expr, BinaryExpression)\n    ] + [\n        expr_\n        for expr in expressions\n        if isinstance(expr, list)\n        for expr_ in expr\n        if isinstance(expr_, BinaryExpression)\n    ]\n\n    # create dict using expr names as keys\n    expression_dict = {}\n    for expr in expression_list:\n        if expr.name not in expression_dict:\n            expression_dict[expr.name] = []\n        expression_dict[expr.name].append(expr)\n\n    # create filter\n    filter_request = cls()\n\n    # datasets\n    if \"dataset_names\" in expression_dict:\n        filter_request.dataset_names = [\n            expr.value for expr in expression_dict[\"dataset_names\"]\n        ]\n    if \"dataset_metadata\" in expression_dict:\n        filter_request.dataset_metadata = {\n            expr.key: ValueFilter(\n                value=expr.value,\n                operator=expr.operator,\n            )\n            for expr in expression_dict[\"dataset_metadata\"]\n        }\n    if \"dataset_geospatial\" in expression_dict:\n        raise NotImplementedError\n\n    # models\n    if \"models_names\" in expression_dict:\n        filter_request.models_names = [\n            expr.value for expr in expression_dict[\"models_names\"]\n        ]\n    if \"models_metadata\" in expression_dict:\n        filter_request.models_metadata = {\n            expr.key: ValueFilter(\n                value=expr.value,\n                operator=expr.operator,\n            )\n            for expr in expression_dict[\"models_metadata\"]\n        }\n    if \"model_geospatial\" in expression_dict:\n        raise NotImplementedError\n\n    # datums\n    if \"datum_uids\" in expression_dict:\n        filter_request.datum_uids = [\n            expr.value for expr in expression_dict[\"datum_uids\"]\n        ]\n    if \"datum_metadata\" in expression_dict:\n        filter_request.datum_metadata = {\n            expr.key: ValueFilter(\n                value=expr.value,\n                operator=expr.operator,\n            )\n            for expr in expression_dict[\"datum_metadata\"]\n        }\n    if \"datum_geospatial\" in expression_dict:\n        raise NotImplementedError\n\n    # annotations\n    if \"task_types\" in expression_dict:\n        filter_request.task_types = [\n            expr.value for expr in expression_dict[\"task_types\"]\n        ]\n    if \"annotation_types\" in expression_dict:\n        filter_request.annotation_types = [\n            expr.value for expr in expression_dict[\"annotation_types\"]\n        ]\n    if \"annotation_geometric_area\" in expression_dict:\n        filter_request.annotation_geometric_area = [\n            ValueFilter(\n                value=expr.value,\n                operator=expr.operator,\n            )\n            for expr in expression_dict[\"annotation_geometric_area\"]\n        ]\n    if \"annotation_metadata\" in expression_dict:\n        filter_request.annotation_metadata = {\n            expr.key: ValueFilter(\n                value=expr.value,\n                operator=expr.operator,\n            )\n            for expr in expression_dict[\"annotation_metadata\"]\n        }\n    if \"annotation_geospatial\" in expression_dict:\n        raise NotImplementedError\n\n    # predictions\n    if \"prediction_scores\" in expression_dict:\n        filter_request.prediction_scores = [\n            ValueFilter(\n                value=expr.value,\n                operator=expr.operator,\n            )\n            for expr in expression_dict[\"prediction_scores\"]\n        ]\n\n    # labels\n    if \"label_ids\" in expression_dict:\n        filter_request.label_ids = [\n            expr.value for expr in expression_dict[\"label_ids\"]\n        ]\n    if \"labels\" in expression_dict:\n        filter_request.labels = [\n            {expr.key: expr.value} for expr in expression_dict[\"labels\"]\n        ]\n    if \"label_keys\" in expression_dict:\n        filter_request.label_keys = [\n            expr.value for expr in expression_dict[\"label_keys\"]\n        ]\n\n    return filter_request\n</code></pre>"},{"location":"references/Python%20Client/Schemas/filters/#velour.schemas.filters.GeospatialFilter","title":"<code>velour.schemas.filters.GeospatialFilter</code>  <code>dataclass</code>","text":"<p>Used to filter on geospatial coordinates.</p> <p>Attributes:</p> Name Type Description <code>geodict</code> <code>Dict[str, Union[List[List[List[List[Union[float, int]]]]], List[List[List[Union[float, int]]]], List[Union[float, int]], str]]</code> <p>A dictionary containing a Point, Polygon, or MultiPolygon. Mirrors <code>shapely's</code> <code>GeoJSON</code> format.</p> <code>operator</code> <code>str</code> <p>The operator to use for comparison. Should be one of <code>intersect</code>, <code>inside</code>, or <code>outside</code>.</p> Source code in <code>client/velour/schemas/filters.py</code> <pre><code>@dataclass\nclass GeospatialFilter:\n    \"\"\"\n    Used to filter on geospatial coordinates.\n\n    Attributes\n    ----------\n    geodict : Dict[str, Union[List[List[List[List[Union[float, int]]]]], List[List[List[Union[float, int]]]], List[Union[float, int]], str]]\n        A dictionary containing a Point, Polygon, or MultiPolygon. Mirrors `shapely's` `GeoJSON` format.\n    operator : str\n        The operator to use for comparison. Should be one of `intersect`, `inside`, or `outside`.\n\n    \"\"\"\n\n    geodict: Dict[\n        str,\n        Union[\n            List[List[List[List[Union[float, int]]]]],\n            List[List[List[Union[float, int]]]],\n            List[Union[float, int]],\n            str,\n        ],\n    ]\n    operator: str = \"intersect\"\n\n    def __post_init__(self):\n        allowed_operators = [\"inside\", \"outside\", \"intersect\"]\n        if self.operator not in allowed_operators:\n            raise ValueError(\n                f\"Invalid comparison operator '{self.operator}'. Allowed operators are {', '.join(allowed_operators)}.\"\n            )\n</code></pre>"},{"location":"references/Python%20Client/Schemas/filters/#velour.schemas.filters.ValueFilter","title":"<code>velour.schemas.filters.ValueFilter</code>  <code>dataclass</code>","text":"<p>Used to filter on string or numeric values that meet some user-defined condition.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>Union[int, float, str]</code> <p>The value to compare the specific field against.</p> <code>operator</code> <code>str</code> <p>The operator to use for comparison. Should be one of <code>[\"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\", \"==\", \"!=\"]</code> if the value is an int or float, otherwise should be one of <code>[\"==\", \"!=\"]</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>value</code> isn't of the correct type.</p> <code>ValueError</code> <p>If the <code>operator</code> doesn't match one of the allowed patterns.</p> Source code in <code>client/velour/schemas/filters.py</code> <pre><code>@dataclass\nclass ValueFilter:\n    \"\"\"\n    Used to filter on string or numeric values that meet some user-defined condition.\n\n    Attributes\n    ----------\n    value : Union[int, float, str]\n        The value to compare the specific field against.\n    operator : str\n        The operator to use for comparison. Should be one of `[\"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\", \"==\", \"!=\"]` if the value is an int or float, otherwise should be one of `[\"==\", \"!=\"]`.\n\n    Raises\n    ------\n    TypeError\n        If `value` isn't of the correct type.\n    ValueError\n        If the `operator` doesn't match one of the allowed patterns.\n    \"\"\"\n\n    value: Union[int, float, str]\n    operator: str = \"==\"\n\n    def __post_init__(self):\n        if isinstance(self.value, int) or isinstance(self.value, float):\n            allowed_operators = [\"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\", \"==\", \"!=\"]\n        elif isinstance(self.value, str):\n            allowed_operators = [\"==\", \"!=\"]\n        else:\n            raise TypeError(\n                \"`value` should be of type `int`, `float` or `str`\"\n            )\n        if self.operator not in allowed_operators:\n            raise ValueError(\n                f\"Invalid comparison operator '{self.operator}'. Allowed operators are {', '.join(allowed_operators)}.\"\n            )\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/","title":"Geometries","text":""},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry-classes","title":"Classes","text":""},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BasicPolygon","title":"<code>velour.schemas.geometry.BasicPolygon</code>  <code>dataclass</code>","text":"<p>Class for representing a bounding region.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>(List[Point], optional)</code> <p>List of <code>Point</code> objects representing the vertices of the polygon. Defaults to an empty list.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>points</code> is not a list or an element in <code>points</code> is not a <code>Point</code>.</p> <code>ValueError</code> <p>If the number of unique points in <code>points</code> is less than 3, making the BasicPolygon invalid.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>@dataclass\nclass BasicPolygon:\n    \"\"\"\n    Class for representing a bounding region.\n\n    Attributes\n    ----------\n    points : List[Point], optional\n        List of `Point` objects representing the vertices of the polygon. Defaults to an empty list.\n\n    Raises\n    ------\n    TypeError\n        If `points` is not a list or an element in `points` is not a `Point`.\n    ValueError\n        If the number of unique points in `points` is less than 3,\n        making the BasicPolygon invalid.\n    \"\"\"\n\n    points: List[Point] = field(default_factory=list)\n\n    def __post_init__(self):\n        # unpack &amp; validate\n        if not isinstance(self.points, list):\n            raise TypeError(\"Member `points` is not a list.\")\n        for i in range(len(self.points)):\n            if isinstance(self.points[i], dict):\n                self.points[i] = Point(**self.points[i])\n            if not isinstance(self.points[i], Point):\n                raise TypeError(\"Element in points is not a `Point`.\")\n        if len(set(self.points)) &lt; 3:\n            raise ValueError(\n                \"BasicPolygon needs at least 3 unique points to be valid.\"\n            )\n\n    def xy_list(self) -&gt; List[Point]:\n        \"\"\"\n        Returns a list of `Point` objects representing the vertices of the polygon.\n\n        Returns\n        -------\n        List[Point]\n            List of `Point` objects.\n        \"\"\"\n        return self.points.copy()\n\n    def tuple_list(self) -&gt; List[Tuple[float, float]]:\n        \"\"\"\n        Returns a list of points as tuples (x, y).\n\n        Returns\n        -------\n        List[Tuple[float, float]]\n            List of points as tuples.\n        \"\"\"\n        return [(pt.x, pt.y) for pt in self.points]\n\n    @property\n    def xmin(self):\n        \"\"\"Minimum x-coordinate of the polygon.\"\"\"\n        return min(p.x for p in self.points)\n\n    @property\n    def ymin(self):\n        \"\"\"Minimum y-coordinate of the polygon.\"\"\"\n        return min(p.y for p in self.points)\n\n    @property\n    def xmax(self):\n        \"\"\"Maximum x-coordinate of the polygon.\"\"\"\n        return max(p.x for p in self.points)\n\n    @property\n    def ymax(self):\n        \"\"\"Maximum y-coordinate of the polygon.\"\"\"\n        return max(p.y for p in self.points)\n\n    @classmethod\n    def from_box(cls, box: Box):\n        \"\"\"\n        Create a BasicPolygon from a Box.\n\n        Parameters\n        ----------\n        box : Box\n            The box to convert to a BasicPolygon.\n\n        Returns\n        -------\n        BasicPolygon\n            A BasicPolygon created from the provided Box.\n        \"\"\"\n        return cls(\n            points=[\n                Point(box.min.x, box.min.y),\n                Point(box.min.x, box.max.y),\n                Point(box.max.x, box.max.y),\n                Point(box.max.x, box.min.y),\n            ]\n        )\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BasicPolygon-attributes","title":"Attributes","text":""},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BasicPolygon.xmax","title":"<code>velour.schemas.geometry.BasicPolygon.xmax</code>  <code>property</code>","text":"<p>Maximum x-coordinate of the polygon.</p>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BasicPolygon.xmin","title":"<code>velour.schemas.geometry.BasicPolygon.xmin</code>  <code>property</code>","text":"<p>Minimum x-coordinate of the polygon.</p>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BasicPolygon.ymax","title":"<code>velour.schemas.geometry.BasicPolygon.ymax</code>  <code>property</code>","text":"<p>Maximum y-coordinate of the polygon.</p>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BasicPolygon.ymin","title":"<code>velour.schemas.geometry.BasicPolygon.ymin</code>  <code>property</code>","text":"<p>Minimum y-coordinate of the polygon.</p>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BasicPolygon-functions","title":"Functions","text":""},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BasicPolygon.from_box","title":"<code>velour.schemas.geometry.BasicPolygon.from_box(box)</code>  <code>classmethod</code>","text":"<p>Create a BasicPolygon from a Box.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>Box</code> <p>The box to convert to a BasicPolygon.</p> required <p>Returns:</p> Type Description <code>BasicPolygon</code> <p>A BasicPolygon created from the provided Box.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>@classmethod\ndef from_box(cls, box: Box):\n    \"\"\"\n    Create a BasicPolygon from a Box.\n\n    Parameters\n    ----------\n    box : Box\n        The box to convert to a BasicPolygon.\n\n    Returns\n    -------\n    BasicPolygon\n        A BasicPolygon created from the provided Box.\n    \"\"\"\n    return cls(\n        points=[\n            Point(box.min.x, box.min.y),\n            Point(box.min.x, box.max.y),\n            Point(box.max.x, box.max.y),\n            Point(box.max.x, box.min.y),\n        ]\n    )\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BasicPolygon.tuple_list","title":"<code>velour.schemas.geometry.BasicPolygon.tuple_list()</code>","text":"<p>Returns a list of points as tuples (x, y).</p> <p>Returns:</p> Type Description <code>List[Tuple[float, float]]</code> <p>List of points as tuples.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>def tuple_list(self) -&gt; List[Tuple[float, float]]:\n    \"\"\"\n    Returns a list of points as tuples (x, y).\n\n    Returns\n    -------\n    List[Tuple[float, float]]\n        List of points as tuples.\n    \"\"\"\n    return [(pt.x, pt.y) for pt in self.points]\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BasicPolygon.xy_list","title":"<code>velour.schemas.geometry.BasicPolygon.xy_list()</code>","text":"<p>Returns a list of <code>Point</code> objects representing the vertices of the polygon.</p> <p>Returns:</p> Type Description <code>List[Point]</code> <p>List of <code>Point</code> objects.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>def xy_list(self) -&gt; List[Point]:\n    \"\"\"\n    Returns a list of `Point` objects representing the vertices of the polygon.\n\n    Returns\n    -------\n    List[Point]\n        List of `Point` objects.\n    \"\"\"\n    return self.points.copy()\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BoundingBox","title":"<code>velour.schemas.geometry.BoundingBox</code>  <code>dataclass</code>","text":"<p>Represents a bounding box defined by a 4-point polygon.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>BasicPolygon or dict</code> <p>The 4-point polygon defining the bounding box. Can be a <code>BasicPolygon</code> object or a dictionary with the necessary information to create a <code>BasicPolygon</code>.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>polygon</code> is not a <code>BasicPolygon</code> or cannot be converted to one.</p> <code>ValueError</code> <p>If the number of points in <code>polygon</code> is not equal to 4, making it invalid as a bounding box.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>@dataclass\nclass BoundingBox:\n    \"\"\"\n    Represents a bounding box defined by a 4-point polygon.\n\n    Parameters\n    ----------\n    polygon : BasicPolygon or dict\n        The 4-point polygon defining the bounding box. Can be a `BasicPolygon` object\n        or a dictionary with the necessary information to create a `BasicPolygon`.\n\n    Raises\n    ------\n    TypeError\n        If `polygon` is not a `BasicPolygon` or cannot be converted to one.\n    ValueError\n        If the number of points in `polygon` is not equal to 4, making it invalid as a bounding box.\n    \"\"\"\n\n    polygon: BasicPolygon\n\n    def __post_init__(self):\n        if isinstance(self.polygon, dict):\n            self.polygon = BasicPolygon(**self.polygon)\n        if not isinstance(self.polygon, BasicPolygon):\n            raise TypeError(\n                \"polygon should be of type `velour.schemas.BasicPolygon`\"\n            )\n        if len(self.polygon.points) != 4:\n            raise ValueError(\n                \"Bounding box should be made of a 4-point polygon.\"\n            )\n\n    @classmethod\n    def from_extrema(cls, xmin: float, xmax: float, ymin: float, ymax: float):\n        \"\"\"\n        Create a BoundingBox from extrema values.\n\n        Parameters\n        ----------\n        xmin : float\n            Minimum x-coordinate of the bounding box.\n        xmax : float\n            Maximum x-coordinate of the bounding box.\n        ymin : float\n            Minimum y-coordinate of the bounding box.\n        ymax : float\n            Maximum y-coordinate of the bounding box.\n\n        Returns\n        -------\n        BoundingBox\n            A BoundingBox created from the provided extrema values.\n        \"\"\"\n        return cls(\n            polygon=BasicPolygon(\n                points=[\n                    Point(x=xmin, y=ymin),\n                    Point(x=xmax, y=ymin),\n                    Point(x=xmax, y=ymax),\n                    Point(x=xmin, y=ymax),\n                ]\n            )\n        )\n\n    @property\n    def xmin(self):\n        \"\"\"Minimum x-coordinate of the bounding box.\"\"\"\n        return self.polygon.xmin\n\n    @property\n    def xmax(self):\n        \"\"\"Maximum x-coordinate of the bounding box.\"\"\"\n        return self.polygon.xmax\n\n    @property\n    def ymin(self):\n        \"\"\"Minimum y-coordinate of the bounding box.\"\"\"\n        return self.polygon.ymin\n\n    @property\n    def ymax(self):\n        \"\"\"Maximum y-coordinate of the bounding box.\"\"\"\n        return self.polygon.ymax\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BoundingBox-attributes","title":"Attributes","text":""},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BoundingBox.xmax","title":"<code>velour.schemas.geometry.BoundingBox.xmax</code>  <code>property</code>","text":"<p>Maximum x-coordinate of the bounding box.</p>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BoundingBox.xmin","title":"<code>velour.schemas.geometry.BoundingBox.xmin</code>  <code>property</code>","text":"<p>Minimum x-coordinate of the bounding box.</p>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BoundingBox.ymax","title":"<code>velour.schemas.geometry.BoundingBox.ymax</code>  <code>property</code>","text":"<p>Maximum y-coordinate of the bounding box.</p>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BoundingBox.ymin","title":"<code>velour.schemas.geometry.BoundingBox.ymin</code>  <code>property</code>","text":"<p>Minimum y-coordinate of the bounding box.</p>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BoundingBox-functions","title":"Functions","text":""},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.BoundingBox.from_extrema","title":"<code>velour.schemas.geometry.BoundingBox.from_extrema(xmin, xmax, ymin, ymax)</code>  <code>classmethod</code>","text":"<p>Create a BoundingBox from extrema values.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>Minimum x-coordinate of the bounding box.</p> required <code>xmax</code> <code>float</code> <p>Maximum x-coordinate of the bounding box.</p> required <code>ymin</code> <code>float</code> <p>Minimum y-coordinate of the bounding box.</p> required <code>ymax</code> <code>float</code> <p>Maximum y-coordinate of the bounding box.</p> required <p>Returns:</p> Type Description <code>BoundingBox</code> <p>A BoundingBox created from the provided extrema values.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>@classmethod\ndef from_extrema(cls, xmin: float, xmax: float, ymin: float, ymax: float):\n    \"\"\"\n    Create a BoundingBox from extrema values.\n\n    Parameters\n    ----------\n    xmin : float\n        Minimum x-coordinate of the bounding box.\n    xmax : float\n        Maximum x-coordinate of the bounding box.\n    ymin : float\n        Minimum y-coordinate of the bounding box.\n    ymax : float\n        Maximum y-coordinate of the bounding box.\n\n    Returns\n    -------\n    BoundingBox\n        A BoundingBox created from the provided extrema values.\n    \"\"\"\n    return cls(\n        polygon=BasicPolygon(\n            points=[\n                Point(x=xmin, y=ymin),\n                Point(x=xmax, y=ymin),\n                Point(x=xmax, y=ymax),\n                Point(x=xmin, y=ymax),\n            ]\n        )\n    )\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.Box","title":"<code>velour.schemas.geometry.Box</code>  <code>dataclass</code>","text":"<p>Represents a 2D box defined by minimum and maximum points.</p> <p>Parameters:</p> Name Type Description Default <code>min</code> <code>Union[Point, dict]</code> <p>The minimum point of the box. Can be a <code>Point</code> object or a dictionary with keys 'x' and 'y' representing the coordinates.</p> required <code>max</code> <code>Union[Point, dict]</code> <p>The maximum point of the box. Can be a <code>Point</code> object or a dictionary with keys 'x' and 'y' representing the coordinates.</p> required <p>Attributes:</p> Name Type Description <code>min</code> <code>Point</code> <p>The minimum point of the box.</p> <code>max</code> <code>Point</code> <p>The maximum point of the box.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the x-coordinate of <code>min</code> is greater than the x-coordinate of <code>max</code>. If the y-coordinate of <code>min</code> is greater than the y-coordinate of <code>max</code>.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>@dataclass\nclass Box:\n    \"\"\"\n    Represents a 2D box defined by minimum and maximum points.\n\n    Parameters\n    ----------\n    min : Union[Point, dict]\n        The minimum point of the box. Can be a `Point` object or a dictionary\n        with keys 'x' and 'y' representing the coordinates.\n    max : Union[Point, dict]\n        The maximum point of the box. Can be a `Point` object or a dictionary\n        with keys 'x' and 'y' representing the coordinates.\n\n    Attributes\n    ----------\n    min : Point\n        The minimum point of the box.\n    max : Point\n        The maximum point of the box.\n\n    Raises\n    ------\n    ValueError\n        If the x-coordinate of `min` is greater than the x-coordinate of `max`.\n        If the y-coordinate of `min` is greater than the y-coordinate of `max`.\n    \"\"\"\n\n    min: Point\n    max: Point\n\n    def __post_init__(self):\n        # unpack\n        if isinstance(self.min, dict):\n            self.min = Point(**self.min)\n        if isinstance(self.max, dict):\n            self.max = Point(**self.max)\n\n        # validate\n        if self.min.x &gt; self.max.x:\n            raise ValueError(\"Cannot have xmin &gt; xmax\")\n        if self.min.y &gt; self.max.y:\n            raise ValueError(\"Cannot have ymin &gt; ymax\")\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.MultiPolygon","title":"<code>velour.schemas.geometry.MultiPolygon</code>  <code>dataclass</code>","text":"<p>Represents a collection of polygons.</p> <p>Parameters:</p> Name Type Description Default <code>polygons</code> <code>List[Polygon]</code> <p>List of <code>Polygon</code> objects. Defaults to an empty list.</p> <code>field(default_factory=list)</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>polygons</code> is not a list or an element in <code>polygons</code> is not a <code>Polygon</code>.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>@dataclass\nclass MultiPolygon:\n    \"\"\"\n    Represents a collection of polygons.\n\n    Parameters\n    ----------\n    polygons : List[Polygon], optional\n        List of `Polygon` objects. Defaults to an empty list.\n\n    Raises\n    ------\n    TypeError\n        If `polygons` is not a list or an element in `polygons` is not a `Polygon`.\n    \"\"\"\n\n    polygons: List[Polygon] = field(default_factory=list)\n\n    def __post_init__(self):\n        # unpack &amp; validate\n        if not isinstance(self.polygons, list):\n            raise TypeError(\n                \"polygons should be list of `velour.schemas.Polyon`\"\n            )\n        for i in range(len(self.polygons)):\n            if isinstance(self.polygons[i], dict):\n                self.polygons[i] = Polygon(**self.polygons[i])\n            if not isinstance(self.polygons[i], Polygon):\n                raise TypeError(\n                    \"polygons list should contain elements of type `velour.schemas.Polygon`\"\n                )\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.Point","title":"<code>velour.schemas.geometry.Point</code>  <code>dataclass</code>","text":"<p>Represents a point in 2D space.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[float, int]</code> <p>The x-coordinate of the point.</p> required <code>y</code> <code>Union[float, int]</code> <p>The y-coordinate of the point.</p> required <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>The x-coordinate of the point.</p> <code>y</code> <code>float</code> <p>The y-coordinate of the point.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the coordinates are not of type <code>float</code> or convertible to <code>float</code>.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>@dataclass\nclass Point:\n    \"\"\"\n    Represents a point in 2D space.\n\n    Parameters\n    ----------\n    x : Union[float, int]\n        The x-coordinate of the point.\n    y : Union[float, int]\n        The y-coordinate of the point.\n\n    Attributes\n    ----------\n    x : float\n        The x-coordinate of the point.\n    y : float\n        The y-coordinate of the point.\n\n    Raises\n    ------\n    TypeError\n        If the coordinates are not of type `float` or convertible to `float`.\n    \"\"\"\n\n    x: float\n    y: float\n\n    def __post_init__(self):\n        if isinstance(self.x, int):\n            self.x = float(self.x)\n        if isinstance(self.y, int):\n            self.y = float(self.y)\n\n        if not isinstance(self.x, float):\n            raise TypeError(\"Point coordinates should be `float` type.\")\n        if not isinstance(self.y, float):\n            raise TypeError(\"Point coordinates should be `float` type.\")\n        self.x = float(self.x)\n        self.y = float(self.y)\n\n    def __hash__(self):\n        return hash(f\"{self.x},{self.y}\")\n\n    def resize(\n        self, og_img_h: int, og_img_w: int, new_img_h: int, new_img_w: int\n    ) -&gt; \"Point\":\n        \"\"\"\n        Resize the point coordinates based on the scaling factors.\n\n        Parameters\n        ----------\n        og_img_h : int\n            Original image height.\n        og_img_w : int\n            Original image width.\n        new_img_h : int\n            New image height.\n        new_img_w : int\n            New image width.\n\n        Returns\n        -------\n        Point\n            Resized point based on the scaling factors.\n        \"\"\"\n        h_factor, w_factor = new_img_h / og_img_h, new_img_w / og_img_w\n        return Point(x=w_factor * self.x, y=h_factor * self.y)\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.Point-functions","title":"Functions","text":""},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.Point.resize","title":"<code>velour.schemas.geometry.Point.resize(og_img_h, og_img_w, new_img_h, new_img_w)</code>","text":"<p>Resize the point coordinates based on the scaling factors.</p> <p>Parameters:</p> Name Type Description Default <code>og_img_h</code> <code>int</code> <p>Original image height.</p> required <code>og_img_w</code> <code>int</code> <p>Original image width.</p> required <code>new_img_h</code> <code>int</code> <p>New image height.</p> required <code>new_img_w</code> <code>int</code> <p>New image width.</p> required <p>Returns:</p> Type Description <code>Point</code> <p>Resized point based on the scaling factors.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>def resize(\n    self, og_img_h: int, og_img_w: int, new_img_h: int, new_img_w: int\n) -&gt; \"Point\":\n    \"\"\"\n    Resize the point coordinates based on the scaling factors.\n\n    Parameters\n    ----------\n    og_img_h : int\n        Original image height.\n    og_img_w : int\n        Original image width.\n    new_img_h : int\n        New image height.\n    new_img_w : int\n        New image width.\n\n    Returns\n    -------\n    Point\n        Resized point based on the scaling factors.\n    \"\"\"\n    h_factor, w_factor = new_img_h / og_img_h, new_img_w / og_img_w\n    return Point(x=w_factor * self.x, y=h_factor * self.y)\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.Polygon","title":"<code>velour.schemas.geometry.Polygon</code>  <code>dataclass</code>","text":"<p>Represents a polygon with a boundary and optional holes.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>BasicPolygon or dict</code> <p>The outer boundary of the polygon. Can be a <code>BasicPolygon</code> object or a dictionary with the necessary information to create a <code>BasicPolygon</code>.</p> required <code>holes</code> <code>List[BasicPolygon]</code> <p>List of holes inside the polygon. Defaults to an empty list.</p> <code>field(default_factory=list)</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>boundary</code> is not a <code>BasicPolygon</code> or cannot be converted to one. If <code>holes</code> is not a list or an element in <code>holes</code> is not a <code>BasicPolygon</code>.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>@dataclass\nclass Polygon:\n    \"\"\"\n    Represents a polygon with a boundary and optional holes.\n\n    Parameters\n    ----------\n    boundary : BasicPolygon or dict\n        The outer boundary of the polygon. Can be a `BasicPolygon` object or a\n        dictionary with the necessary information to create a `BasicPolygon`.\n    holes : List[BasicPolygon], optional\n        List of holes inside the polygon. Defaults to an empty list.\n\n    Raises\n    ------\n    TypeError\n        If `boundary` is not a `BasicPolygon` or cannot be converted to one.\n        If `holes` is not a list or an element in `holes` is not a `BasicPolygon`.\n    \"\"\"\n\n    boundary: BasicPolygon\n    holes: List[BasicPolygon] = field(default_factory=list)\n\n    def __post_init__(self):\n        # unpack &amp; validate\n        if isinstance(self.boundary, dict):\n            self.boundary = BasicPolygon(**self.boundary)\n        if not isinstance(self.boundary, BasicPolygon):\n            raise TypeError(\n                \"boundary should be of type `velour.schemas.BasicPolygon`\"\n            )\n        if self.holes:\n            if not isinstance(self.holes, list):\n                raise TypeError(\n                    f\"holes should be a list of `velour.schemas.BasicPolygon`. Got `{type(self.holes)}`.\"\n                )\n            for i in range(len(self.holes)):\n                if isinstance(self.holes[i], dict):\n                    self.holes[i] = BasicPolygon(**self.holes[i])\n                if not isinstance(self.holes[i], BasicPolygon):\n                    raise TypeError(\n                        \"holes list should contain elements of type `velour.schemas.BasicPolygon`\"\n                    )\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.Raster","title":"<code>velour.schemas.geometry.Raster</code>  <code>dataclass</code>","text":"<p>Represents a raster image or binary mask.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>str</code> <p>Base64-encoded string representing the raster mask.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>mask</code> is not a string.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>@dataclass\nclass Raster:\n    \"\"\"\n    Represents a raster image or binary mask.\n\n    Parameters\n    ----------\n    mask : str\n        Base64-encoded string representing the raster mask.\n\n    Raises\n    ------\n    TypeError\n        If `mask` is not a string.\n    \"\"\"\n\n    mask: str\n\n    def __post_init__(self):\n        if not isinstance(self.mask, str):\n            raise TypeError(\"mask should be of type `str`\")\n\n    @classmethod\n    def from_numpy(cls, mask: np.ndarray):\n        \"\"\"\n        Create a Raster object from a NumPy array.\n\n        Parameters\n        ----------\n        mask : np.ndarray\n            The 2D binary array representing the mask.\n\n        Returns\n        -------\n        Raster\n            A Raster object created from the provided NumPy array.\n\n        Raises\n        ------\n        ValueError\n            If the input array is not 2D or not of dtype bool.\n        \"\"\"\n        if len(mask.shape) != 2:\n            raise ValueError(\"raster currently only supports 2d arrays\")\n        if mask.dtype != bool:\n            raise ValueError(\n                f\"Expecting a binary mask (i.e. of dtype bool) but got dtype {mask.dtype}\"\n            )\n        f = io.BytesIO()\n        PIL.Image.fromarray(mask).save(f, format=\"PNG\")\n        f.seek(0)\n        mask_bytes = f.read()\n        f.close()\n        return cls(\n            mask=b64encode(mask_bytes).decode(),\n        )\n\n    def to_numpy(self) -&gt; np.ndarray:\n        \"\"\"\n        Convert the base64-encoded mask to a NumPy array.\n\n        Returns\n        -------\n        np.ndarray\n            A 2D binary array representing the mask.\n        \"\"\"\n        mask_bytes = b64decode(self.mask)\n        with io.BytesIO(mask_bytes) as f:\n            img = PIL.Image.open(f)\n            return np.array(img)\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.Raster-functions","title":"Functions","text":""},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.Raster.from_numpy","title":"<code>velour.schemas.geometry.Raster.from_numpy(mask)</code>  <code>classmethod</code>","text":"<p>Create a Raster object from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>The 2D binary array representing the mask.</p> required <p>Returns:</p> Type Description <code>Raster</code> <p>A Raster object created from the provided NumPy array.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input array is not 2D or not of dtype bool.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>@classmethod\ndef from_numpy(cls, mask: np.ndarray):\n    \"\"\"\n    Create a Raster object from a NumPy array.\n\n    Parameters\n    ----------\n    mask : np.ndarray\n        The 2D binary array representing the mask.\n\n    Returns\n    -------\n    Raster\n        A Raster object created from the provided NumPy array.\n\n    Raises\n    ------\n    ValueError\n        If the input array is not 2D or not of dtype bool.\n    \"\"\"\n    if len(mask.shape) != 2:\n        raise ValueError(\"raster currently only supports 2d arrays\")\n    if mask.dtype != bool:\n        raise ValueError(\n            f\"Expecting a binary mask (i.e. of dtype bool) but got dtype {mask.dtype}\"\n        )\n    f = io.BytesIO()\n    PIL.Image.fromarray(mask).save(f, format=\"PNG\")\n    f.seek(0)\n    mask_bytes = f.read()\n    f.close()\n    return cls(\n        mask=b64encode(mask_bytes).decode(),\n    )\n</code></pre>"},{"location":"references/Python%20Client/Schemas/geometries/#velour.schemas.geometry.Raster.to_numpy","title":"<code>velour.schemas.geometry.Raster.to_numpy()</code>","text":"<p>Convert the base64-encoded mask to a NumPy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>A 2D binary array representing the mask.</p> Source code in <code>client/velour/schemas/geometry.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n    \"\"\"\n    Convert the base64-encoded mask to a NumPy array.\n\n    Returns\n    -------\n    np.ndarray\n        A 2D binary array representing the mask.\n    \"\"\"\n    mask_bytes = b64decode(self.mask)\n    with io.BytesIO(mask_bytes) as f:\n        img = PIL.Image.open(f)\n        return np.array(img)\n</code></pre>"}]}