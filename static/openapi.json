{"openapi": "3.1.0", "info": {"title": "FastAPI", "version": "0.1.0"}, "paths": {"/groundtruths": {"post": {"tags": ["GroundTruths"], "summary": "Create Groundtruths", "description": "Create a ground truth in the database.\n\nPOST Endpoint: `/groundtruths`\n\nParameters\n----------\ngroundtruths : list[schemas.GroundTruth]\n    The ground truths to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\nignore_existing_datums : bool, optional\n    If True, will ignore datums that already exist in the database.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.\nHTTPException (409)\n    If the dataset has been finalized, or if the datum already exists.", "operationId": "create_groundtruths_groundtruths_post", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "ignore_existing_datums", "in": "query", "required": false, "schema": {"type": "boolean", "default": false, "title": "Ignore Existing Datums"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/GroundTruth-Input"}, "title": "Groundtruths"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/groundtruths/dataset/{dataset_name}/datum/{uid}": {"get": {"tags": ["GroundTruths"], "summary": "Get Groundtruth", "description": "Fetch a ground truth from the database.\n\nGET Endpoint: `/groundtruths/dataset/{dataset_name}/datum/{uid}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset to fetch the ground truth from.\nuid : str\n    The UID of the ground truth.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.GroundTruth\n    Thee ground truth requested by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum does not exist.", "operationId": "get_groundtruth_groundtruths_dataset__dataset_name__datum__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/GroundTruth-Output"}, {"type": "null"}], "title": "Response Get Groundtruth Groundtruths Dataset  Dataset Name  Datum  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/predictions": {"post": {"tags": ["Predictions"], "summary": "Create Predictions", "description": "Create a prediction in the database.\n\nPOST Endpoint: `/predictions`\n\nParameters\n----------\npredictions : list[schemas.Prediction]\n    The predictions to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset, model, or datum doesn't exist.\nHTTPException (409)\n    If the model has been finalized, or if the dataset has not been finalized.", "operationId": "create_predictions_predictions_post", "requestBody": {"content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Prediction-Input"}, "type": "array", "title": "Predictions"}}}, "required": true}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/predictions/model/{model_name}/dataset/{dataset_name}/datum/{uid}": {"get": {"tags": ["Predictions"], "summary": "Get Prediction", "description": "Fetch a prediction from the database.\n\nGET Endpoint: `/predictions/model/{model_name}/dataset/{dataset_name}/datum/{uid}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model associated with the prediction.\ndataset_name : str\n    The name of the dataset associated with the prediction.\nuid : str\n    The UID associated with the prediction.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Prediction\n    The requested prediction.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.", "operationId": "get_prediction_predictions_model__model_name__dataset__dataset_name__datum__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}, {"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Prediction-Output"}, {"type": "null"}], "title": "Response Get Prediction Predictions Model  Model Name  Dataset  Dataset Name  Datum  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/labels": {"get": {"tags": ["Labels"], "summary": "Get Labels", "description": "Fetch labels using optional JSON strings as query parameters.", "operationId": "get_labels_labels_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "offset", "in": "query", "required": false, "schema": {"type": "integer", "default": 0, "title": "Offset"}}, {"name": "limit", "in": "query", "required": false, "schema": {"type": "integer", "default": -1, "title": "Limit"}}, {"name": "dataset_names", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Dataset Names"}}, {"name": "dataset_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Dataset Metadata"}}, {"name": "model_names", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Model Names"}}, {"name": "model_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Model Metadata"}}, {"name": "datum_uids", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Datum Uids"}}, {"name": "datum_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Datum Metadata"}}, {"name": "task_types", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Task Types"}}, {"name": "annotation_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Annotation Metadata"}}, {"name": "require_bounding_box", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Bounding Box"}}, {"name": "bounding_box_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Bounding Box Area"}}, {"name": "require_polygon", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Polygon"}}, {"name": "polygon_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Polygon Area"}}, {"name": "require_raster", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Raster"}}, {"name": "raster_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Raster Area"}}, {"name": "labels", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Labels"}}, {"name": "label_ids", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Ids"}}, {"name": "label_keys", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Keys"}}, {"name": "label_scores", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Scores"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Label"}, "title": "Response Get Labels Labels Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/labels/dataset/{dataset_name}": {"get": {"tags": ["Labels"], "summary": "Get Labels From Dataset", "description": "Fetch all labels for a particular dataset from the database.\n\nGET Endpoint: `/labels/dataset/{dataset_name}`\n\nParameters\n----------\nresponse: Response\n    The FastAPI response object. Used to return a content-range header to the user.\ndataset_name : str\n    The name of the dataset.\noffset : int, optional\n    The start index of the items to return.\nlimit : int, optional\n    The number of items to return. Returns all items when set to -1. Returns all items when set to -1.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user\n-------\nlist[schemas.Label]\n    A list of all labels associated with the dataset in the database.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_labels_from_dataset_labels_dataset__dataset_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "offset", "in": "query", "required": false, "schema": {"type": "integer", "default": 0, "title": "Offset"}}, {"name": "limit", "in": "query", "required": false, "schema": {"type": "integer", "default": -1, "title": "Limit"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Label"}, "title": "Response Get Labels From Dataset Labels Dataset  Dataset Name  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/labels/model/{model_name}": {"get": {"tags": ["Labels"], "summary": "Get Labels From Model", "description": "Fetch all labels for a particular model from the database.\n\nGET Endpoint: `/labels/model/{model_name}`\n\nParameters\n----------\nresponse: Response\n    The FastAPI response object. Used to return a content-range header to the user.\nmodel_name : str\n    The name of the model.\noffset : int, optional\n    The start index of the items to return.\nlimit : int, optional\n    The number of items to return. Returns all items when set to -1.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[schemas.Label]\n    A list of all labels associated with the model in the database.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.", "operationId": "get_labels_from_model_labels_model__model_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}, {"name": "offset", "in": "query", "required": false, "schema": {"type": "integer", "default": 0, "title": "Offset"}}, {"name": "limit", "in": "query", "required": false, "schema": {"type": "integer", "default": -1, "title": "Limit"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Label"}, "title": "Response Get Labels From Model Labels Model  Model Name  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets": {"post": {"tags": ["Datasets"], "summary": "Create Dataset", "description": "Create a dataset in the database.\n\nPOST Endpoint: `/datasets`\n\nParameters\n----------\ndataset : schemas.Dataset\n    The dataset to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (409)\n    If the dataset already exists.", "operationId": "create_dataset_datasets_post", "security": [{"OptionalHTTPBearer": []}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Dataset"}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "get": {"tags": ["Datasets"], "summary": "Get Datasets", "description": "Fetch datasets using optional JSON strings as query parameters.", "operationId": "get_datasets_datasets_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "offset", "in": "query", "required": false, "schema": {"type": "integer", "default": 0, "title": "Offset"}}, {"name": "limit", "in": "query", "required": false, "schema": {"type": "integer", "default": -1, "title": "Limit"}}, {"name": "dataset_names", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Dataset Names"}}, {"name": "dataset_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Dataset Metadata"}}, {"name": "model_names", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Model Names"}}, {"name": "model_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Model Metadata"}}, {"name": "datum_uids", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Datum Uids"}}, {"name": "datum_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Datum Metadata"}}, {"name": "task_types", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Task Types"}}, {"name": "annotation_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Annotation Metadata"}}, {"name": "require_bounding_box", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Bounding Box"}}, {"name": "bounding_box_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Bounding Box Area"}}, {"name": "require_polygon", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Polygon"}}, {"name": "polygon_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Polygon Area"}}, {"name": "require_raster", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Raster"}}, {"name": "raster_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Raster Area"}}, {"name": "labels", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Labels"}}, {"name": "label_ids", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Ids"}}, {"name": "label_keys", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Keys"}}, {"name": "label_scores", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Scores"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Dataset"}, "title": "Response Get Datasets Datasets Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}": {"get": {"tags": ["Datasets"], "summary": "Get Dataset", "description": "Fetch a particular dataset from the database.\n\nGET Endpoint: `/datasets/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Dataset\n    The requested dataset.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_dataset_datasets__dataset_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Dataset"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Datasets"], "summary": "Delete Dataset", "description": "Delete a dataset from the database.\n\nDELETE Endpoint: `/datasets/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nbackground_tasks: BackgroundTasks\n    A FastAPI `BackgroundTasks` object to process the deletion asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.\nHTTPException (409)\n    If the dataset isn't in the correct state to be deleted.", "operationId": "delete_dataset_datasets__dataset_name__delete", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}/status": {"get": {"tags": ["Datasets"], "summary": "Get Dataset Status", "description": "Fetch the status of a dataset.\n\nGET Endpoint: `/datasets/{dataset_name}/status`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nenums.TableStatus\n    The requested state.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_dataset_status_datasets__dataset_name__status_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TableStatus"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}/summary": {"get": {"tags": ["Datasets"], "summary": "Get Dataset Summary", "description": "Get the summary of a dataset.\n\nGET Endpoint: `/datasets/{dataset_name}/summary`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.DatasetSummary\n    The dataset summary.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_dataset_summary_datasets__dataset_name__summary_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DatasetSummary"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}/finalize": {"put": {"tags": ["Datasets"], "summary": "Finalize Dataset", "description": "Finalizes a dataset for evaluation.\n\nPUT Endpoint: `/datasets/{dataset_name}/finalize`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (409)\n    If the dataset is empty.\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "finalize_dataset_datasets__dataset_name__finalize_put", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/data": {"get": {"tags": ["Datums"], "summary": "Get Datums", "description": "Fetch datums using optional JSON strings as query parameters.", "operationId": "get_datums_data_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "offset", "in": "query", "required": false, "schema": {"type": "integer", "default": 0, "title": "Offset"}}, {"name": "limit", "in": "query", "required": false, "schema": {"type": "integer", "default": -1, "title": "Limit"}}, {"name": "dataset_names", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Dataset Names"}}, {"name": "dataset_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Dataset Metadata"}}, {"name": "model_names", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Model Names"}}, {"name": "model_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Model Metadata"}}, {"name": "datum_uids", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Datum Uids"}}, {"name": "datum_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Datum Metadata"}}, {"name": "task_types", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Task Types"}}, {"name": "annotation_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Annotation Metadata"}}, {"name": "require_bounding_box", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Bounding Box"}}, {"name": "bounding_box_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Bounding Box Area"}}, {"name": "require_polygon", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Polygon"}}, {"name": "polygon_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Polygon Area"}}, {"name": "require_raster", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Raster"}}, {"name": "raster_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Raster Area"}}, {"name": "labels", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Labels"}}, {"name": "label_ids", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Ids"}}, {"name": "label_keys", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Keys"}}, {"name": "label_scores", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Scores"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Datum"}, "title": "Response Get Datums Data Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/data/dataset/{dataset_name}/uid/{uid}": {"get": {"tags": ["Datums"], "summary": "Get Datum", "description": "Fetch a particular datum.\nGET Endpoint: `/data/dataset/{dataset_name}/uid/{uid}`\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nuid : str\n    The UID of the datum.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\nReturns\n-------\nschemas.Datum\n    The requested datum.\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.", "operationId": "get_datum_data_dataset__dataset_name__uid__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Datum"}, {"type": "null"}], "title": "Response Get Datum Data Dataset  Dataset Name  Uid  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models": {"post": {"tags": ["Models"], "summary": "Create Model", "description": "Create a model in the database.\n\nPOST Endpoint: `/models`\n\nParameters\n----------\nmodel : schemas.Model\n    The model to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.\nHTTPException (409)\n    If the dataset has been finalized, or if the datum already exists.", "operationId": "create_model_models_post", "security": [{"OptionalHTTPBearer": []}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Model"}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "get": {"tags": ["Models"], "summary": "Get Models", "description": "Fetch models using optional JSON strings as query parameters.", "operationId": "get_models_models_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "offset", "in": "query", "required": false, "schema": {"type": "integer", "default": 0, "title": "Offset"}}, {"name": "limit", "in": "query", "required": false, "schema": {"type": "integer", "default": -1, "title": "Limit"}}, {"name": "dataset_names", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Dataset Names"}}, {"name": "dataset_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Dataset Metadata"}}, {"name": "model_names", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Model Names"}}, {"name": "model_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Model Metadata"}}, {"name": "datum_uids", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Datum Uids"}}, {"name": "datum_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Datum Metadata"}}, {"name": "task_types", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Task Types"}}, {"name": "annotation_metadata", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Annotation Metadata"}}, {"name": "require_bounding_box", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Bounding Box"}}, {"name": "bounding_box_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Bounding Box Area"}}, {"name": "require_polygon", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Polygon"}}, {"name": "polygon_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Polygon Area"}}, {"name": "require_raster", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Require Raster"}}, {"name": "raster_area", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Raster Area"}}, {"name": "labels", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Labels"}}, {"name": "label_ids", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Ids"}}, {"name": "label_keys", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Keys"}}, {"name": "label_scores", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Label Scores"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Model"}, "title": "Response Get Models Models Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models/{model_name}": {"get": {"tags": ["Models"], "summary": "Get Model", "description": "Fetch a particular model.\n\nGET Endpoint: `/models/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Model\n    The requested model.\n\nRaises\n------\nHTTPException (404)\n    If the model datum doesn't exist.", "operationId": "get_model_models__model_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Model"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Models"], "summary": "Delete Model", "description": "Delete a model from the database.\n\nDELETE Endpoint: `/models/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.\nHTTPException (409)\n    If the model isn't in the correct state to be deleted.", "operationId": "delete_model_models__model_name__delete", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models/{model_name}/eval-requests": {"get": {"tags": ["Models"], "summary": "Get Model Eval Requests", "description": "Fetch a particular model.\n\nGET Endpoint: `/models/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[EvaluationResponse]\n    The evaluation requessts associated to the model\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.", "operationId": "get_model_eval_requests_models__model_name__eval_requests_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/EvaluationResponse"}, "title": "Response Get Model Eval Requests Models  Model Name  Eval Requests Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models/{model_name}/dataset/{dataset_name}/status": {"get": {"tags": ["Models"], "summary": "Get Model Status", "description": "Fetch the status of a model over a dataset.\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nenums.TableStatus\n    The requested state.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.", "operationId": "get_model_status_models__model_name__dataset__dataset_name__status_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TableStatus"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models/{model_name}/datasets/{dataset_name}/finalize": {"put": {"tags": ["Models"], "summary": "Finalize Inferences", "description": "Finalize a model prior to evaluation.\n\nPUT Endpoint: `/models/{model_name}/datasets/{dataset_name}/finalize`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n\nRaises\n------\nHTTPException (400)\n    If the dataset or model are empty.\nHTTPException (404)\n    If the dataset or model do not exist.", "operationId": "finalize_inferences_models__model_name__datasets__dataset_name__finalize_put", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/evaluations": {"post": {"tags": ["Evaluations"], "summary": "Create Or Get Evaluations", "description": "Create a new evaluation.\n\nPOST Endpoint: `/evaluations`\n\nParameters\n----------\nresponse: Response\n    The FastAPI response object. Used to return a content-range header to the user.\njob_request: schemas.EvaluationJob\n    The job request for the evaluation.\nbackground_tasks: BackgroundTasks\n    A FastAPI `BackgroundTasks` object to process the creation asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.\nallow_retries: bool, default = False\n    Determines whether failed evaluations are restarted.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[schemas.EvaluationResponse]\n    A list of evaluation response objects.\n\nRaises\n------\nHTTPException (400)\n    If the task type of the evaluation job doesn't exist, or if another ValueError is thrown.\nHTTPException (404)\n    If the dataset or model does not exist.\nHTTPException (405)\n    If the dataset or model hasn't been finalized.\nHTTPException (409)\n    If there is a state exception when creating the evaluation.", "operationId": "create_or_get_evaluations_evaluations_post", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "allow_retries", "in": "query", "required": false, "schema": {"type": "boolean", "default": false, "title": "Allow Retries"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EvaluationRequest"}}}}, "responses": {"202": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/EvaluationResponse"}, "title": "Response Create Or Get Evaluations Evaluations Post"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "get": {"tags": ["Evaluations"], "summary": "Get Evaluations", "description": "Fetch all metrics associated with user-supplied dataset and model names. Users\nmay query using model names, dataset names, or both. All metrics for all specified\nmodels and datasets will be returned in a list of Evaluations.\n\nThis endpoint can handle multiple dataset and model names. For example, you can use\n`/evaluations?models=first_model,second_model&datasets=test_dataset` to get all evaluations\nrelated to `test_dataset` and either `first_model` or `second_model`.\n\nGET Endpoint: `/evaluations`\n\nParameters\n----------\nresponse: Response\n    The FastAPI response object. Used to return a content-range header to the user.\ndatasets : str\n    An optional set of dataset names to return metrics for\nmodels : str\n    An optional set of model names to return metrics for\nevaluation_ids : str\n    An optional set of evaluation_ids to return metrics for\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\noffset : int, optional\n    The start index of the items to return.\nlimit : int, optional\n    The number of items to return. Returns all items when set to -1.\nmetrics_to_sort_by: str, optional\n    An optional dict of metric types to sort the evaluations by.\n\nReturns\n-------\nlist[schemas.Evaluation]\n    A list of evaluations.\n\nRaises\n------\nHTTPException (400)\n    If a ValueError is thrown.\nHTTPException (404)\n    If the dataset or model doesn't exist.", "operationId": "get_evaluations_evaluations_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "datasets", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Datasets"}}, {"name": "models", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Models"}}, {"name": "evaluation_ids", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Evaluation Ids"}}, {"name": "offset", "in": "query", "required": false, "schema": {"type": "integer", "default": 0, "title": "Offset"}}, {"name": "limit", "in": "query", "required": false, "schema": {"type": "integer", "default": -1, "title": "Limit"}}, {"name": "metrics_to_sort_by", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Metrics To Sort By"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/EvaluationResponse"}, "title": "Response Get Evaluations Evaluations Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/evaluations/{evaluation_id}": {"delete": {"tags": ["Evaluations"], "summary": "Delete Evaluation", "description": "Delete a evaluation from the database.\n\nDELETE Endpoint: `/evaluations/{evaluation_id}`\n\nParameters\n----------\nevaluation_id : int\n    The evaluation identifier.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the evaluation doesn't exist.\nHTTPException (409)\n    If the evaluation isn't in the correct state to be deleted.", "operationId": "delete_evaluation_evaluations__evaluation_id__delete", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "evaluation_id", "in": "path", "required": true, "schema": {"type": "integer", "title": "Evaluation Id"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/token": {"post": {"tags": ["Authentication"], "summary": "Login For Access Token", "operationId": "login_for_access_token_token_post", "requestBody": {"content": {"application/x-www-form-urlencoded": {"schema": {"$ref": "#/components/schemas/Body_login_for_access_token_token_post"}}}, "required": true}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "string", "title": "Response Login For Access Token Token Post"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/api-version": {"get": {"tags": ["Info"], "summary": "Get Api Version", "description": "Return the API's version.\n\nGET Endpoint: `/api-version`\n\nReturns\n-------\nschemas.APIVersion\n    A response object containing the API's version number.", "operationId": "get_api_version_api_version_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/APIVersion"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/health": {"get": {"tags": ["Status"], "summary": "Health", "description": "Return 200 if the service is up.\n\nGET Endpoint: `/health`\n\nReturns\n-------\nschemas.Health\n    A response indicating that the service is up and running.", "operationId": "health_health_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}}}}, "/ready": {"get": {"tags": ["Status"], "summary": "Ready", "description": "Return 200 if the service is up and connected to the database.\n\nGET Endpoint: `/ready`\n\nReturns\n-------\nschemas.Readiness\n    A response indicating that the service is up and connected to the database.", "operationId": "ready_ready_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}}}}}, "components": {"schemas": {"APIVersion": {"properties": {"api_version": {"type": "string", "title": "Api Version"}}, "type": "object", "required": ["api_version"], "title": "APIVersion", "description": "Defines an API version string which is sent back to the user after their authentication is confirmed.\n\nAttributes\n----------\napi_version : str\n    The API version."}, "Annotation-Input": {"properties": {"metadata": {"additionalProperties": {"anyOf": [{"type": "boolean"}, {"type": "integer"}, {"type": "number"}, {"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"type": "number"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}, "labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Labels", "default": []}, "bounding_box": {"anyOf": [{"$ref": "#/components/schemas/Box"}, {"type": "null"}]}, "polygon": {"anyOf": [{"$ref": "#/components/schemas/Polygon"}, {"type": "null"}]}, "raster": {"anyOf": [{"$ref": "#/components/schemas/Raster"}, {"type": "null"}]}, "embedding": {"anyOf": [{"items": {"type": "number"}, "type": "array"}, {"type": "null"}], "title": "Embedding"}, "is_instance": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Is Instance"}, "implied_task_types": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Implied Task Types"}}, "additionalProperties": false, "type": "object", "title": "Annotation", "description": "A class used to annotate 'GroundTruths' and 'Predictions'.\n\nAttributes\n----------\nmetadata: dict, optional\n    A dictionary of metadata that describes the 'Annotation'.\nlabels: List[Label], optional\n    A list of labels to use for the 'Annotation'.\nbounding_box: BoundingBox, optional\n    A bounding box to assign to the 'Annotation'.\npolygon: Polygon, optional\n    A polygon to assign to the 'Annotation'.\nraster: Raster, optional\n    A raster to assign to the 'Annotation'.\nembedding: list[float], optional\n    A jsonb to assign to the 'Annotation'.\nis_instance: bool, optional\n    A boolean describing whether we should treat the Raster attached to an annotation as an instance segmentation or not. If set to true, then the Annotation will be validated for use in object detection tasks. If set to false, then the Annotation will be validated for use in semantic segmentation tasks.\nimplied_task_types: list[str], optional\n    The validated task types that are applicable to each Annotation. Doesn't need to bet set by the user."}, "Annotation-Output": {"properties": {"metadata": {"additionalProperties": {"anyOf": [{"type": "boolean"}, {"type": "integer"}, {"type": "number"}, {"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"type": "number"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}, "labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Labels", "default": []}, "bounding_box": {"anyOf": [{"type": "object"}, {"type": "null"}]}, "polygon": {"anyOf": [{"type": "object"}, {"type": "null"}]}, "raster": {"anyOf": [{"type": "object"}, {"type": "null"}]}, "embedding": {"anyOf": [{"items": {"type": "number"}, "type": "array"}, {"type": "null"}], "title": "Embedding"}, "is_instance": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Is Instance"}, "implied_task_types": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Implied Task Types"}}, "additionalProperties": false, "type": "object", "title": "Annotation", "description": "A class used to annotate 'GroundTruths' and 'Predictions'.\n\nAttributes\n----------\nmetadata: dict, optional\n    A dictionary of metadata that describes the 'Annotation'.\nlabels: List[Label], optional\n    A list of labels to use for the 'Annotation'.\nbounding_box: BoundingBox, optional\n    A bounding box to assign to the 'Annotation'.\npolygon: Polygon, optional\n    A polygon to assign to the 'Annotation'.\nraster: Raster, optional\n    A raster to assign to the 'Annotation'.\nembedding: list[float], optional\n    A jsonb to assign to the 'Annotation'.\nis_instance: bool, optional\n    A boolean describing whether we should treat the Raster attached to an annotation as an instance segmentation or not. If set to true, then the Annotation will be validated for use in object detection tasks. If set to false, then the Annotation will be validated for use in semantic segmentation tasks.\nimplied_task_types: list[str], optional\n    The validated task types that are applicable to each Annotation. Doesn't need to bet set by the user."}, "AnnotationType": {"type": "string", "enum": ["none", "box", "polygon", "multipolygon", "raster"], "title": "AnnotationType"}, "Body_login_for_access_token_token_post": {"properties": {"grant_type": {"anyOf": [{"type": "string", "pattern": "password"}, {"type": "null"}], "title": "Grant Type"}, "username": {"type": "string", "title": "Username"}, "password": {"type": "string", "title": "Password"}, "scope": {"type": "string", "title": "Scope", "default": ""}, "client_id": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Client Id"}, "client_secret": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Client Secret"}}, "type": "object", "required": ["username", "password"], "title": "Body_login_for_access_token_token_post"}, "BooleanFilter": {"properties": {"value": {"type": "boolean", "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "BooleanFilter", "description": "Used to filter on boolean values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : bool\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "Box": {"properties": {"value": {"items": {"items": {"prefixItems": [{"anyOf": [{"type": "integer"}, {"type": "number"}]}, {"anyOf": [{"type": "integer"}, {"type": "number"}]}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array", "title": "Value"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "Box", "description": "Describes a Box in (x,y) coordinates.\n\nAttributes\n----------\nvalue : list[list[tuple[int | float, int | float]]]\n    A list of coordinates describing the Box.\n\nRaises\n------\nValueError\n    If the value doesn't conform to the type."}, "ConfusionMatrixEntry": {"properties": {"prediction": {"type": "string", "title": "Prediction"}, "groundtruth": {"type": "string", "title": "Groundtruth"}, "count": {"type": "integer", "title": "Count"}}, "type": "object", "required": ["prediction", "groundtruth", "count"], "title": "ConfusionMatrixEntry", "description": "Describes one element in a confusion matrix.\n\nAttributes\n----------\nprediction : str\n    The prediction.\ngroundtruth : str\n    The ground truth.\ncount : int\n    The value of the element in the matrix."}, "ConfusionMatrixResponse": {"properties": {"label_key": {"type": "string", "title": "Label Key"}, "entries": {"items": {"$ref": "#/components/schemas/ConfusionMatrixEntry"}, "type": "array", "title": "Entries"}}, "type": "object", "required": ["label_key", "entries"], "title": "ConfusionMatrixResponse", "description": "A response object used for HTTP responses since they won't contain matrix or label map attributes."}, "Dataset": {"properties": {"name": {"type": "string", "title": "Name"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "boolean"}, {"type": "integer"}, {"type": "number"}, {"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"type": "number"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}}, "additionalProperties": false, "type": "object", "required": ["name"], "title": "Dataset", "description": "A class describing a given dataset.\n\nAttributes\n----------\nname : str\n    The name of the dataset.\nmetadata : dict, optional\n    A dictionary of metadata that describes the dataset."}, "DatasetSummary": {"properties": {"name": {"type": "string", "title": "Name"}, "num_datums": {"type": "integer", "title": "Num Datums"}, "num_annotations": {"type": "integer", "title": "Num Annotations"}, "num_bounding_boxes": {"type": "integer", "title": "Num Bounding Boxes"}, "num_polygons": {"type": "integer", "title": "Num Polygons"}, "num_rasters": {"type": "integer", "title": "Num Rasters"}, "task_types": {"items": {"$ref": "#/components/schemas/TaskType"}, "type": "array", "title": "Task Types"}, "labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Labels"}, "datum_metadata": {"items": {"additionalProperties": {"anyOf": [{"type": "boolean"}, {"type": "integer"}, {"type": "number"}, {"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"type": "number"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object"}, "type": "array", "title": "Datum Metadata"}, "annotation_metadata": {"items": {"additionalProperties": {"anyOf": [{"type": "boolean"}, {"type": "integer"}, {"type": "number"}, {"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"type": "number"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object"}, "type": "array", "title": "Annotation Metadata"}}, "type": "object", "required": ["name", "num_datums", "num_annotations", "num_bounding_boxes", "num_polygons", "num_rasters", "task_types", "labels", "datum_metadata", "annotation_metadata"], "title": "DatasetSummary"}, "Date": {"properties": {"value": {"type": "string", "title": "Value"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "Date", "description": "An object describing a date.\n\nAttributes\n----------\nvalue : str\n    Date in ISO format."}, "DateTime": {"properties": {"value": {"type": "string", "title": "Value"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "DateTime", "description": "An object describing a date and time.\n\nAttributes\n----------\nvalue : str\n    Datetime in ISO format."}, "DateTimeFilter": {"properties": {"value": {"anyOf": [{"$ref": "#/components/schemas/DateTime"}, {"$ref": "#/components/schemas/Date"}, {"$ref": "#/components/schemas/Time"}, {"$ref": "#/components/schemas/Duration"}], "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "DateTimeFilter", "description": "Used to filter on datetime values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : DateTime\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\">\", \"<\", \">=\", \"<=\", \"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "Datum": {"properties": {"uid": {"type": "string", "title": "Uid"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "boolean"}, {"type": "integer"}, {"type": "number"}, {"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"type": "number"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}}, "additionalProperties": false, "type": "object", "required": ["uid"], "title": "Datum", "description": "A class used to store datum information about 'GroundTruths' and 'Predictions'.\n\nAttributes\n----------\nuid : str\n    The UID of the datum.\nmetadata : dict, optional\n    A dictionary of metadata that describes the datum."}, "Duration": {"properties": {"value": {"type": "number", "title": "Value"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "Duration", "description": "An object describing a time duration.\n\nAttributes\n----------\nvalue : float\n    Time duration in seconds."}, "EvaluationParameters": {"properties": {"task_type": {"$ref": "#/components/schemas/TaskType"}, "metrics_to_return": {"anyOf": [{"items": {"$ref": "#/components/schemas/MetricType"}, "type": "array"}, {"type": "null"}], "title": "Metrics To Return"}, "label_map": {"anyOf": [{"items": {"items": {"items": {"type": "string"}, "type": "array"}, "type": "array"}, "type": "array"}, {"type": "null"}], "title": "Label Map"}, "convert_annotations_to_type": {"anyOf": [{"$ref": "#/components/schemas/AnnotationType"}, {"type": "null"}]}, "iou_thresholds_to_compute": {"anyOf": [{"items": {"type": "number"}, "type": "array"}, {"type": "null"}], "title": "Iou Thresholds To Compute"}, "iou_thresholds_to_return": {"anyOf": [{"items": {"type": "number"}, "type": "array"}, {"type": "null"}], "title": "Iou Thresholds To Return"}, "recall_score_threshold": {"anyOf": [{"type": "number"}, {"type": "null"}], "title": "Recall Score Threshold", "default": 0}, "pr_curve_iou_threshold": {"type": "number", "title": "Pr Curve Iou Threshold", "default": 0.5}, "pr_curve_max_examples": {"type": "integer", "title": "Pr Curve Max Examples", "default": 1}}, "additionalProperties": false, "type": "object", "required": ["task_type"], "title": "EvaluationParameters", "description": "Defines parameters for evaluation methods.\n\nAttributes\n----------\ntask_type: TaskType\n    The task type of a given evaluation.\nlabel_map: Optional[List[List[List[str]]]]\n    Optional mapping of individual labels to a grouper label. Useful when you need to evaluate performance using labels that differ across datasets and models.\nmetrics_to_return: List[str], optional\n    The list of metrics to compute, store, and return to the user.\nconvert_annotations_to_type: AnnotationType | None = None\n    The type to convert all annotations to.\niou_thresholds_to_compute: List[float], optional\n    A list of floats describing which Intersection over Unions (IoUs) to use when calculating metrics (i.e., mAP).\niou_thresholds_to_return: List[float], optional\n    A list of floats describing which Intersection over Union (IoUs) thresholds to calculate a metric for. Must be a subset of `iou_thresholds_to_compute`.\nrecall_score_threshold: float, default=0\n    The confidence score threshold for use when determining whether to count a prediction as a true positive or not while calculating Average Recall.\npr_curve_iou_threshold: float, optional\n        The IOU threshold to use when calculating precision-recall curves for object detection tasks. Defaults to 0.5.\npr_curve_max_examples: int\n    The maximum number of datum examples to store when calculating PR curves."}, "EvaluationRequest": {"properties": {"dataset_names": {"items": {"type": "string"}, "type": "array", "title": "Dataset Names"}, "model_names": {"items": {"type": "string"}, "type": "array", "title": "Model Names"}, "filters": {"allOf": [{"$ref": "#/components/schemas/Filter-Input"}], "default": {}}, "parameters": {"$ref": "#/components/schemas/EvaluationParameters"}}, "additionalProperties": false, "type": "object", "required": ["dataset_names", "model_names", "parameters"], "title": "EvaluationRequest", "description": "Request for evaluation.\n\nAttributes\n----------\ndataset_names : list[str]\n    The names of the evaluated datasets.\nmodel_names : str | list[str]\n    The model(s) to evaluate.\nfilters : schemas.Filter, optional\n    The filter object used to define what data to evaluate.\nparameters : DetectionParameters, optional\n    Any parameters that are used to modify an evaluation method."}, "EvaluationResponse": {"properties": {"id": {"type": "integer", "title": "Id"}, "dataset_names": {"items": {"type": "string"}, "type": "array", "title": "Dataset Names"}, "model_name": {"type": "string", "title": "Model Name"}, "filters": {"$ref": "#/components/schemas/Filter-Output"}, "parameters": {"$ref": "#/components/schemas/EvaluationParameters"}, "status": {"$ref": "#/components/schemas/EvaluationStatus"}, "created_at": {"type": "string", "format": "date-time", "title": "Created At"}, "meta": {"anyOf": [{"additionalProperties": {"anyOf": [{"type": "string"}, {"type": "integer"}, {"type": "number"}]}, "type": "object"}, {"type": "null"}], "title": "Meta"}, "metrics": {"anyOf": [{"items": {"$ref": "#/components/schemas/Metric"}, "type": "array"}, {"type": "null"}], "title": "Metrics"}, "confusion_matrices": {"anyOf": [{"items": {"$ref": "#/components/schemas/ConfusionMatrixResponse"}, "type": "array"}, {"type": "null"}], "title": "Confusion Matrices"}, "ignored_pred_labels": {"anyOf": [{"items": {"$ref": "#/components/schemas/Label"}, "type": "array"}, {"type": "null"}], "title": "Ignored Pred Labels"}, "missing_pred_labels": {"anyOf": [{"items": {"$ref": "#/components/schemas/Label"}, "type": "array"}, {"type": "null"}], "title": "Missing Pred Labels"}}, "additionalProperties": true, "type": "object", "required": ["id", "dataset_names", "model_name", "filters", "parameters", "status", "created_at", "meta"], "title": "EvaluationResponse", "description": "An object for storing the returned results of a model evaluation (where groundtruths are compared with predictions to measure performance).\n\nAttributes\n----------\nid : int\n    The ID of the evaluation.\ndataset_names : list[str]\n    The names of the evaluated datasets.\nmodel_name : str\n    The name of the evaluated model.\nfilters : schemas.Filter\n    The evaluation filter used in the evaluation.\nparameters : schemas.EvaluationParameters\n    Any parameters used by the evaluation method.\nstatus : str\n    The status of the evaluation.\ncreated_at: datetime.datetime\n    The time the evaluation was created.\nmetrics : List[Metric]\n    A list of metrics associated with the evaluation.\nconfusion_matrices: List[ConfusionMatrixResponse]\n    A list of confusion matrices associated with the evaluation.\nmissing_pred_labels: List[Label], optional\n    A list of ground truth labels that aren't associated with any predictions.\nignored_pred_labels: List[Label], optional\n    A list of prediction labels that aren't associated with any ground truths.\nmeta: dict[str, str | int | float]\n    Metadata about the evaluation run."}, "EvaluationStatus": {"type": "string", "enum": ["pending", "running", "done", "failed", "deleting"], "title": "EvaluationStatus"}, "Filter-Input": {"properties": {"dataset_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Dataset Names"}, "dataset_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Dataset Metadata"}, "model_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Model Names"}, "model_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Model Metadata"}, "datum_uids": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Datum Uids"}, "datum_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Datum Metadata"}, "task_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/TaskType"}, "type": "array"}, {"type": "null"}], "title": "Task Types"}, "annotation_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Annotation Metadata"}, "require_bounding_box": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Bounding Box"}, "bounding_box_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Bounding Box Area"}, "require_polygon": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Polygon"}, "polygon_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Polygon Area"}, "require_raster": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Raster"}, "raster_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Raster Area"}, "labels": {"anyOf": [{"items": {"additionalProperties": {"type": "string"}, "type": "object"}, "type": "array"}, {"type": "null"}], "title": "Labels"}, "label_ids": {"anyOf": [{"items": {"type": "integer"}, "type": "array"}, {"type": "null"}], "title": "Label Ids"}, "label_keys": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Label Keys"}, "label_scores": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Label Scores"}}, "additionalProperties": false, "type": "object", "title": "Filter", "description": "Used to filter Evaluations according to specific, user-defined criteria.\n\nAttributes\n----------\ndataset_names: List[str], default=None\n    A list of `Dataset` names to filter on.\ndataset_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Dataset` metadata to filter on.\nmodel_names: List[str], default=None\n    A list of `Model` names to filter on.\nmodel_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Model` metadata to filter on.\ndatum_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Datum` metadata to filter on.\ntask_types: List[TaskType], default=None\n    A list of task types to filter on.\nannotation_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Annotation` metadata to filter on.\nrequire_bounding_box : bool, optional\n    A toggle for filtering by bounding boxes.\nbounding_box_area : bool, optional\n    An optional constraint to filter by bounding box area.\nrequire_polygon : bool, optional\n    A toggle for filtering by polygons.\npolygon_area : bool, optional\n    An optional constraint to filter by polygon area.\nrequire_raster : bool, optional\n    A toggle for filtering by rasters.\nraster_area : bool, optional\n    An optional constraint to filter by raster area.\nlabels: List[Dict[str, str]], default=None\n    A dictionary of `Labels' to filter on.\nlabel_ids: List[int], default=None\n    A list of `Label` IDs to filter on.\nlabel_keys: List[str] = None, default=None\n    A list of `Label` keys to filter on.\nlabel_scores: List[ValueFilter], default=None\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Model`'s prediction scores."}, "Filter-Output": {"properties": {"dataset_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Dataset Names"}, "dataset_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Dataset Metadata"}, "model_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Model Names"}, "model_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Model Metadata"}, "datum_uids": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Datum Uids"}, "datum_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Datum Metadata"}, "task_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/TaskType"}, "type": "array"}, {"type": "null"}], "title": "Task Types"}, "annotation_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Annotation Metadata"}, "require_bounding_box": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Bounding Box"}, "bounding_box_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Bounding Box Area"}, "require_polygon": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Polygon"}, "polygon_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Polygon Area"}, "require_raster": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Raster"}, "raster_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Raster Area"}, "labels": {"anyOf": [{"items": {"additionalProperties": {"type": "string"}, "type": "object"}, "type": "array"}, {"type": "null"}], "title": "Labels"}, "label_ids": {"anyOf": [{"items": {"type": "integer"}, "type": "array"}, {"type": "null"}], "title": "Label Ids"}, "label_keys": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Label Keys"}, "label_scores": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Label Scores"}}, "additionalProperties": false, "type": "object", "title": "Filter", "description": "Used to filter Evaluations according to specific, user-defined criteria.\n\nAttributes\n----------\ndataset_names: List[str], default=None\n    A list of `Dataset` names to filter on.\ndataset_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Dataset` metadata to filter on.\nmodel_names: List[str], default=None\n    A list of `Model` names to filter on.\nmodel_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Model` metadata to filter on.\ndatum_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Datum` metadata to filter on.\ntask_types: List[TaskType], default=None\n    A list of task types to filter on.\nannotation_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Annotation` metadata to filter on.\nrequire_bounding_box : bool, optional\n    A toggle for filtering by bounding boxes.\nbounding_box_area : bool, optional\n    An optional constraint to filter by bounding box area.\nrequire_polygon : bool, optional\n    A toggle for filtering by polygons.\npolygon_area : bool, optional\n    An optional constraint to filter by polygon area.\nrequire_raster : bool, optional\n    A toggle for filtering by rasters.\nraster_area : bool, optional\n    An optional constraint to filter by raster area.\nlabels: List[Dict[str, str]], default=None\n    A dictionary of `Labels' to filter on.\nlabel_ids: List[int], default=None\n    A list of `Label` IDs to filter on.\nlabel_keys: List[str] = None, default=None\n    A list of `Label` keys to filter on.\nlabel_scores: List[ValueFilter], default=None\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Model`'s prediction scores."}, "GeoJSON": {"properties": {"type": {"type": "string", "title": "Type"}, "coordinates": {"anyOf": [{"items": {"type": "number"}, "type": "array"}, {"items": {"items": {"type": "number"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"type": "number"}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"items": {"type": "number"}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array"}], "title": "Coordinates"}}, "type": "object", "required": ["type", "coordinates"], "title": "GeoJSON"}, "GeospatialFilter": {"properties": {"value": {"$ref": "#/components/schemas/GeoJSON"}, "operator": {"type": "string", "title": "Operator", "default": "intersect"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "GeospatialFilter", "description": "Used to filter on geospatial coordinates.\n\nAttributes\n----------\nvalue : GeoJSON\n    A dictionary containing a Point, Polygon, or MultiPolygon. Mirrors `shapely's` `GeoJSON` format.\noperator : str\n    The operator to use for comparison. Should be one of `intersect`, `inside`, or `outside`."}, "GroundTruth-Input": {"properties": {"dataset_name": {"type": "string", "title": "Dataset Name"}, "datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Input"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["dataset_name", "datum", "annotations"], "title": "GroundTruth", "description": "An object describing a ground truth (e.g., a human-drawn bounding box on an image).\n\nAttributes\n----------\ndataset_name: str\n    The name of the dataset this ground truth belongs to.\ndatum : Datum\n    The datum this ground truth annotates.\nannotations : List[Annotation]\n    The list of annotations that this ground truth applies."}, "GroundTruth-Output": {"properties": {"dataset_name": {"type": "string", "title": "Dataset Name"}, "datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Output"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["dataset_name", "datum", "annotations"], "title": "GroundTruth", "description": "An object describing a ground truth (e.g., a human-drawn bounding box on an image).\n\nAttributes\n----------\ndataset_name: str\n    The name of the dataset this ground truth belongs to.\ndatum : Datum\n    The datum this ground truth annotates.\nannotations : List[Annotation]\n    The list of annotations that this ground truth applies."}, "HTTPValidationError": {"properties": {"detail": {"items": {"$ref": "#/components/schemas/ValidationError"}, "type": "array", "title": "Detail"}}, "type": "object", "title": "HTTPValidationError"}, "Label": {"properties": {"key": {"type": "string", "title": "Key"}, "value": {"type": "string", "title": "Value"}, "score": {"anyOf": [{"type": "number"}, {"type": "null"}], "title": "Score"}}, "additionalProperties": false, "type": "object", "required": ["key", "value"], "title": "Label", "description": "An object for labeling datasets, models, and annotations.\n\nAttributes\n----------\nkey : str\n    The label key. (e.g. 'class', 'category')\nvalue : str\n    The label's value. (e.g. 'dog', 'cat')\nscore : float, optional\n    A score assigned to the label in the case of a prediction."}, "Metric": {"properties": {"type": {"type": "string", "title": "Type"}, "parameters": {"anyOf": [{"type": "object"}, {"type": "null"}], "title": "Parameters"}, "value": {"anyOf": [{"type": "number"}, {"type": "object"}, {"type": "null"}], "title": "Value"}, "label": {"anyOf": [{"$ref": "#/components/schemas/Label"}, {"type": "null"}]}}, "type": "object", "required": ["type"], "title": "Metric", "description": "A metric response from the API.\n\nAttributes\n----------\ntype : str\n    The type of metric.\nparameters : dict\n    The parameters of the metric.\nvalue : float\n    The value of the metric.\nlabel : Label\n    The `Label` for the metric."}, "MetricType": {"type": "string", "enum": ["Accuracy", "Precision", "Recall", "F1", "ROCAUC", "AP", "AR", "mAP", "mAR", "APAveragedOverIOUs", "mAPAveragedOverIOUs", "IOU", "mIOU", "PrecisionRecallCurve", "DetailedPrecisionRecallCurve"], "title": "MetricType"}, "Model": {"properties": {"name": {"type": "string", "title": "Name"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "boolean"}, {"type": "integer"}, {"type": "number"}, {"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"type": "number"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"prefixItems": [{"type": "number"}, {"type": "number"}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}}, "additionalProperties": false, "type": "object", "required": ["name"], "title": "Model", "description": "A class describing a model that was trained on a particular dataset.\n\nAttributes\n----------\nname : str\n    The name of the model.\nmetadata : dict, optional\n    A dictionary of metadata that describes the model."}, "MultiPolygon": {"properties": {"value": {"items": {"items": {"items": {"prefixItems": [{"anyOf": [{"type": "integer"}, {"type": "number"}]}, {"anyOf": [{"type": "integer"}, {"type": "number"}]}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array"}, "type": "array", "title": "Value"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "MultiPolygon", "description": "Describes a MultiPolygon in (x,y) coordinates.\n\nAttributes\n----------\nvalue : list[list[list[list[int | float]]]]\n    A list of coordinates describing the MultiPolygon.\n\nRaises\n------\nValueError\n    If the value doesn't conform to the type."}, "NumericFilter": {"properties": {"value": {"type": "number", "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "NumericFilter", "description": "Used to filter on numeric values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : float\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\">\", \"<\", \">=\", \"<=\", \"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "Polygon": {"properties": {"value": {"items": {"items": {"prefixItems": [{"anyOf": [{"type": "integer"}, {"type": "number"}]}, {"anyOf": [{"type": "integer"}, {"type": "number"}]}], "type": "array", "maxItems": 2, "minItems": 2}, "type": "array"}, "type": "array", "title": "Value"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "Polygon", "description": "Describes a Polygon in (x,y) coordinates.\n\nAttributes\n----------\nvalue : list[list[tuple[int | float, int | float]]]\n    A list of coordinates describing the Box.\n\nRaises\n------\nValueError\n    If the value doesn't conform to the type."}, "Prediction-Input": {"properties": {"dataset_name": {"type": "string", "title": "Dataset Name"}, "model_name": {"type": "string", "title": "Model Name"}, "datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Input"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["dataset_name", "model_name", "datum", "annotations"], "title": "Prediction", "description": "An object describing a prediction (e.g., a machine-drawn bounding box on an image).\n\nAttributes\n----------\ndataset_name: str\n    The name of the dataset this ground truth belongs to.\nmodel_name : str\n    The name of the model that produced the prediction.\ndatum : Datum\n    The datum this ground truth annotates.\nannotations : List[Annotation]\n    The list of annotations that this ground truth applies."}, "Prediction-Output": {"properties": {"dataset_name": {"type": "string", "title": "Dataset Name"}, "model_name": {"type": "string", "title": "Model Name"}, "datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Output"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["dataset_name", "model_name", "datum", "annotations"], "title": "Prediction", "description": "An object describing a prediction (e.g., a machine-drawn bounding box on an image).\n\nAttributes\n----------\ndataset_name: str\n    The name of the dataset this ground truth belongs to.\nmodel_name : str\n    The name of the model that produced the prediction.\ndatum : Datum\n    The datum this ground truth annotates.\nannotations : List[Annotation]\n    The list of annotations that this ground truth applies."}, "Raster": {"properties": {"mask": {"type": "string", "title": "Mask"}, "geometry": {"anyOf": [{"$ref": "#/components/schemas/Box"}, {"$ref": "#/components/schemas/Polygon"}, {"$ref": "#/components/schemas/MultiPolygon"}, {"type": "null"}], "title": "Geometry"}}, "additionalProperties": false, "type": "object", "required": ["mask"], "title": "Raster", "description": "Describes a raster in geometric space.\n\nAttributes\n----------\nmask : str\n    The mask describing the raster.\ngeometry : Box | Polygon | MultiPolygon, optional\n    Option to define raster by a geometry. Overrides the bitmask.\n\nRaises\n------\nValueError\n    If the image format is not PNG.\n    If the image mode is not binary."}, "StringFilter": {"properties": {"value": {"type": "string", "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "StringFilter", "description": "Used to filter on string values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : str\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "TableStatus": {"type": "string", "enum": ["creating", "finalized", "deleting"], "title": "TableStatus"}, "TaskType": {"type": "string", "enum": ["skip", "empty", "classification", "object-detection", "semantic-segmentation", "embedding"], "title": "TaskType"}, "Time": {"properties": {"value": {"type": "string", "title": "Value"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "Time", "description": "An object describing a time.\n\nAttributes\n----------\nvalue : str\n    Time in ISO format."}, "ValidationError": {"properties": {"loc": {"items": {"anyOf": [{"type": "string"}, {"type": "integer"}]}, "type": "array", "title": "Location"}, "msg": {"type": "string", "title": "Message"}, "type": {"type": "string", "title": "Error Type"}}, "type": "object", "required": ["loc", "msg", "type"], "title": "ValidationError"}}, "securitySchemes": {"OptionalHTTPBearer": {"type": "http", "scheme": "bearer"}}}}