{"openapi": "3.1.0", "info": {"title": "FastAPI", "version": "0.1.0"}, "paths": {"/groundtruths": {"post": {"tags": ["GroundTruths"], "summary": "Create Groundtruths", "description": "Create a groundtruth in the database.\n\nPOST Endpoint: `/groundtruths`\n\nParameters\n----------\ngt : schemas.GroundTruth\n    The groundtruth to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.\nHTTPException (409)\n    If the dataset has been finalized, or if the datum already exists.", "operationId": "create_groundtruths_groundtruths_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/GroundTruth-Input"}}}, "required": true}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/groundtruths/dataset/{dataset_name}/datum/{uid}": {"get": {"tags": ["GroundTruths"], "summary": "Get Groundtruth", "description": "Fetch a groundtruth from the database.\n\nGET Endpoint: `/groundtruths/dataset/{dataset_name}/datum/{uid}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset to fetch the groundtruth from.\nuid : str\n    The UID of the groundtruth.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.GroundTruth\n    Thee groundtruth requested by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum does not exist.", "operationId": "get_groundtruth_groundtruths_dataset__dataset_name__datum__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/GroundTruth-Output"}, {"type": "null"}], "title": "Response Get Groundtruth Groundtruths Dataset  Dataset Name  Datum  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/predictions": {"post": {"tags": ["Predictions"], "summary": "Create Predictions", "description": "Create a prediction in the database.\n\nPOST Endpoint: `/predictions`\n\nParameters\n----------\npd : schemas.Prediction\n    The prediction to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset, model, or datum doesn't exist.\nHTTPException (409)\n    If the model has been finalized, or if the dataset has not been finalized.", "operationId": "create_predictions_predictions_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Prediction-Input"}}}, "required": true}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/predictions/model/{model_name}/dataset/{dataset_name}/datum/{uid}": {"get": {"tags": ["Predictions"], "summary": "Get Prediction", "description": "Fetch a prediction from the database.\n\nGET Endpoint: `/predictions/model/{model_name}/dataset/{dataset_name}/datum/{uid}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model associated with the prediction.\ndataset_name : str\n    The name of the dataset associated with the prediction.\nuid : str\n    The UID associated with the prediction.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Prediction\n    The requested prediction.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.", "operationId": "get_prediction_predictions_model__model_name__dataset__dataset_name__datum__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}, {"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Prediction-Output"}, {"type": "null"}], "title": "Response Get Prediction Predictions Model  Model Name  Dataset  Dataset Name  Datum  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/labels": {"get": {"tags": ["Labels"], "summary": "Get All Labels", "description": "Fetch all labels in the database.\n\nGET Endpoint: `/labels`\n\nParameters\n----------\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Label]\n    A list of all labels in the database.", "operationId": "get_all_labels_labels_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Response Get All Labels Labels Get"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/labels/dataset/{dataset_name}": {"get": {"tags": ["Labels"], "summary": "Get Labels From Dataset", "description": "Fetch all labels for a particular dataset from the database.\n\nGET Endpoint: `/labels/dataset/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Label]\n    A list of all labels associated with the dataset in the database.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_labels_from_dataset_labels_dataset__dataset_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Label"}, "title": "Response Get Labels From Dataset Labels Dataset  Dataset Name  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/labels/model/{model_name}": {"get": {"tags": ["Labels"], "summary": "Get Labels From Model", "description": "Fetch all labels for a particular model from the database.\n\nGET Endpoint: `/labels/model/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Label]\n    A list of all labels associated with the model in the database.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.", "operationId": "get_labels_from_model_labels_model__model_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Label"}, "title": "Response Get Labels From Model Labels Model  Model Name  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets": {"get": {"tags": ["Datasets"], "summary": "Get Datasets", "description": "Fetch all datasets from the database.\n\nGET Endpoint: `/datasets`\n\nParameters\n----------\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Dataset]\n    A list of all datasets stored in the database.", "operationId": "get_datasets_datasets_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Dataset"}, "type": "array", "title": "Response Get Datasets Datasets Get"}}}}}, "security": [{"OptionalHTTPBearer": []}]}, "post": {"tags": ["Datasets"], "summary": "Create Dataset", "description": "Create a dataset in the database.\n\nPOST Endpoint: `/datasets`\n\nParameters\n----------\ndataset : schemas.Dataset\n    The dataset to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (409)\n    If the dataset already exists.", "operationId": "create_dataset_datasets_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Dataset"}}}, "required": true}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/datasets/{dataset_name}": {"get": {"tags": ["Datasets"], "summary": "Get Dataset", "description": "Fetch a particular dataset from the database.\n\nGET Endpoint: `/datasets/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Dataset\n    The requested dataset.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_dataset_datasets__dataset_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Dataset"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Datasets"], "summary": "Delete Dataset", "description": "Delete a dataset from the database.\n\nDELETE Endpoint: `/datasets/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nbackground_tasks: BackgroundTasks\n    A FastAPI `BackgroundTasks` object to process the deletion asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.\nHTTPException (409)\n    If the dataset isn't in the correct state to be deleted.", "operationId": "delete_dataset_datasets__dataset_name__delete", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}/status": {"get": {"tags": ["Datasets"], "summary": "Get Dataset Status", "description": "Fetch the status of a dataset.\n\nGET Endpoint: `/datasets/{dataset_name}/status`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nenums.TableStatus\n    The requested state.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_dataset_status_datasets__dataset_name__status_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TableStatus"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}/summary": {"get": {"tags": ["Datasets"], "summary": "Get Dataset Summary", "description": "Get the summary of a dataset.\n\nGET Endpoint: `/datasets/{dataset_name}/summary`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.DatasetSummary\n    The dataset summary.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_dataset_summary_datasets__dataset_name__summary_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DatasetSummary"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}/finalize": {"put": {"tags": ["Datasets"], "summary": "Finalize Dataset", "description": "Finalizes a dataset for evaluation.\n\nPUT Endpoint: `/datasets/{dataset_name}/finalize`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (409)\n    If the dataset is empty.\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "finalize_dataset_datasets__dataset_name__finalize_put", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/data/dataset/{dataset_name}": {"get": {"tags": ["Datums"], "summary": "Get Datums", "description": "Fetch all datums for a particular dataset.\n\nGET Endpoint: `/data/dataset/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Datum]\n    A list of datums.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.", "operationId": "get_datums_data_dataset__dataset_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Datum"}, "title": "Response Get Datums Data Dataset  Dataset Name  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/data/dataset/{dataset_name}/uid/{uid}": {"get": {"tags": ["Datums"], "summary": "Get Datum", "description": "Fetch a particular datum.\n\nGET Endpoint: `/data/dataset/{dataset_name}/uid/{uid}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nuid : str\n    The UID of the datum.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Datum\n    The requested datum.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.", "operationId": "get_datum_data_dataset__dataset_name__uid__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Datum"}, {"type": "null"}], "title": "Response Get Datum Data Dataset  Dataset Name  Uid  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models": {"get": {"tags": ["Models"], "summary": "Get Models", "description": "Fetch all models in the database.\n\nGET Endpoint: `/models`\n\nParameters\n----------\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Model]\n    A list of models.", "operationId": "get_models_models_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Model"}, "type": "array", "title": "Response Get Models Models Get"}}}}}, "security": [{"OptionalHTTPBearer": []}]}, "post": {"tags": ["Models"], "summary": "Create Model", "description": "Create a model in the database.\n\nPOST Endpoint: `/models`\n\nParameters\n----------\nmodel : schemas.Model\n    The model to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.\nHTTPException (409)\n    If the dataset has been finalized, or if the datum already exists.", "operationId": "create_model_models_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Model"}}}, "required": true}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/models/{model_name}": {"get": {"tags": ["Models"], "summary": "Get Model", "description": "Fetch a particular model.\n\nGET Endpoint: `/models/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Model\n    The requested model.\n\nRaises\n------\nHTTPException (404)\n    If the model datum doesn't exist.", "operationId": "get_model_models__model_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Model"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Models"], "summary": "Delete Model", "description": "Delete a model from the database.\n\nDELETE Endpoint: `/models/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.\nHTTPException (409)\n    If the model isn't in the correct state to be deleted.", "operationId": "delete_model_models__model_name__delete", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models/{model_name}/dataset/{dataset_name}/status": {"get": {"tags": ["Models"], "summary": "Get Model Status", "description": "Fetch the status of a model over a dataset.\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nenums.TableStatus\n    The requested state.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.", "operationId": "get_model_status_models__model_name__dataset__dataset_name__status_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TableStatus"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models/{model_name}/datasets/{dataset_name}/finalize": {"put": {"tags": ["Models"], "summary": "Finalize Inferences", "description": "Finalize a model prior to evaluation.\n\nPUT Endpoint: `/models/{model_name}/datasets/{dataset_name}/finalize`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n\nRaises\n------\nHTTPException (400)\n    If the dataset or model are empty.\nHTTPException (404)\n    If the dataset or model do not exist.", "operationId": "finalize_inferences_models__model_name__datasets__dataset_name__finalize_put", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/evaluations": {"post": {"tags": ["Evaluations"], "summary": "Create Or Get Evaluations", "description": "Create a new evaluation.\n\nPOST Endpoint: `/evaluations`\n\nParameters\n----------\njob_request: schemas.EvaluationJob\n    The job request for the evaluation.\nbackground_tasks: BackgroundTasks\n    A FastAPI `BackgroundTasks` object to process the creation asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[schemas.EvaluationResponse]\n    A list of evaluation response objects.\n\nRaises\n------\nHTTPException (400)\n    If the task type of the evaluation job doesn't exist, or if another ValueError is thrown.\nHTTPException (404)\n    If the dataset or model does not exist.\nHTTPException (405)\n    If the dataset or model hasn't been finalized.\nHTTPException (409)\n    If there is a state exception when creating the evaluation.", "operationId": "create_or_get_evaluations_evaluations_post", "security": [{"OptionalHTTPBearer": []}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EvaluationRequest"}}}}, "responses": {"202": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/EvaluationResponse"}, "title": "Response Create Or Get Evaluations Evaluations Post"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "get": {"tags": ["Evaluations"], "summary": "Get Evaluations", "description": "Fetch all metrics associated with user-supplied dataset and model names. Users\nmay query using model names, dataset names, or both. All metrics for all specified\nmodels and datasets will be returned in a list of Evaluations.\n\nThis endpoint can handle multiple dataset and model names. For example, you can use\n`/evaluations?models=first_model,second_model&datasets=test_dataset` to get all evaluations\nrelated to `test_dataset` and either `first_model` or `second_model`.\n\nGET Endpoint: `/evaluations`\n\nParameters\n----------\ndatasets : str\n    An optional set of dataset names to return metrics for\nmodels : str\n    An optional set of model names to return metrics for\nevaluation_ids : str\n    An optional set of evaluation_ids to return metrics for\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Evaluation]\n    A list of evaluations.\n\nRaises\n------\nHTTPException (400)\n    If a ValueError is thrown.\nHTTPException (404)\n    If the dataset or model doesn't exist.", "operationId": "get_evaluations_evaluations_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "datasets", "in": "query", "required": false, "schema": {"type": "string", "title": "Datasets"}}, {"name": "models", "in": "query", "required": false, "schema": {"type": "string", "title": "Models"}}, {"name": "evaluation_ids", "in": "query", "required": false, "schema": {"type": "string", "title": "Evaluation Ids"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/EvaluationResponse"}, "title": "Response Get Evaluations Evaluations Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/user": {"get": {"tags": ["Authentication"], "summary": "Get User", "description": "Verify a user and return their email address.\n\nGET Endpoint: `/user`\n\nParameters\n----------\ntoken: HTTPAuthorizationCredentials\n    The auth token for the user.\n\nReturns\n-------\nschemas.User\n    A response object containing information about the user.", "operationId": "get_user_user_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/User"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/api-version": {"get": {"tags": ["Info"], "summary": "Get Api Version", "description": "Return the API's version.\n\nGET Endpoint: `/api-version`\n\nReturns\n-------\nschemas.APIVersion\n    A response object containing the API's version number.", "operationId": "get_api_version_api_version_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/APIVersion"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/health": {"get": {"tags": ["Status"], "summary": "Health", "description": "Return 200 if the service is up.\n\nGET Endpoint: `/health`\n\nReturns\n-------\nschemas.Health\n    A response indicating that the service is up and running.", "operationId": "health_health_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}}}}, "/ready": {"get": {"tags": ["Status"], "summary": "Ready", "description": "Return 200 if the service is up and connected to the database.\n\nGET Endpoint: `/ready`\n\nReturns\n-------\nschemas.Readiness\n    A response indicating that the service is up and connected to the database.", "operationId": "ready_ready_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}}}}}, "components": {"schemas": {"APIVersion": {"properties": {"api_version": {"type": "string", "title": "Api Version"}}, "type": "object", "required": ["api_version"], "title": "APIVersion", "description": "Defines an API version string which is sent back to the user after their authentication is confirmed.\n\nAttributes\n----------\napi_version : str\n    The API version."}, "Annotation-Input": {"properties": {"task_type": {"$ref": "#/components/schemas/TaskType"}, "labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Labels"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"type": "string"}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}, "bounding_box": {"anyOf": [{"$ref": "#/components/schemas/BoundingBox-Input"}, {"type": "null"}]}, "polygon": {"anyOf": [{"$ref": "#/components/schemas/Polygon-Input"}, {"type": "null"}]}, "multipolygon": {"anyOf": [{"$ref": "#/components/schemas/MultiPolygon-Input"}, {"type": "null"}]}, "raster": {"anyOf": [{"$ref": "#/components/schemas/Raster"}, {"type": "null"}]}, "jsonb": {"anyOf": [{"additionalProperties": {"type": "string"}, "type": "object"}, {"type": "null"}], "title": "Jsonb"}}, "additionalProperties": false, "type": "object", "required": ["task_type", "labels"], "title": "Annotation", "description": "A class used to annotate `GroundTruths` and `Predictions`.\n\nAttributes\n----------\ntask_type: TaskType\n    The task type associated with the `Annotation`.\nlabels: List[Label]\n    A list of labels to use for the `Annotation`.\nmetadata: Dict[str, Union[int, float, str]]\n    A dictionary of metadata that describes the `Annotation`.\nbounding_box: BoundingBox\n    A bounding box to assign to the `Annotation`.\npolygon: Polygon\n    A polygon to assign to the `Annotation`.\nmultipolygon: MultiPolygon\n    A multipolygon to assign to the `Annotation`.\nraster: Raster\n    A raster to assign to the `Annotation`.\njsonb: Dict\n    A jsonb to assign to the `Annotation`.\n\nRaises\n----------\nValueError\n    If no labels are passed.\n    If the same label appears in two annotations."}, "Annotation-Output": {"properties": {"task_type": {"$ref": "#/components/schemas/TaskType"}, "labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Labels"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"type": "string"}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}, "bounding_box": {"anyOf": [{"$ref": "#/components/schemas/BoundingBox-Output"}, {"type": "null"}]}, "polygon": {"anyOf": [{"$ref": "#/components/schemas/Polygon-Output"}, {"type": "null"}]}, "multipolygon": {"anyOf": [{"$ref": "#/components/schemas/MultiPolygon-Output"}, {"type": "null"}]}, "raster": {"anyOf": [{"$ref": "#/components/schemas/Raster"}, {"type": "null"}]}, "jsonb": {"anyOf": [{"additionalProperties": {"type": "string"}, "type": "object"}, {"type": "null"}], "title": "Jsonb"}}, "additionalProperties": false, "type": "object", "required": ["task_type", "labels"], "title": "Annotation", "description": "A class used to annotate `GroundTruths` and `Predictions`.\n\nAttributes\n----------\ntask_type: TaskType\n    The task type associated with the `Annotation`.\nlabels: List[Label]\n    A list of labels to use for the `Annotation`.\nmetadata: Dict[str, Union[int, float, str]]\n    A dictionary of metadata that describes the `Annotation`.\nbounding_box: BoundingBox\n    A bounding box to assign to the `Annotation`.\npolygon: Polygon\n    A polygon to assign to the `Annotation`.\nmultipolygon: MultiPolygon\n    A multipolygon to assign to the `Annotation`.\nraster: Raster\n    A raster to assign to the `Annotation`.\njsonb: Dict\n    A jsonb to assign to the `Annotation`.\n\nRaises\n----------\nValueError\n    If no labels are passed.\n    If the same label appears in two annotations."}, "AnnotationType": {"type": "string", "enum": ["none", "box", "polygon", "multipolygon", "raster"], "title": "AnnotationType"}, "BasicPolygon": {"properties": {"points": {"items": {"$ref": "#/components/schemas/Point"}, "type": "array", "title": "Points"}}, "type": "object", "required": ["points"], "title": "BasicPolygon", "description": "Describes a polygon in geometric space.\n\nAttributes\n----------\npoints: Tuple[Point, Point]\n    The coordinates of the polygon.\n\nRaises\n------\nValueError\n    If less than three points are passed."}, "BooleanFilter": {"properties": {"value": {"type": "boolean", "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "BooleanFilter", "description": "Used to filter on boolean values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : bool\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "BoundingBox-Input": {"properties": {"polygon": {"$ref": "#/components/schemas/BasicPolygon"}}, "type": "object", "required": ["polygon"], "title": "BoundingBox", "description": "Describes a bounding box in geometric space.\n\nAttributes\n----------\npolygons: BasicPolygon\n    A polygon describing the bounding box.\n\nRaises\n------\nValueError\n    If the number of points != 4."}, "BoundingBox-Output": {"properties": {"polygon": {"$ref": "#/components/schemas/BasicPolygon"}}, "type": "object", "required": ["polygon"], "title": "BoundingBox", "description": "Describes a bounding box in geometric space.\n\nAttributes\n----------\npolygons: BasicPolygon\n    A polygon describing the bounding box.\n\nRaises\n------\nValueError\n    If the number of points != 4."}, "ConfusionMatrixEntry": {"properties": {"prediction": {"type": "string", "title": "Prediction"}, "groundtruth": {"type": "string", "title": "Groundtruth"}, "count": {"type": "integer", "title": "Count"}}, "type": "object", "required": ["prediction", "groundtruth", "count"], "title": "ConfusionMatrixEntry", "description": "Describes one element in a confusion matrix.\n\nAttributes\n----------\nprediction : str\n    The prediction.\ngroundtruth : str\n    The groundtruth.\ncount : int\n    The value of the element in the matrix."}, "ConfusionMatrixResponse": {"properties": {"label_key": {"type": "string", "title": "Label Key"}, "entries": {"items": {"$ref": "#/components/schemas/ConfusionMatrixEntry"}, "type": "array", "title": "Entries"}}, "type": "object", "required": ["label_key", "entries"], "title": "ConfusionMatrixResponse", "description": "A response object used for HTTP responses since they won't contain matrix or label map attributes."}, "Dataset": {"properties": {"id": {"anyOf": [{"type": "integer"}, {"type": "null"}], "title": "Id"}, "name": {"type": "string", "title": "Name"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"additionalProperties": {"type": "string"}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}, "geospatial": {"anyOf": [{"$ref": "#/components/schemas/GeoJSONPoint"}, {"$ref": "#/components/schemas/GeoJSONPolygon"}, {"$ref": "#/components/schemas/GeoJSONMultiPolygon"}, {"type": "null"}], "title": "Geospatial"}}, "additionalProperties": false, "type": "object", "required": ["name"], "title": "Dataset", "description": "A class describing a given dataset.\n\nAttributes\n----------\nid : int\n    The ID of the dataset.\nname : str\n    The name of the dataset.\nmetadata :  dict\n    A dictionary of metadata that describes the dataset.\ngeospatial : dict\n    A GeoJSON-style dictionary describing the geospatial coordinates of the dataset.\n\nRaises\n----------\nValueError\n    If the name is invalid."}, "DatasetSummary": {"properties": {"name": {"type": "string", "title": "Name"}, "num_datums": {"type": "integer", "title": "Num Datums"}, "num_annotations": {"type": "integer", "title": "Num Annotations"}, "num_bounding_boxes": {"type": "integer", "title": "Num Bounding Boxes"}, "num_polygons": {"type": "integer", "title": "Num Polygons"}, "num_groundtruth_multipolygons": {"type": "integer", "title": "Num Groundtruth Multipolygons"}, "num_rasters": {"type": "integer", "title": "Num Rasters"}, "task_types": {"items": {"$ref": "#/components/schemas/TaskType"}, "type": "array", "title": "Task Types"}, "labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Labels"}, "datum_metadata": {"items": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"type": "string"}, "type": "object"}]}, "type": "object"}, "type": "array", "title": "Datum Metadata"}, "annotation_metadata": {"items": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"type": "string"}, "type": "object"}]}, "type": "object"}, "type": "array", "title": "Annotation Metadata"}}, "type": "object", "required": ["name", "num_datums", "num_annotations", "num_bounding_boxes", "num_polygons", "num_groundtruth_multipolygons", "num_rasters", "task_types", "labels", "datum_metadata", "annotation_metadata"], "title": "DatasetSummary"}, "Date": {"properties": {"date": {"type": "string", "title": "Date"}}, "additionalProperties": false, "type": "object", "required": ["date"], "title": "Date", "description": "An object describing a date.\n\nAttributes\n----------\ndate : str\n    Date in ISO format."}, "DateTime": {"properties": {"datetime": {"type": "string", "title": "Datetime"}}, "additionalProperties": false, "type": "object", "required": ["datetime"], "title": "DateTime", "description": "An object describing a date and time.\n\nAttributes\n----------\ndatetime : str\n    Datetime in ISO format."}, "DateTimeFilter": {"properties": {"value": {"anyOf": [{"$ref": "#/components/schemas/DateTime"}, {"$ref": "#/components/schemas/Date"}, {"$ref": "#/components/schemas/Time"}, {"$ref": "#/components/schemas/Duration"}], "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "DateTimeFilter", "description": "Used to filter on datetime values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : DateTime\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\">\", \"<\", \">=\", \"<=\", \"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "Datum": {"properties": {"uid": {"type": "string", "title": "Uid"}, "dataset_name": {"type": "string", "title": "Dataset Name"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"type": "string"}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}, "geospatial": {"anyOf": [{"$ref": "#/components/schemas/GeoJSONPoint"}, {"$ref": "#/components/schemas/GeoJSONPolygon"}, {"$ref": "#/components/schemas/GeoJSONMultiPolygon"}, {"type": "null"}], "title": "Geospatial"}}, "additionalProperties": false, "type": "object", "required": ["uid", "dataset_name"], "title": "Datum", "description": "A class used to store datum about `GroundTruths` and `Predictions`.\n\nAttributes\n----------\nuid : str\n    The UID of the `Datum`.\ndataset_name : str\n    The name of the dataset to associate the `Datum` with.\nmetadata : dict\n    A dictionary of metadata that describes the `Datum`.\ngeospatial :  dict\n    A GeoJSON-style dictionary describing the geospatial coordinates of the `Datum`.\n\nRaises\n----------\nValueError\n    If the dataset or UID is invalid."}, "Duration": {"properties": {"duration": {"type": "string", "title": "Duration"}}, "additionalProperties": false, "type": "object", "required": ["duration"], "title": "Duration", "description": "An object describing a time duration.\n\nAttributes\n----------\nduration : str\n    Time duration in seconds."}, "EvaluationParameters": {"properties": {"task_type": {"$ref": "#/components/schemas/TaskType"}, "convert_annotations_to_type": {"anyOf": [{"$ref": "#/components/schemas/AnnotationType"}, {"type": "null"}]}, "iou_thresholds_to_compute": {"anyOf": [{"items": {"type": "number"}, "type": "array"}, {"type": "null"}], "title": "Iou Thresholds To Compute"}, "iou_thresholds_to_return": {"anyOf": [{"items": {"type": "number"}, "type": "array"}, {"type": "null"}], "title": "Iou Thresholds To Return"}}, "additionalProperties": false, "type": "object", "required": ["task_type"], "title": "EvaluationParameters", "description": "Defines parameters for evaluation methods.\n\nAttributes\n----------\n\niou_thresholds_to_compute : List[float], optional\n    A list of floats describing which Intersection over Unions (IoUs) to use when calculating metrics (i.e., mAP).\niou_thresholds_to_return: List[float], optional\n    A list of floats describing which Intersection over Union (IoUs) thresholds to calculate a metric for. Must be a subset of `iou_thresholds_to_compute`."}, "EvaluationRequest": {"properties": {"model_names": {"anyOf": [{"type": "string"}, {"items": {"type": "string"}, "type": "array"}], "title": "Model Names"}, "datum_filter": {"$ref": "#/components/schemas/Filter-Input"}, "parameters": {"$ref": "#/components/schemas/EvaluationParameters"}}, "additionalProperties": false, "type": "object", "required": ["model_names", "datum_filter", "parameters"], "title": "EvaluationRequest", "description": "Request for evaluation.\n\nAttributes\n----------\nmodel_names : str | list[str]\n    The model(s) to evaluate.\ndatum_filter : schemas.Filter\n    The filter object used to define what datums the model is evaluating over.\nparameters : DetectionParameters, optional\n    Any parameters that are used to modify an evaluation method."}, "EvaluationResponse": {"properties": {"id": {"type": "integer", "title": "Id"}, "model_name": {"type": "string", "title": "Model Name"}, "datum_filter": {"$ref": "#/components/schemas/Filter-Output"}, "parameters": {"$ref": "#/components/schemas/EvaluationParameters"}, "status": {"$ref": "#/components/schemas/EvaluationStatus"}, "metrics": {"items": {"$ref": "#/components/schemas/Metric"}, "type": "array", "title": "Metrics"}, "confusion_matrices": {"items": {"$ref": "#/components/schemas/ConfusionMatrixResponse"}, "type": "array", "title": "Confusion Matrices"}}, "additionalProperties": true, "type": "object", "required": ["id", "model_name", "datum_filter", "parameters", "status", "metrics", "confusion_matrices"], "title": "EvaluationResponse", "description": "An object for storing the returned results of a model evaluation (where groundtruths are compared with predictions to measure performance).\n\nAttributes\n----------\nid : int\n    The id of the evaluation.\nmodel_name : str\n    The name of the evaluated model.\ndatum_filter : schemas.Filter\n    The evaluation filter used in the evaluation.\nparameters : schemas.EvaluationParameters\n    Any parameters used by the evaluation method.\nstatus : str\n    The status of the evaluation.\nmetrics : List[Metric]\n    A list of metrics associated with the evaluation.\nconfusion_matrices: List[ConfusionMatrixResponse]\n    A list of confusion matrices associated with the evaluation."}, "EvaluationStatus": {"type": "string", "enum": ["pending", "running", "done", "failed", "deleting"], "title": "EvaluationStatus"}, "Filter-Input": {"properties": {"dataset_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Dataset Names"}, "dataset_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Dataset Metadata"}, "dataset_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter"}, "type": "array"}, {"type": "null"}], "title": "Dataset Geospatial"}, "model_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Model Names"}, "model_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Model Metadata"}, "model_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter"}, "type": "array"}, {"type": "null"}], "title": "Model Geospatial"}, "datum_uids": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Datum Uids"}, "datum_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Datum Metadata"}, "datum_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter"}, "type": "array"}, {"type": "null"}], "title": "Datum Geospatial"}, "task_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/TaskType"}, "type": "array"}, {"type": "null"}], "title": "Task Types"}, "annotation_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/AnnotationType"}, "type": "array"}, {"type": "null"}], "title": "Annotation Types"}, "annotation_geometric_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Annotation Geometric Area"}, "annotation_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Annotation Metadata"}, "annotation_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter"}, "type": "array"}, {"type": "null"}], "title": "Annotation Geospatial"}, "prediction_scores": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Prediction Scores"}, "labels": {"anyOf": [{"items": {"additionalProperties": {"type": "string"}, "type": "object"}, "type": "array"}, {"type": "null"}], "title": "Labels"}, "label_ids": {"anyOf": [{"items": {"type": "integer"}, "type": "array"}, {"type": "null"}], "title": "Label Ids"}, "label_keys": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Label Keys"}}, "additionalProperties": false, "type": "object", "title": "Filter", "description": "Used to filter Evaluations according to specific, user-defined criteria.\n\nAttributes\n----------\ndataset_names: List[str], default=None\n    A list of `Dataset` names to filter on.\ndataset_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter]], default=None\n    A dictionary of `Dataset` metadata to filter on.\ndataset_geospatial: List[GeospatialFilter]., default=None\n    A list of `Dataset` geospatial filters to filter on.\nmodel_names: List[str], default=None\n    A list of `Model` names to filter on.\nmodel_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter]], default=None\n    A dictionary of `Model` metadata to filter on.\nmodel_geospatial: List[GeospatialFilter], default=None\n    A list of `Model` geospatial filters to filter on.\ndatum_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter]], default=None\n    A dictionary of `Datum` metadata to filter on.\ndatum_geospatial: List[GeospatialFilter], default=None\n    A list of `Datum` geospatial filters to filter on.\ntask_types: List[TaskType], default=None\n    A list of task types to filter on.\nannotation_types: List[AnnotationType], default=None\n    A list of `Annotation` types to filter on.\nannotation_geometric_area: List[ValueFilter], default=None\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Annotation`'s geometric area.\nannotation_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter]], default=None\n    A dictionary of `Annotation` metadata to filter on.\nannotation_geospatial: List[GeospatialFilter], default=None\n    A list of `Annotation` geospatial filters to filter on.\nprediction_scores: List[ValueFilter], default=None\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Model`'s prediction scores.\nlabels: List[Dict[str, str]], default=None\n    A dictionary of `Labels' to filter on.\nlabel_ids: List[int], default=None\n    A list of `Label` IDs to filter on.\nlabel_keys: List[str] = None, default=None\n    A list of `Label` keys to filter on."}, "Filter-Output": {"properties": {"dataset_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Dataset Names"}, "dataset_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Dataset Metadata"}, "dataset_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter"}, "type": "array"}, {"type": "null"}], "title": "Dataset Geospatial"}, "model_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Model Names"}, "model_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Model Metadata"}, "model_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter"}, "type": "array"}, {"type": "null"}], "title": "Model Geospatial"}, "datum_uids": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Datum Uids"}, "datum_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Datum Metadata"}, "datum_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter"}, "type": "array"}, {"type": "null"}], "title": "Datum Geospatial"}, "task_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/TaskType"}, "type": "array"}, {"type": "null"}], "title": "Task Types"}, "annotation_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/AnnotationType"}, "type": "array"}, {"type": "null"}], "title": "Annotation Types"}, "annotation_geometric_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Annotation Geometric Area"}, "annotation_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Annotation Metadata"}, "annotation_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter"}, "type": "array"}, {"type": "null"}], "title": "Annotation Geospatial"}, "prediction_scores": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Prediction Scores"}, "labels": {"anyOf": [{"items": {"additionalProperties": {"type": "string"}, "type": "object"}, "type": "array"}, {"type": "null"}], "title": "Labels"}, "label_ids": {"anyOf": [{"items": {"type": "integer"}, "type": "array"}, {"type": "null"}], "title": "Label Ids"}, "label_keys": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Label Keys"}}, "additionalProperties": false, "type": "object", "title": "Filter", "description": "Used to filter Evaluations according to specific, user-defined criteria.\n\nAttributes\n----------\ndataset_names: List[str], default=None\n    A list of `Dataset` names to filter on.\ndataset_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter]], default=None\n    A dictionary of `Dataset` metadata to filter on.\ndataset_geospatial: List[GeospatialFilter]., default=None\n    A list of `Dataset` geospatial filters to filter on.\nmodel_names: List[str], default=None\n    A list of `Model` names to filter on.\nmodel_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter]], default=None\n    A dictionary of `Model` metadata to filter on.\nmodel_geospatial: List[GeospatialFilter], default=None\n    A list of `Model` geospatial filters to filter on.\ndatum_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter]], default=None\n    A dictionary of `Datum` metadata to filter on.\ndatum_geospatial: List[GeospatialFilter], default=None\n    A list of `Datum` geospatial filters to filter on.\ntask_types: List[TaskType], default=None\n    A list of task types to filter on.\nannotation_types: List[AnnotationType], default=None\n    A list of `Annotation` types to filter on.\nannotation_geometric_area: List[ValueFilter], default=None\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Annotation`'s geometric area.\nannotation_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter]], default=None\n    A dictionary of `Annotation` metadata to filter on.\nannotation_geospatial: List[GeospatialFilter], default=None\n    A list of `Annotation` geospatial filters to filter on.\nprediction_scores: List[ValueFilter], default=None\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Model`'s prediction scores.\nlabels: List[Dict[str, str]], default=None\n    A dictionary of `Labels' to filter on.\nlabel_ids: List[int], default=None\n    A list of `Label` IDs to filter on.\nlabel_keys: List[str] = None, default=None\n    A list of `Label` keys to filter on."}, "GeoJSONMultiPolygon": {"properties": {"type": {"type": "string", "title": "Type"}, "coordinates": {"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array", "title": "Coordinates"}}, "type": "object", "required": ["type", "coordinates"], "title": "GeoJSONMultiPolygon", "description": "Describes a multipolygon in geospatial coordinates.\n\nAttributes\n----------\ntype : str\n    The type of GeoJSON. Should be \"MultiPolygon\" for this class.\ncoordinates : List[List[List[List[float | int]]]]\n    A list of coordinates describing where the `MultiPolygon` lies.\n\nRaises\n------\nValueError\n    If the type isn't correct."}, "GeoJSONPoint": {"properties": {"type": {"type": "string", "title": "Type"}, "coordinates": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array", "title": "Coordinates"}}, "type": "object", "required": ["type", "coordinates"], "title": "GeoJSONPoint", "description": "Describes a point in geospatial coordinates.\n\nAttributes\n----------\ntype : str\n    The type of GeoJSON. Should be \"Point\" for this class.\ncoordinates : List[float | int]\n    A list of coordinates describing where the `Point` lies.\n\nRaises\n------\nValueError\n    If the type isn't correct.\n    If passed an incorrect number of coordinates."}, "GeoJSONPolygon": {"properties": {"type": {"type": "string", "title": "Type"}, "coordinates": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array", "title": "Coordinates"}}, "type": "object", "required": ["type", "coordinates"], "title": "GeoJSONPolygon", "description": "Describes a polygon in geospatial coordinates.\n\nAttributes\n----------\ntype : str\n    The type of GeoJSON. Should be \"Polygon\" for this class.\ncoordinates : List[List[List[float | int]]]\n    A list of coordinates describing where the `Polygon` lies.\n\nRaises\n------\nValueError\n    If the type isn't correct."}, "GeospatialFilter": {"properties": {"value": {"anyOf": [{"$ref": "#/components/schemas/GeoJSONPoint"}, {"$ref": "#/components/schemas/GeoJSONPolygon"}, {"$ref": "#/components/schemas/GeoJSONMultiPolygon"}], "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "intersect"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "GeospatialFilter", "description": "Used to filter on geospatial coordinates.\n\nAttributes\n----------\nvalue : GeoJSON\n    A dictionary containing a Point, Polygon, or MultiPolygon. Mirrors `shapely's` `GeoJSON` format.\noperator : str\n    The operator to use for comparison. Should be one of `intersect`, `inside`, or `outside`."}, "GroundTruth-Input": {"properties": {"datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Input"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["datum", "annotations"], "title": "GroundTruth", "description": "An object describing a groundtruth (e.g., a human-drawn bounding box on an image).\n\nAttributes\n----------\ndatum : Datum\n    The `Datum` associated with the `GroundTruth`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `GroundTruth`.\n\nRaises\n----------\nValueError\n    If the same label appears in two annotations.\n    If any rasters don't match their metadata."}, "GroundTruth-Output": {"properties": {"datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Output"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["datum", "annotations"], "title": "GroundTruth", "description": "An object describing a groundtruth (e.g., a human-drawn bounding box on an image).\n\nAttributes\n----------\ndatum : Datum\n    The `Datum` associated with the `GroundTruth`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `GroundTruth`.\n\nRaises\n----------\nValueError\n    If the same label appears in two annotations.\n    If any rasters don't match their metadata."}, "HTTPValidationError": {"properties": {"detail": {"items": {"$ref": "#/components/schemas/ValidationError"}, "type": "array", "title": "Detail"}}, "type": "object", "title": "HTTPValidationError"}, "Label": {"properties": {"key": {"type": "string", "title": "Key"}, "value": {"type": "string", "title": "Value"}, "score": {"anyOf": [{"type": "number"}, {"type": "null"}], "title": "Score"}}, "type": "object", "required": ["key", "value"], "title": "Label", "description": "An object for labeling datasets, models, and annotations.\n\nAttributes\n----------\nkey : str\n    A key for the `Label`.\nvalue : str\n    A value for the `Label`.\nscore : float\n    The score associated with the `Label` (where applicable).\n\nAttributes\n----------\nid : int\n    A unique ID for the `Label`."}, "Metric": {"properties": {"type": {"type": "string", "title": "Type"}, "parameters": {"anyOf": [{"type": "object"}, {"type": "null"}], "title": "Parameters"}, "value": {"anyOf": [{"type": "number"}, {"type": "object"}, {"type": "null"}], "title": "Value"}, "label": {"anyOf": [{"$ref": "#/components/schemas/Label"}, {"type": "null"}]}}, "type": "object", "required": ["type"], "title": "Metric", "description": "A metric response from the API.\n\nAttributes\n----------\ntype : str\n    The type of metric.\nparameters : dict\n    The parameters of the metric.\nvalue : float\n    The value of the metric.\nlabel : Label\n    The `Label` for the metric."}, "Model": {"properties": {"id": {"anyOf": [{"type": "integer"}, {"type": "null"}], "title": "Id"}, "name": {"type": "string", "title": "Name"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"type": "string"}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}, "geospatial": {"anyOf": [{"$ref": "#/components/schemas/GeoJSONPoint"}, {"$ref": "#/components/schemas/GeoJSONPolygon"}, {"$ref": "#/components/schemas/GeoJSONMultiPolygon"}, {"type": "null"}], "title": "Geospatial"}}, "additionalProperties": false, "type": "object", "required": ["name"], "title": "Model", "description": "A class describing a model that was trained on a particular dataset.\n\nAttributes\n----------\nid : int\n    The ID of the model.\nname : str\n    The name of the model.\nmetadata :  dict\n    A dictionary of metadata that describes the model.\ngeospatial : dict\n    A GeoJSON-style dictionary describing the geospatial metadata of the model.\n\nRaises\n----------\nValueError\n    If the name is invalid."}, "MultiPolygon-Input": {"properties": {"polygons": {"items": {"$ref": "#/components/schemas/Polygon-Input"}, "type": "array", "title": "Polygons"}}, "type": "object", "required": ["polygons"], "title": "MultiPolygon", "description": "Describes a multipolygon in geometric space.\n\nAttributes\n----------\npolygons: List[Polygon]\n    A list of polygons that make up the `MultiPolygon`.\n\nRaises\n------\nValueError\n    If less than three points are passed."}, "MultiPolygon-Output": {"properties": {"polygons": {"items": {"$ref": "#/components/schemas/Polygon-Output"}, "type": "array", "title": "Polygons"}}, "type": "object", "required": ["polygons"], "title": "MultiPolygon", "description": "Describes a multipolygon in geometric space.\n\nAttributes\n----------\npolygons: List[Polygon]\n    A list of polygons that make up the `MultiPolygon`.\n\nRaises\n------\nValueError\n    If less than three points are passed."}, "NumericFilter": {"properties": {"value": {"type": "number", "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "NumericFilter", "description": "Used to filter on numeric values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : float\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\">\", \"<\", \">=\", \"<=\", \"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "Point": {"properties": {"x": {"type": "number", "title": "X"}, "y": {"type": "number", "title": "Y"}}, "type": "object", "required": ["x", "y"], "title": "Point", "description": "Describes a point in geometric space.\n\nAttributes\n----------\nx : float\n    The x-coordinate of the point.\ny : float\n    The y-coordinate of the point.\n\nRaises\n------\nValueError\n    If an x or y-coordinate isn't passed."}, "Polygon-Input": {"properties": {"boundary": {"$ref": "#/components/schemas/BasicPolygon"}, "holes": {"anyOf": [{"items": {"$ref": "#/components/schemas/BasicPolygon"}, "type": "array"}, {"type": "null"}], "title": "Holes"}}, "type": "object", "required": ["boundary"], "title": "Polygon", "description": "Describes a polygon in geometric space.\n\nAttributes\n----------\nboundary : BasicPolygon\n    The polygon itself.\nholes : List[BasicPolygon]\n    Any holes that exist within the polygon."}, "Polygon-Output": {"properties": {"boundary": {"$ref": "#/components/schemas/BasicPolygon"}, "holes": {"anyOf": [{"items": {"$ref": "#/components/schemas/BasicPolygon"}, "type": "array"}, {"type": "null"}], "title": "Holes"}}, "type": "object", "required": ["boundary"], "title": "Polygon", "description": "Describes a polygon in geometric space.\n\nAttributes\n----------\nboundary : BasicPolygon\n    The polygon itself.\nholes : List[BasicPolygon]\n    Any holes that exist within the polygon."}, "Prediction-Input": {"properties": {"model_name": {"type": "string", "title": "Model Name"}, "datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Input"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["model_name", "datum", "annotations"], "title": "Prediction", "description": "An object describing a prediction (e.g., a machine-drawn bounding box on an image).\n\nAttributes\n----------\nmodel_name : str\n    The name of the model that produced the `Prediction`.\ndatum : Datum\n    The `Datum` associated with the `Prediction`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `Prediction`.\n\nRaises\n----------\nValueError\n    If the model name is invalid.\n    If no annotations are passed.\n    If the same label appears in two annotations.\n    If we're missing scores for any label.\n    If semantic segmentations contain a score.\n    If label scores for any key sum to more than 1."}, "Prediction-Output": {"properties": {"model_name": {"type": "string", "title": "Model Name"}, "datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Output"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["model_name", "datum", "annotations"], "title": "Prediction", "description": "An object describing a prediction (e.g., a machine-drawn bounding box on an image).\n\nAttributes\n----------\nmodel_name : str\n    The name of the model that produced the `Prediction`.\ndatum : Datum\n    The `Datum` associated with the `Prediction`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `Prediction`.\n\nRaises\n----------\nValueError\n    If the model name is invalid.\n    If no annotations are passed.\n    If the same label appears in two annotations.\n    If we're missing scores for any label.\n    If semantic segmentations contain a score.\n    If label scores for any key sum to more than 1."}, "Raster": {"properties": {"mask": {"type": "string", "title": "Mask"}}, "type": "object", "required": ["mask"], "title": "Raster", "description": "Describes a raster in geometric space.\n\nAttributes\n----------\nmask : str\n    The mask describing the raster.\n\nRaises\n------\nValueError\n    If the image format is not PNG.\n    If the image mode is not binary."}, "StringFilter": {"properties": {"value": {"type": "string", "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "StringFilter", "description": "Used to filter on string values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : str\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "TableStatus": {"type": "string", "enum": ["creating", "finalized", "deleting"], "title": "TableStatus"}, "TaskType": {"type": "string", "enum": ["skip", "empty", "classification", "object-detection", "semantic-segmentation"], "title": "TaskType"}, "Time": {"properties": {"time": {"type": "string", "title": "Time"}}, "additionalProperties": false, "type": "object", "required": ["time"], "title": "Time", "description": "An object describing a time.\n\nAttributes\n----------\ntime : str\n    Time in ISO format."}, "User": {"properties": {"email": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Email"}}, "type": "object", "title": "User", "description": "Defines an authorized user.\n\nAttributes\n----------\nemail : str\n    The user's email address."}, "ValidationError": {"properties": {"loc": {"items": {"anyOf": [{"type": "string"}, {"type": "integer"}]}, "type": "array", "title": "Location"}, "msg": {"type": "string", "title": "Message"}, "type": {"type": "string", "title": "Error Type"}}, "type": "object", "required": ["loc", "msg", "type"], "title": "ValidationError"}}, "securitySchemes": {"OptionalHTTPBearer": {"type": "http", "scheme": "bearer"}}}}