{"openapi": "3.1.0", "info": {"title": "FastAPI", "version": "0.1.0"}, "paths": {"/groundtruths": {"post": {"tags": ["GroundTruths"], "summary": "Create Groundtruths", "description": "Create a ground truth in the database.\n\nPOST Endpoint: `/groundtruths`\n\nParameters\n----------\ngroundtruths : list[schemas.GroundTruth]\n    The ground truths to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.\nHTTPException (409)\n    If the dataset has been finalized, or if the datum already exists.", "operationId": "create_groundtruths_groundtruths_post", "requestBody": {"content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/GroundTruth-Input"}, "type": "array", "title": "Groundtruths"}}}, "required": true}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/groundtruths/dataset/{dataset_name}/datum/{uid}": {"get": {"tags": ["GroundTruths"], "summary": "Get Groundtruth", "description": "Fetch a ground truth from the database.\n\nGET Endpoint: `/groundtruths/dataset/{dataset_name}/datum/{uid}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset to fetch the ground truth from.\nuid : str\n    The UID of the ground truth.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.GroundTruth\n    Thee ground truth requested by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum does not exist.", "operationId": "get_groundtruth_groundtruths_dataset__dataset_name__datum__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/GroundTruth-Output"}, {"type": "null"}], "title": "Response Get Groundtruth Groundtruths Dataset  Dataset Name  Datum  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/predictions": {"post": {"tags": ["Predictions"], "summary": "Create Predictions", "description": "Create a prediction in the database.\n\nPOST Endpoint: `/predictions`\n\nParameters\n----------\npredictions : list[schemas.Prediction]\n    The predictions to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset, model, or datum doesn't exist.\nHTTPException (409)\n    If the model has been finalized, or if the dataset has not been finalized.", "operationId": "create_predictions_predictions_post", "requestBody": {"content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Prediction-Input"}, "type": "array", "title": "Predictions"}}}, "required": true}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/predictions/model/{model_name}/dataset/{dataset_name}/datum/{uid}": {"get": {"tags": ["Predictions"], "summary": "Get Prediction", "description": "Fetch a prediction from the database.\n\nGET Endpoint: `/predictions/model/{model_name}/dataset/{dataset_name}/datum/{uid}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model associated with the prediction.\ndataset_name : str\n    The name of the dataset associated with the prediction.\nuid : str\n    The UID associated with the prediction.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Prediction\n    The requested prediction.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.", "operationId": "get_prediction_predictions_model__model_name__dataset__dataset_name__datum__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}, {"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Prediction-Output"}, {"type": "null"}], "title": "Response Get Prediction Predictions Model  Model Name  Dataset  Dataset Name  Datum  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/labels": {"get": {"tags": ["Labels"], "summary": "Get Labels", "description": "Fetch all labels in the database.\n\nGET Endpoint: `/labels`\n\nParameters\n----------\nfilters : schemas.Filter, optional\n    An optional filter to constrain results by.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[schemas.Label]\n    A list of all labels in the database.", "operationId": "get_labels_labels_get", "requestBody": {"content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Filter-Input"}, {"type": "null"}], "title": "Filters"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Response Get Labels Labels Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/labels/dataset/{dataset_name}": {"get": {"tags": ["Labels"], "summary": "Get Labels From Dataset", "description": "Fetch all labels for a particular dataset from the database.\n\nGET Endpoint: `/labels/dataset/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[schemas.Label]\n    A list of all labels associated with the dataset in the database.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_labels_from_dataset_labels_dataset__dataset_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Label"}, "title": "Response Get Labels From Dataset Labels Dataset  Dataset Name  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/labels/model/{model_name}": {"get": {"tags": ["Labels"], "summary": "Get Labels From Model", "description": "Fetch all labels for a particular model from the database.\n\nGET Endpoint: `/labels/model/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[schemas.Label]\n    A list of all labels associated with the model in the database.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.", "operationId": "get_labels_from_model_labels_model__model_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Label"}, "title": "Response Get Labels From Model Labels Model  Model Name  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets": {"get": {"tags": ["Datasets"], "summary": "Get Datasets", "description": "Fetch all datasets from the database.\n\nGET Endpoint: `/datasets`\n\nParameters\n----------\nfilters : schemas.Filter, optional\n    An optional filter to constrain results by.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[schemas.Dataset]\n    A list of all datasets stored in the database.", "operationId": "get_datasets_datasets_get", "requestBody": {"content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Filter-Input"}, {"type": "null"}], "title": "Filters"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Dataset"}, "type": "array", "title": "Response Get Datasets Datasets Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}, "post": {"tags": ["Datasets"], "summary": "Create Dataset", "description": "Create a dataset in the database.\n\nPOST Endpoint: `/datasets`\n\nParameters\n----------\ndataset : schemas.Dataset\n    The dataset to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (409)\n    If the dataset already exists.", "operationId": "create_dataset_datasets_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Dataset"}}}, "required": true}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/datasets/{dataset_name}": {"get": {"tags": ["Datasets"], "summary": "Get Dataset", "description": "Fetch a particular dataset from the database.\n\nGET Endpoint: `/datasets/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Dataset\n    The requested dataset.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_dataset_datasets__dataset_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Dataset"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Datasets"], "summary": "Delete Dataset", "description": "Delete a dataset from the database.\n\nDELETE Endpoint: `/datasets/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nbackground_tasks: BackgroundTasks\n    A FastAPI `BackgroundTasks` object to process the deletion asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.\nHTTPException (409)\n    If the dataset isn't in the correct state to be deleted.", "operationId": "delete_dataset_datasets__dataset_name__delete", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}/status": {"get": {"tags": ["Datasets"], "summary": "Get Dataset Status", "description": "Fetch the status of a dataset.\n\nGET Endpoint: `/datasets/{dataset_name}/status`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nenums.TableStatus\n    The requested state.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_dataset_status_datasets__dataset_name__status_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TableStatus"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}/summary": {"get": {"tags": ["Datasets"], "summary": "Get Dataset Summary", "description": "Get the summary of a dataset.\n\nGET Endpoint: `/datasets/{dataset_name}/summary`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.DatasetSummary\n    The dataset summary.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_dataset_summary_datasets__dataset_name__summary_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DatasetSummary"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}/finalize": {"put": {"tags": ["Datasets"], "summary": "Finalize Dataset", "description": "Finalizes a dataset for evaluation.\n\nPUT Endpoint: `/datasets/{dataset_name}/finalize`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (409)\n    If the dataset is empty.\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "finalize_dataset_datasets__dataset_name__finalize_put", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/data": {"get": {"tags": ["Datums"], "summary": "Get Datums", "description": "Fetch all datums for a particular dataset.\n\nGET Endpoint: `/data`\n\nParameters\n----------\nfilters : schemas.Filter, optional\n    An optional filter to constrain results by.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[schemas.Datum]\n    A list of datums.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.", "operationId": "get_datums_data_get", "requestBody": {"content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Filter-Input"}, {"type": "null"}], "title": "Filters"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Datum"}, "type": "array", "title": "Response Get Datums Data Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/data/dataset/{dataset_name}/uid/{uid}": {"get": {"tags": ["Datums"], "summary": "Get Datum", "description": "Fetch a particular datum.\nGET Endpoint: `/data/dataset/{dataset_name}/uid/{uid}`\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nuid : str\n    The UID of the datum.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\nReturns\n-------\nschemas.Datum\n    The requested datum.\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.", "operationId": "get_datum_data_dataset__dataset_name__uid__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Datum"}, {"type": "null"}], "title": "Response Get Datum Data Dataset  Dataset Name  Uid  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models": {"get": {"tags": ["Models"], "summary": "Get Models", "description": "Fetch all models in the database.\n\nGET Endpoint: `/models`\n\nParameters\n----------\nfilters : schemas.Filter, optional\n    An optional filter to constrain results by.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[schemas.Model]\n    A list of models.", "operationId": "get_models_models_get", "requestBody": {"content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Filter-Input"}, {"type": "null"}], "title": "Filters"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Model"}, "type": "array", "title": "Response Get Models Models Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}, "post": {"tags": ["Models"], "summary": "Create Model", "description": "Create a model in the database.\n\nPOST Endpoint: `/models`\n\nParameters\n----------\nmodel : schemas.Model\n    The model to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.\nHTTPException (409)\n    If the dataset has been finalized, or if the datum already exists.", "operationId": "create_model_models_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Model"}}}, "required": true}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/models/{model_name}": {"get": {"tags": ["Models"], "summary": "Get Model", "description": "Fetch a particular model.\n\nGET Endpoint: `/models/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Model\n    The requested model.\n\nRaises\n------\nHTTPException (404)\n    If the model datum doesn't exist.", "operationId": "get_model_models__model_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Model"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Models"], "summary": "Delete Model", "description": "Delete a model from the database.\n\nDELETE Endpoint: `/models/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.\nHTTPException (409)\n    If the model isn't in the correct state to be deleted.", "operationId": "delete_model_models__model_name__delete", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models/{model_name}/eval-requests": {"get": {"tags": ["Models"], "summary": "Get Model Eval Requests", "description": "Fetch a particular model.\n\nGET Endpoint: `/models/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[EvaluationResponse]\n    The evaluation requessts associated to the model\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.", "operationId": "get_model_eval_requests_models__model_name__eval_requests_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/EvaluationResponse"}, "title": "Response Get Model Eval Requests Models  Model Name  Eval Requests Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models/{model_name}/dataset/{dataset_name}/status": {"get": {"tags": ["Models"], "summary": "Get Model Status", "description": "Fetch the status of a model over a dataset.\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nenums.TableStatus\n    The requested state.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.", "operationId": "get_model_status_models__model_name__dataset__dataset_name__status_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TableStatus"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models/{model_name}/datasets/{dataset_name}/finalize": {"put": {"tags": ["Models"], "summary": "Finalize Inferences", "description": "Finalize a model prior to evaluation.\n\nPUT Endpoint: `/models/{model_name}/datasets/{dataset_name}/finalize`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n\nRaises\n------\nHTTPException (400)\n    If the dataset or model are empty.\nHTTPException (404)\n    If the dataset or model do not exist.", "operationId": "finalize_inferences_models__model_name__datasets__dataset_name__finalize_put", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/evaluations": {"post": {"tags": ["Evaluations"], "summary": "Create Or Get Evaluations", "description": "Create a new evaluation.\n\nPOST Endpoint: `/evaluations`\n\nParameters\n----------\njob_request: schemas.EvaluationJob\n    The job request for the evaluation.\nbackground_tasks: BackgroundTasks\n    A FastAPI `BackgroundTasks` object to process the creation asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[schemas.EvaluationResponse]\n    A list of evaluation response objects.\n\nRaises\n------\nHTTPException (400)\n    If the task type of the evaluation job doesn't exist, or if another ValueError is thrown.\nHTTPException (404)\n    If the dataset or model does not exist.\nHTTPException (405)\n    If the dataset or model hasn't been finalized.\nHTTPException (409)\n    If there is a state exception when creating the evaluation.", "operationId": "create_or_get_evaluations_evaluations_post", "security": [{"OptionalHTTPBearer": []}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EvaluationRequest"}}}}, "responses": {"202": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/EvaluationResponse"}, "title": "Response Create Or Get Evaluations Evaluations Post"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "get": {"tags": ["Evaluations"], "summary": "Get Evaluations", "description": "Fetch all metrics associated with user-supplied dataset and model names. Users\nmay query using model names, dataset names, or both. All metrics for all specified\nmodels and datasets will be returned in a list of Evaluations.\n\nThis endpoint can handle multiple dataset and model names. For example, you can use\n`/evaluations?models=first_model,second_model&datasets=test_dataset` to get all evaluations\nrelated to `test_dataset` and either `first_model` or `second_model`.\n\nGET Endpoint: `/evaluations`\n\nParameters\n----------\ndatasets : str\n    An optional set of dataset names to return metrics for\nmodels : str\n    An optional set of model names to return metrics for\nevaluation_ids : str\n    An optional set of evaluation_ids to return metrics for\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nlist[schemas.Evaluation]\n    A list of evaluations.\n\nRaises\n------\nHTTPException (400)\n    If a ValueError is thrown.\nHTTPException (404)\n    If the dataset or model doesn't exist.", "operationId": "get_evaluations_evaluations_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "datasets", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Datasets"}}, {"name": "models", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Models"}}, {"name": "evaluation_ids", "in": "query", "required": false, "schema": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Evaluation Ids"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/EvaluationResponse"}, "title": "Response Get Evaluations Evaluations Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/token": {"post": {"tags": ["Authentication"], "summary": "Login For Access Token", "operationId": "login_for_access_token_token_post", "requestBody": {"content": {"application/x-www-form-urlencoded": {"schema": {"$ref": "#/components/schemas/Body_login_for_access_token_token_post"}}}, "required": true}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "string", "title": "Response Login For Access Token Token Post"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/api-version": {"get": {"tags": ["Info"], "summary": "Get Api Version", "description": "Return the API's version.\n\nGET Endpoint: `/api-version`\n\nReturns\n-------\nschemas.APIVersion\n    A response object containing the API's version number.", "operationId": "get_api_version_api_version_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/APIVersion"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/health": {"get": {"tags": ["Status"], "summary": "Health", "description": "Return 200 if the service is up.\n\nGET Endpoint: `/health`\n\nReturns\n-------\nschemas.Health\n    A response indicating that the service is up and running.", "operationId": "health_health_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}}}}, "/ready": {"get": {"tags": ["Status"], "summary": "Ready", "description": "Return 200 if the service is up and connected to the database.\n\nGET Endpoint: `/ready`\n\nReturns\n-------\nschemas.Readiness\n    A response indicating that the service is up and connected to the database.", "operationId": "ready_ready_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}}}}}, "components": {"schemas": {"APIVersion": {"properties": {"api_version": {"type": "string", "title": "Api Version"}}, "type": "object", "required": ["api_version"], "title": "APIVersion", "description": "Defines an API version string which is sent back to the user after their authentication is confirmed.\n\nAttributes\n----------\napi_version : str\n    The API version."}, "Annotation-Input": {"properties": {"task_type": {"$ref": "#/components/schemas/TaskType"}, "labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Labels"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}, "bounding_box": {"anyOf": [{"$ref": "#/components/schemas/BoundingBox-Input"}, {"type": "null"}]}, "polygon": {"anyOf": [{"$ref": "#/components/schemas/Polygon-Input"}, {"type": "null"}]}, "multipolygon": {"anyOf": [{"$ref": "#/components/schemas/MultiPolygon-Input"}, {"type": "null"}]}, "raster": {"anyOf": [{"$ref": "#/components/schemas/Raster"}, {"type": "null"}]}}, "additionalProperties": false, "type": "object", "required": ["task_type", "labels"], "title": "Annotation", "description": "A class used to annotate `GroundTruths` and `Predictions`.\n\nAttributes\n----------\ntask_type: TaskType\n    The task type associated with the `Annotation`.\nlabels: List[Label]\n    A list of labels to use for the `Annotation`.\nmetadata: MetadataType\n    A dictionary of metadata that describes the `Annotation`.\nbounding_box: BoundingBox\n    A bounding box to assign to the `Annotation`.\npolygon: Polygon\n    A polygon to assign to the `Annotation`.\nmultipolygon: MultiPolygon\n    A multipolygon to assign to the `Annotation`.\nraster: Raster\n    A raster to assign to the `Annotation`.\njsonb: Dict\n    A jsonb to assign to the `Annotation`.\n\nRaises\n----------\nValueError\n    If no labels are passed.\n    If the same label appears in two annotations."}, "Annotation-Output": {"properties": {"task_type": {"$ref": "#/components/schemas/TaskType"}, "labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Labels"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}, "bounding_box": {"anyOf": [{"$ref": "#/components/schemas/BoundingBox-Output"}, {"type": "null"}]}, "polygon": {"anyOf": [{"$ref": "#/components/schemas/Polygon-Output"}, {"type": "null"}]}, "multipolygon": {"anyOf": [{"$ref": "#/components/schemas/MultiPolygon-Output"}, {"type": "null"}]}, "raster": {"anyOf": [{"$ref": "#/components/schemas/Raster"}, {"type": "null"}]}}, "additionalProperties": false, "type": "object", "required": ["task_type", "labels"], "title": "Annotation", "description": "A class used to annotate `GroundTruths` and `Predictions`.\n\nAttributes\n----------\ntask_type: TaskType\n    The task type associated with the `Annotation`.\nlabels: List[Label]\n    A list of labels to use for the `Annotation`.\nmetadata: MetadataType\n    A dictionary of metadata that describes the `Annotation`.\nbounding_box: BoundingBox\n    A bounding box to assign to the `Annotation`.\npolygon: Polygon\n    A polygon to assign to the `Annotation`.\nmultipolygon: MultiPolygon\n    A multipolygon to assign to the `Annotation`.\nraster: Raster\n    A raster to assign to the `Annotation`.\njsonb: Dict\n    A jsonb to assign to the `Annotation`.\n\nRaises\n----------\nValueError\n    If no labels are passed.\n    If the same label appears in two annotations."}, "AnnotationType": {"type": "string", "enum": ["none", "box", "polygon", "multipolygon", "raster"], "title": "AnnotationType"}, "BasicPolygon": {"properties": {"points": {"items": {"$ref": "#/components/schemas/Point"}, "type": "array", "title": "Points"}}, "type": "object", "required": ["points"], "title": "BasicPolygon", "description": "Describes a polygon in geometric space.\n\nAttributes\n----------\npoints: Tuple[Point, Point]\n    The coordinates of the polygon.\n\nRaises\n------\nValueError\n    If less than three points are passed."}, "Body_login_for_access_token_token_post": {"properties": {"grant_type": {"anyOf": [{"type": "string", "pattern": "password"}, {"type": "null"}], "title": "Grant Type"}, "username": {"type": "string", "title": "Username"}, "password": {"type": "string", "title": "Password"}, "scope": {"type": "string", "title": "Scope", "default": ""}, "client_id": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Client Id"}, "client_secret": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Client Secret"}}, "type": "object", "required": ["username", "password"], "title": "Body_login_for_access_token_token_post"}, "BooleanFilter": {"properties": {"value": {"type": "boolean", "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "BooleanFilter", "description": "Used to filter on boolean values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : bool\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "BoundingBox-Input": {"properties": {"polygon": {"$ref": "#/components/schemas/BasicPolygon"}}, "type": "object", "required": ["polygon"], "title": "BoundingBox", "description": "Describes a bounding box in geometric space.\n\nAttributes\n----------\npolygons: BasicPolygon\n    A polygon describing the bounding box.\n\nRaises\n------\nValueError\n    If the number of points != 4."}, "BoundingBox-Output": {"properties": {"polygon": {"$ref": "#/components/schemas/BasicPolygon"}}, "type": "object", "required": ["polygon"], "title": "BoundingBox", "description": "Describes a bounding box in geometric space.\n\nAttributes\n----------\npolygons: BasicPolygon\n    A polygon describing the bounding box.\n\nRaises\n------\nValueError\n    If the number of points != 4."}, "ConfusionMatrixEntry": {"properties": {"prediction": {"type": "string", "title": "Prediction"}, "groundtruth": {"type": "string", "title": "Groundtruth"}, "count": {"type": "integer", "title": "Count"}}, "type": "object", "required": ["prediction", "groundtruth", "count"], "title": "ConfusionMatrixEntry", "description": "Describes one element in a confusion matrix.\n\nAttributes\n----------\nprediction : str\n    The prediction.\ngroundtruth : str\n    The ground truth.\ncount : int\n    The value of the element in the matrix."}, "ConfusionMatrixResponse": {"properties": {"label_key": {"type": "string", "title": "Label Key"}, "entries": {"items": {"$ref": "#/components/schemas/ConfusionMatrixEntry"}, "type": "array", "title": "Entries"}}, "type": "object", "required": ["label_key", "entries"], "title": "ConfusionMatrixResponse", "description": "A response object used for HTTP responses since they won't contain matrix or label map attributes."}, "Dataset": {"properties": {"id": {"anyOf": [{"type": "integer"}, {"type": "null"}], "title": "Id"}, "name": {"type": "string", "title": "Name"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}}, "additionalProperties": false, "type": "object", "required": ["name"], "title": "Dataset", "description": "A class describing a given dataset.\n\nAttributes\n----------\nid : int\n    The ID of the dataset.\nname : str\n    The name of the dataset.\nmetadata :  MetadataType\n    A dictionary of metadata that describes the dataset.\n\nRaises\n----------\nValueError\n    If the name is invalid."}, "DatasetSummary": {"properties": {"name": {"type": "string", "title": "Name"}, "num_datums": {"type": "integer", "title": "Num Datums"}, "num_annotations": {"type": "integer", "title": "Num Annotations"}, "num_bounding_boxes": {"type": "integer", "title": "Num Bounding Boxes"}, "num_polygons": {"type": "integer", "title": "Num Polygons"}, "num_groundtruth_multipolygons": {"type": "integer", "title": "Num Groundtruth Multipolygons"}, "num_rasters": {"type": "integer", "title": "Num Rasters"}, "task_types": {"items": {"$ref": "#/components/schemas/TaskType"}, "type": "array", "title": "Task Types"}, "labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Labels"}, "datum_metadata": {"items": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object"}, "type": "array", "title": "Datum Metadata"}, "annotation_metadata": {"items": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object"}, "type": "array", "title": "Annotation Metadata"}}, "type": "object", "required": ["name", "num_datums", "num_annotations", "num_bounding_boxes", "num_polygons", "num_groundtruth_multipolygons", "num_rasters", "task_types", "labels", "datum_metadata", "annotation_metadata"], "title": "DatasetSummary"}, "Date": {"properties": {"date": {"type": "string", "title": "Date"}}, "additionalProperties": false, "type": "object", "required": ["date"], "title": "Date", "description": "An object describing a date.\n\nAttributes\n----------\ndate : str\n    Date in ISO format."}, "DateTime": {"properties": {"datetime": {"type": "string", "title": "Datetime"}}, "additionalProperties": false, "type": "object", "required": ["datetime"], "title": "DateTime", "description": "An object describing a date and time.\n\nAttributes\n----------\ndatetime : str\n    Datetime in ISO format."}, "DateTimeFilter": {"properties": {"value": {"anyOf": [{"$ref": "#/components/schemas/DateTime"}, {"$ref": "#/components/schemas/Date"}, {"$ref": "#/components/schemas/Time"}, {"$ref": "#/components/schemas/Duration"}], "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "DateTimeFilter", "description": "Used to filter on datetime values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : DateTime\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\">\", \"<\", \">=\", \"<=\", \"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "Datum": {"properties": {"uid": {"type": "string", "title": "Uid"}, "dataset_name": {"type": "string", "title": "Dataset Name"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}}, "additionalProperties": false, "type": "object", "required": ["uid", "dataset_name"], "title": "Datum", "description": "A class used to store datum about `GroundTruths` and `Predictions`.\n\nAttributes\n----------\nuid : str\n    The UID of the `Datum`.\ndataset_name : str\n    The name of the dataset to associate the `Datum` with.\nmetadata : MetadataType\n    A dictionary of metadata that describes the `Datum`.\n\nRaises\n----------\nValueError\n    If the dataset or UID is invalid."}, "Duration": {"properties": {"duration": {"type": "string", "title": "Duration"}}, "additionalProperties": false, "type": "object", "required": ["duration"], "title": "Duration", "description": "An object describing a time duration.\n\nAttributes\n----------\nduration : str\n    Time duration in seconds."}, "EvaluationParameters": {"properties": {"task_type": {"$ref": "#/components/schemas/TaskType"}, "convert_annotations_to_type": {"anyOf": [{"$ref": "#/components/schemas/AnnotationType"}, {"type": "null"}]}, "iou_thresholds_to_compute": {"anyOf": [{"items": {"type": "number"}, "type": "array"}, {"type": "null"}], "title": "Iou Thresholds To Compute"}, "iou_thresholds_to_return": {"anyOf": [{"items": {"type": "number"}, "type": "array"}, {"type": "null"}], "title": "Iou Thresholds To Return"}, "label_map": {"anyOf": [{"items": {"items": {"items": {"type": "string"}, "type": "array"}, "type": "array"}, "type": "array"}, {"type": "null"}], "title": "Label Map"}}, "additionalProperties": false, "type": "object", "required": ["task_type"], "title": "EvaluationParameters", "description": "Defines parameters for evaluation methods.\n\nAttributes\n----------\nconvert_annotations_to_type: AnnotationType | None = None\n    The type to convert all annotations to.\niou_thresholds_to_compute : List[float], optional\n    A list of floats describing which Intersection over Unions (IoUs) to use when calculating metrics (i.e., mAP).\niou_thresholds_to_return: List[float], optional\n    A list of floats describing which Intersection over Union (IoUs) thresholds to calculate a metric for. Must be a subset of `iou_thresholds_to_compute`.\nlabel_map : LabelMapType, optional\n    Optional mapping of individual labels to a grouper label. Useful when you need to evaluate performance using labels that differ across datasets and models."}, "EvaluationRequest": {"properties": {"model_names": {"items": {"type": "string"}, "type": "array", "title": "Model Names"}, "datum_filter": {"$ref": "#/components/schemas/Filter-Input"}, "parameters": {"$ref": "#/components/schemas/EvaluationParameters"}}, "additionalProperties": false, "type": "object", "required": ["model_names", "datum_filter", "parameters"], "title": "EvaluationRequest", "description": "Request for evaluation.\n\nAttributes\n----------\nmodel_names : str | list[str]\n    The model(s) to evaluate.\ndatum_filter : schemas.Filter\n    The filter object used to define what datums the model is evaluating over.\nparameters : DetectionParameters, optional\n    Any parameters that are used to modify an evaluation method."}, "EvaluationResponse": {"properties": {"id": {"type": "integer", "title": "Id"}, "model_name": {"type": "string", "title": "Model Name"}, "datum_filter": {"$ref": "#/components/schemas/Filter-Output"}, "parameters": {"$ref": "#/components/schemas/EvaluationParameters"}, "status": {"$ref": "#/components/schemas/EvaluationStatus"}, "metrics": {"anyOf": [{"items": {"$ref": "#/components/schemas/Metric"}, "type": "array"}, {"type": "null"}], "title": "Metrics"}, "confusion_matrices": {"anyOf": [{"items": {"$ref": "#/components/schemas/ConfusionMatrixResponse"}, "type": "array"}, {"type": "null"}], "title": "Confusion Matrices"}}, "additionalProperties": true, "type": "object", "required": ["id", "model_name", "datum_filter", "parameters", "status"], "title": "EvaluationResponse", "description": "An object for storing the returned results of a model evaluation (where groundtruths are compared with predictions to measure performance).\n\nAttributes\n----------\nid : int\n    The ID of the evaluation.\nmodel_name : str\n    The name of the evaluated model.\ndatum_filter : schemas.Filter\n    The evaluation filter used in the evaluation.\nparameters : schemas.EvaluationParameters\n    Any parameters used by the evaluation method.\nstatus : str\n    The status of the evaluation.\nmetrics : List[Metric]\n    A list of metrics associated with the evaluation.\nconfusion_matrices: List[ConfusionMatrixResponse]\n    A list of confusion matrices associated with the evaluation."}, "EvaluationStatus": {"type": "string", "enum": ["pending", "running", "done", "failed", "deleting"], "title": "EvaluationStatus"}, "Filter-Input": {"properties": {"dataset_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Dataset Names"}, "dataset_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Dataset Metadata"}, "model_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Model Names"}, "model_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Model Metadata"}, "datum_uids": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Datum Uids"}, "datum_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Datum Metadata"}, "task_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/TaskType"}, "type": "array"}, {"type": "null"}], "title": "Task Types"}, "annotation_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Annotation Metadata"}, "require_bounding_box": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Bounding Box"}, "bounding_box_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Bounding Box Area"}, "require_polygon": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Polygon"}, "polygon_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Polygon Area"}, "require_multipolygon": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Multipolygon"}, "multipolygon_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Multipolygon Area"}, "require_raster": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Raster"}, "raster_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Raster Area"}, "labels": {"anyOf": [{"items": {"additionalProperties": {"type": "string"}, "type": "object"}, "type": "array"}, {"type": "null"}], "title": "Labels"}, "label_ids": {"anyOf": [{"items": {"type": "integer"}, "type": "array"}, {"type": "null"}], "title": "Label Ids"}, "label_keys": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Label Keys"}, "label_scores": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Label Scores"}}, "additionalProperties": false, "type": "object", "title": "Filter", "description": "Used to filter Evaluations according to specific, user-defined criteria.\n\nAttributes\n----------\ndataset_names: List[str], default=None\n    A list of `Dataset` names to filter on.\ndataset_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Dataset` metadata to filter on.\nmodel_names: List[str], default=None\n    A list of `Model` names to filter on.\nmodel_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Model` metadata to filter on.\ndatum_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Datum` metadata to filter on.\ntask_types: List[TaskType], default=None\n    A list of task types to filter on.\nannotation_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Annotation` metadata to filter on.\nrequire_bounding_box : bool, optional\n    A toggle for filtering by bounding boxes.\nbounding_box_area : bool, optional\n    An optional constraint to filter by bounding box area.\nrequire_polygon : bool, optional\n    A toggle for filtering by polygons.\npolygon_area : bool, optional\n    An optional constraint to filter by polygon area.\nrequire_multipolygon : bool, optional\n    A toggle for filtering by multipolygons.\nmultipolygon_area : bool, optional\n    An optional constraint to filter by multipolygon area.\nrequire_raster : bool, optional\n    A toggle for filtering by rasters.\nraster_area : bool, optional\n    An optional constraint to filter by raster area.\nlabels: List[Dict[str, str]], default=None\n    A dictionary of `Labels' to filter on.\nlabel_ids: List[int], default=None\n    A list of `Label` IDs to filter on.\nlabel_keys: List[str] = None, default=None\n    A list of `Label` keys to filter on.\nlabel_scores: List[ValueFilter], default=None\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Model`'s prediction scores."}, "Filter-Output": {"properties": {"dataset_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Dataset Names"}, "dataset_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Dataset Metadata"}, "model_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Model Names"}, "model_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Model Metadata"}, "datum_uids": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Datum Uids"}, "datum_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Datum Metadata"}, "task_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/TaskType"}, "type": "array"}, {"type": "null"}], "title": "Task Types"}, "annotation_metadata": {"anyOf": [{"additionalProperties": {"items": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"$ref": "#/components/schemas/NumericFilter"}, {"$ref": "#/components/schemas/DateTimeFilter"}, {"$ref": "#/components/schemas/BooleanFilter"}, {"$ref": "#/components/schemas/GeospatialFilter"}]}, "type": "array"}, "type": "object"}, {"type": "null"}], "title": "Annotation Metadata"}, "require_bounding_box": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Bounding Box"}, "bounding_box_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Bounding Box Area"}, "require_polygon": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Polygon"}, "polygon_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Polygon Area"}, "require_multipolygon": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Multipolygon"}, "multipolygon_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Multipolygon Area"}, "require_raster": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "title": "Require Raster"}, "raster_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Raster Area"}, "labels": {"anyOf": [{"items": {"additionalProperties": {"type": "string"}, "type": "object"}, "type": "array"}, {"type": "null"}], "title": "Labels"}, "label_ids": {"anyOf": [{"items": {"type": "integer"}, "type": "array"}, {"type": "null"}], "title": "Label Ids"}, "label_keys": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Label Keys"}, "label_scores": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Label Scores"}}, "additionalProperties": false, "type": "object", "title": "Filter", "description": "Used to filter Evaluations according to specific, user-defined criteria.\n\nAttributes\n----------\ndataset_names: List[str], default=None\n    A list of `Dataset` names to filter on.\ndataset_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Dataset` metadata to filter on.\nmodel_names: List[str], default=None\n    A list of `Model` names to filter on.\nmodel_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Model` metadata to filter on.\ndatum_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Datum` metadata to filter on.\ntask_types: List[TaskType], default=None\n    A list of task types to filter on.\nannotation_metadata: Dict[str, list[StringFilter | NumericFilter | DateTimeFilter | BooleanFilter | GeospatialFilter]], default=None\n    A dictionary of `Annotation` metadata to filter on.\nrequire_bounding_box : bool, optional\n    A toggle for filtering by bounding boxes.\nbounding_box_area : bool, optional\n    An optional constraint to filter by bounding box area.\nrequire_polygon : bool, optional\n    A toggle for filtering by polygons.\npolygon_area : bool, optional\n    An optional constraint to filter by polygon area.\nrequire_multipolygon : bool, optional\n    A toggle for filtering by multipolygons.\nmultipolygon_area : bool, optional\n    An optional constraint to filter by multipolygon area.\nrequire_raster : bool, optional\n    A toggle for filtering by rasters.\nraster_area : bool, optional\n    An optional constraint to filter by raster area.\nlabels: List[Dict[str, str]], default=None\n    A dictionary of `Labels' to filter on.\nlabel_ids: List[int], default=None\n    A list of `Label` IDs to filter on.\nlabel_keys: List[str] = None, default=None\n    A list of `Label` keys to filter on.\nlabel_scores: List[ValueFilter], default=None\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Model`'s prediction scores."}, "GeoJSONMultiPolygon": {"properties": {"type": {"type": "string", "title": "Type"}, "coordinates": {"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array", "title": "Coordinates"}}, "type": "object", "required": ["type", "coordinates"], "title": "GeoJSONMultiPolygon", "description": "Describes a multipolygon in geospatial coordinates.\n\nAttributes\n----------\ntype : str\n    The type of GeoJSON. Should be \"MultiPolygon\" for this class.\ncoordinates : List[List[List[List[float | int]]]]\n    A list of coordinates describing where the `MultiPolygon` lies.\n\nRaises\n------\nValueError\n    If the type isn't correct."}, "GeoJSONPoint": {"properties": {"type": {"type": "string", "title": "Type"}, "coordinates": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array", "title": "Coordinates"}}, "type": "object", "required": ["type", "coordinates"], "title": "GeoJSONPoint", "description": "Describes a point in geospatial coordinates.\n\nAttributes\n----------\ntype : str\n    The type of GeoJSON. Should be \"Point\" for this class.\ncoordinates : List[float | int]\n    A list of coordinates describing where the `Point` lies.\n\nRaises\n------\nValueError\n    If the type isn't correct.\n    If passed an incorrect number of coordinates."}, "GeoJSONPolygon": {"properties": {"type": {"type": "string", "title": "Type"}, "coordinates": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array", "title": "Coordinates"}}, "type": "object", "required": ["type", "coordinates"], "title": "GeoJSONPolygon", "description": "Describes a polygon in geospatial coordinates.\n\nAttributes\n----------\ntype : str\n    The type of GeoJSON. Should be \"Polygon\" for this class.\ncoordinates : List[List[List[float | int]]]\n    A list of coordinates describing where the `Polygon` lies.\n\nRaises\n------\nValueError\n    If the type isn't correct."}, "GeospatialFilter": {"properties": {"value": {"anyOf": [{"$ref": "#/components/schemas/GeoJSONPoint"}, {"$ref": "#/components/schemas/GeoJSONPolygon"}, {"$ref": "#/components/schemas/GeoJSONMultiPolygon"}], "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "intersect"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "GeospatialFilter", "description": "Used to filter on geospatial coordinates.\n\nAttributes\n----------\nvalue : GeoJSON\n    A dictionary containing a Point, Polygon, or MultiPolygon. Mirrors `shapely's` `GeoJSON` format.\noperator : str\n    The operator to use for comparison. Should be one of `intersect`, `inside`, or `outside`."}, "GroundTruth-Input": {"properties": {"datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Input"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["datum", "annotations"], "title": "GroundTruth", "description": "An object describing a ground truth (e.g., a human-drawn bounding box on an image).\n\nAttributes\n----------\ndatum : Datum\n    The `Datum` associated with the `GroundTruth`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `GroundTruth`.\n\nRaises\n----------\nValueError\n    If the same label appears in two annotations.\n    If any rasters don't match their metadata."}, "GroundTruth-Output": {"properties": {"datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Output"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["datum", "annotations"], "title": "GroundTruth", "description": "An object describing a ground truth (e.g., a human-drawn bounding box on an image).\n\nAttributes\n----------\ndatum : Datum\n    The `Datum` associated with the `GroundTruth`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `GroundTruth`.\n\nRaises\n----------\nValueError\n    If the same label appears in two annotations.\n    If any rasters don't match their metadata."}, "HTTPValidationError": {"properties": {"detail": {"items": {"$ref": "#/components/schemas/ValidationError"}, "type": "array", "title": "Detail"}}, "type": "object", "title": "HTTPValidationError"}, "Label": {"properties": {"key": {"type": "string", "title": "Key"}, "value": {"type": "string", "title": "Value"}, "score": {"anyOf": [{"type": "number"}, {"type": "null"}], "title": "Score"}}, "type": "object", "required": ["key", "value"], "title": "Label", "description": "An object for labeling datasets, models, and annotations.\n\nAttributes\n----------\nkey : str\n    A key for the `Label`.\nvalue : str\n    A value for the `Label`.\nscore : float\n    The score associated with the `Label` (where applicable).\n\nAttributes\n----------\nid : int\n    A unique ID for the `Label`."}, "Metric": {"properties": {"type": {"type": "string", "title": "Type"}, "parameters": {"anyOf": [{"type": "object"}, {"type": "null"}], "title": "Parameters"}, "value": {"anyOf": [{"type": "number"}, {"type": "object"}, {"type": "null"}], "title": "Value"}, "label": {"anyOf": [{"$ref": "#/components/schemas/Label"}, {"type": "null"}]}}, "type": "object", "required": ["type"], "title": "Metric", "description": "A metric response from the API.\n\nAttributes\n----------\ntype : str\n    The type of metric.\nparameters : dict\n    The parameters of the metric.\nvalue : float\n    The value of the metric.\nlabel : Label\n    The `Label` for the metric."}, "Model": {"properties": {"id": {"anyOf": [{"type": "integer"}, {"type": "null"}], "title": "Id"}, "name": {"type": "string", "title": "Name"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}, {"type": "boolean"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"additionalProperties": {"anyOf": [{"type": "string"}, {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array"}]}, "type": "object"}]}, "type": "object"}]}, "type": "object", "title": "Metadata", "default": {}}}, "additionalProperties": false, "type": "object", "required": ["name"], "title": "Model", "description": "A class describing a model that was trained on a particular dataset.\n\nAttributes\n----------\nid : int\n    The ID of the model.\nname : str\n    The name of the model.\nmetadata :  MetadataType\n    A dictionary of metadata that describes the model.\n\nRaises\n----------\nValueError\n    If the name is invalid."}, "MultiPolygon-Input": {"properties": {"polygons": {"items": {"$ref": "#/components/schemas/Polygon-Input"}, "type": "array", "title": "Polygons"}}, "type": "object", "required": ["polygons"], "title": "MultiPolygon", "description": "Describes a multipolygon in geometric space.\n\nAttributes\n----------\npolygons: List[Polygon]\n    A list of polygons that make up the `MultiPolygon`.\n\nRaises\n------\nValueError\n    If less than three points are passed."}, "MultiPolygon-Output": {"properties": {"polygons": {"items": {"$ref": "#/components/schemas/Polygon-Output"}, "type": "array", "title": "Polygons"}}, "type": "object", "required": ["polygons"], "title": "MultiPolygon", "description": "Describes a multipolygon in geometric space.\n\nAttributes\n----------\npolygons: List[Polygon]\n    A list of polygons that make up the `MultiPolygon`.\n\nRaises\n------\nValueError\n    If less than three points are passed."}, "NumericFilter": {"properties": {"value": {"type": "number", "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "NumericFilter", "description": "Used to filter on numeric values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : float\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\">\", \"<\", \">=\", \"<=\", \"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "Point": {"properties": {"x": {"type": "number", "title": "X"}, "y": {"type": "number", "title": "Y"}}, "type": "object", "required": ["x", "y"], "title": "Point", "description": "Describes a point in geometric space.\n\nAttributes\n----------\nx : float\n    The x-coordinate of the point.\ny : float\n    The y-coordinate of the point.\n\nRaises\n------\nValueError\n    If an x or y-coordinate isn't passed."}, "Polygon-Input": {"properties": {"boundary": {"$ref": "#/components/schemas/BasicPolygon"}, "holes": {"anyOf": [{"items": {"$ref": "#/components/schemas/BasicPolygon"}, "type": "array"}, {"type": "null"}], "title": "Holes"}}, "type": "object", "required": ["boundary"], "title": "Polygon", "description": "Describes a polygon in geometric space.\n\nAttributes\n----------\nboundary : BasicPolygon\n    The polygon itself.\nholes : List[BasicPolygon]\n    Any holes that exist within the polygon."}, "Polygon-Output": {"properties": {"boundary": {"$ref": "#/components/schemas/BasicPolygon"}, "holes": {"anyOf": [{"items": {"$ref": "#/components/schemas/BasicPolygon"}, "type": "array"}, {"type": "null"}], "title": "Holes"}}, "type": "object", "required": ["boundary"], "title": "Polygon", "description": "Describes a polygon in geometric space.\n\nAttributes\n----------\nboundary : BasicPolygon\n    The polygon itself.\nholes : List[BasicPolygon]\n    Any holes that exist within the polygon."}, "Prediction-Input": {"properties": {"model_name": {"type": "string", "title": "Model Name"}, "datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Input"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["model_name", "datum", "annotations"], "title": "Prediction", "description": "An object describing a prediction (e.g., a machine-drawn bounding box on an image).\n\nAttributes\n----------\nmodel_name : str\n    The name of the model that produced the `Prediction`.\ndatum : Datum\n    The `Datum` associated with the `Prediction`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `Prediction`.\n\nRaises\n----------\nValueError\n    If the model name is invalid.\n    If no annotations are passed.\n    If the same label appears in two annotations.\n    If we're missing scores for any label.\n    If semantic segmentations contain a score.\n    If label scores for any key sum to more than 1."}, "Prediction-Output": {"properties": {"model_name": {"type": "string", "title": "Model Name"}, "datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Output"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["model_name", "datum", "annotations"], "title": "Prediction", "description": "An object describing a prediction (e.g., a machine-drawn bounding box on an image).\n\nAttributes\n----------\nmodel_name : str\n    The name of the model that produced the `Prediction`.\ndatum : Datum\n    The `Datum` associated with the `Prediction`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `Prediction`.\n\nRaises\n----------\nValueError\n    If the model name is invalid.\n    If no annotations are passed.\n    If the same label appears in two annotations.\n    If we're missing scores for any label.\n    If semantic segmentations contain a score.\n    If label scores for any key sum to more than 1."}, "Raster": {"properties": {"mask": {"type": "string", "title": "Mask"}}, "type": "object", "required": ["mask"], "title": "Raster", "description": "Describes a raster in geometric space.\n\nAttributes\n----------\nmask : str\n    The mask describing the raster.\n\nRaises\n------\nValueError\n    If the image format is not PNG.\n    If the image mode is not binary."}, "StringFilter": {"properties": {"value": {"type": "string", "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "StringFilter", "description": "Used to filter on string values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : str\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "TableStatus": {"type": "string", "enum": ["creating", "finalized", "deleting"], "title": "TableStatus"}, "TaskType": {"type": "string", "enum": ["skip", "empty", "classification", "object-detection", "semantic-segmentation"], "title": "TaskType"}, "Time": {"properties": {"time": {"type": "string", "title": "Time"}}, "additionalProperties": false, "type": "object", "required": ["time"], "title": "Time", "description": "An object describing a time.\n\nAttributes\n----------\ntime : str\n    Time in ISO format."}, "ValidationError": {"properties": {"loc": {"items": {"anyOf": [{"type": "string"}, {"type": "integer"}]}, "type": "array", "title": "Location"}, "msg": {"type": "string", "title": "Message"}, "type": {"type": "string", "title": "Error Type"}}, "type": "object", "required": ["loc", "msg", "type"], "title": "ValidationError"}}, "securitySchemes": {"OptionalHTTPBearer": {"type": "http", "scheme": "bearer"}}}}