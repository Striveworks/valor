{"openapi": "3.1.0", "info": {"title": "FastAPI", "version": "0.1.0"}, "paths": {"/groundtruths": {"post": {"tags": ["GroundTruths"], "summary": "Create Groundtruths", "description": "Create a groundtruth in the database.\n\nPOST Endpoint: `/groundtruths`\n\nParameters\n----------\ngt : schemas.GroundTruth\n    The groundtruth to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.\nHTTPException (409)\n    If the dataset has been finalized, or if the datum already exists.", "operationId": "create_groundtruths_groundtruths_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/GroundTruth-Input"}}}, "required": true}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/groundtruths/dataset/{dataset_name}/datum/{uid}": {"get": {"tags": ["GroundTruths"], "summary": "Get Groundtruth", "description": "Fetch a groundtruth from the database.\n\nGET Endpoint: `/groundtruths/dataset/{dataset_name}/datum/{uid}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset to fetch the groundtruth from.\nuid : str\n    The UID of the groundtruth.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.GroundTruth\n    Thee groundtruth requested by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum does not exist.", "operationId": "get_groundtruth_groundtruths_dataset__dataset_name__datum__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/GroundTruth-Output"}, {"type": "null"}], "title": "Response Get Groundtruth Groundtruths Dataset  Dataset Name  Datum  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/predictions": {"post": {"tags": ["Predictions"], "summary": "Create Predictions", "description": "Create a prediction in the database.\n\nPOST Endpoint: `/predictions`\n\nParameters\n----------\npd : schemas.Prediction\n    The prediction to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset, model, or datum doesn't exist.\nHTTPException (409)\n    If the model has been finalized, or if the dataset has not been finalized.", "operationId": "create_predictions_predictions_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Prediction-Input"}}}, "required": true}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/predictions/model/{model_name}/dataset/{dataset_name}/datum/{uid}": {"get": {"tags": ["Predictions"], "summary": "Get Prediction", "description": "Fetch a prediction from the database.\n\nGET Endpoint: `/predictions/model/{model_name}/dataset/{dataset_name}/datum/{uid}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model associated with the prediction.\ndataset_name : str\n    The name of the dataset associated with the prediction.\nuid : str\n    The UID associated with the prediction.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Prediction\n    The requested prediction.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.", "operationId": "get_prediction_predictions_model__model_name__dataset__dataset_name__datum__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}, {"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Prediction-Output"}, {"type": "null"}], "title": "Response Get Prediction Predictions Model  Model Name  Dataset  Dataset Name  Datum  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/labels": {"get": {"tags": ["Labels"], "summary": "Get All Labels", "description": "Fetch all labels in the database.\n\nGET Endpoint: `/labels`\n\nParameters\n----------\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Label]\n    A list of all labels in the database.", "operationId": "get_all_labels_labels_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Response Get All Labels Labels Get"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/labels/dataset/{dataset_name}": {"get": {"tags": ["Labels"], "summary": "Get Labels From Dataset", "description": "Fetch all labels for a particular dataset from the database.\n\nGET Endpoint: `/labels/dataset/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Label]\n    A list of all labels associated with the dataset in the database.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_labels_from_dataset_labels_dataset__dataset_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Label"}, "title": "Response Get Labels From Dataset Labels Dataset  Dataset Name  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/labels/model/{model_name}": {"get": {"tags": ["Labels"], "summary": "Get Labels From Model", "description": "Fetch all labels for a particular model from the database.\n\nGET Endpoint: `/labels/model/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Label]\n    A list of all labels associated with the model in the database.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.", "operationId": "get_labels_from_model_labels_model__model_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Label"}, "title": "Response Get Labels From Model Labels Model  Model Name  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets": {"get": {"tags": ["Datasets"], "summary": "Get Datasets", "description": "Fetch all datasets from the database.\n\nGET Endpoint: `/datasets`\n\nParameters\n----------\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Dataset]\n    A list of all datasets stored in the database.", "operationId": "get_datasets_datasets_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Dataset"}, "type": "array", "title": "Response Get Datasets Datasets Get"}}}}}, "security": [{"OptionalHTTPBearer": []}]}, "post": {"tags": ["Datasets"], "summary": "Create Dataset", "description": "Create a dataset in the database.\n\nPOST Endpoint: `/datasets`\n\nParameters\n----------\ndataset : schemas.Dataset\n    The dataset to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (409)\n    If the dataset already exists.", "operationId": "create_dataset_datasets_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Dataset"}}}, "required": true}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/datasets/{dataset_name}": {"get": {"tags": ["Datasets"], "summary": "Get Dataset", "description": "Fetch a particular dataset from the database.\n\nGET Endpoint: `/datasets/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Dataset\n    The requested dataset.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_dataset_datasets__dataset_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Dataset"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Datasets"], "summary": "Delete Dataset", "description": "Delete a dataset from the database.\n\nDELETE Endpoint: `/datasets/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nbackground_tasks: BackgroundTasks\n    A FastAPI `BackgroundTasks` object to process the deletion asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.\nHTTPException (409)\n    If the dataset isn't in the correct state to be deleted.", "operationId": "delete_dataset_datasets__dataset_name__delete", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}/status": {"get": {"tags": ["Datasets"], "summary": "Get Dataset Status", "description": "Fetch the status of a dataset.\n\nGET Endpoint: `/datasets/{dataset_name}/status`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nenums.JobStatus\n    The requested state.\n\nRaises\n------\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "get_dataset_status_datasets__dataset_name__status_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/JobStatus"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/datasets/{dataset_name}/finalize": {"put": {"tags": ["Datasets"], "summary": "Finalize Dataset", "description": "Finalizes a dataset for evaluation.\n\nPUT Endpoint: `/datasets/{dataset_name}/finalize`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (409)\n    If the dataset is empty.\nHTTPException (404)\n    If the dataset doesn't exist.", "operationId": "finalize_dataset_datasets__dataset_name__finalize_put", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/data/dataset/{dataset_name}": {"get": {"tags": ["Datums"], "summary": "Get Datums", "description": "Fetch all datums for a particular dataset.\n\nGET Endpoint: `/data/dataset/{dataset_name}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Datum]\n    A list of datums.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.", "operationId": "get_datums_data_dataset__dataset_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Datum"}, "title": "Response Get Datums Data Dataset  Dataset Name  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/data/dataset/{dataset_name}/uid/{uid}": {"get": {"tags": ["Datums"], "summary": "Get Datum", "description": "Fetch a particular datum.\n\nGET Endpoint: `/data/dataset/{dataset_name}/uid/{uid}`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nuid : str\n    The UID of the datum.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Datum\n    The requested datum.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.", "operationId": "get_datum_data_dataset__dataset_name__uid__uid__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "uid", "in": "path", "required": true, "schema": {"type": "string", "title": "Uid"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/Datum"}, {"type": "null"}], "title": "Response Get Datum Data Dataset  Dataset Name  Uid  Uid  Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models": {"get": {"tags": ["Models"], "summary": "Get Models", "description": "Fetch all models in the database.\n\nGET Endpoint: `/models`\n\nParameters\n----------\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Model]\n    A list of models.", "operationId": "get_models_models_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"items": {"$ref": "#/components/schemas/Model"}, "type": "array", "title": "Response Get Models Models Get"}}}}}, "security": [{"OptionalHTTPBearer": []}]}, "post": {"tags": ["Models"], "summary": "Create Model", "description": "Create a model in the database.\n\nPOST Endpoint: `/models`\n\nParameters\n----------\nmodel : schemas.Model\n    The model to add to the database.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the dataset or datum doesn't exist.\nHTTPException (409)\n    If the dataset has been finalized, or if the datum already exists.", "operationId": "create_model_models_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Model"}}}, "required": true}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/models/{model_name}": {"get": {"tags": ["Models"], "summary": "Get Model", "description": "Fetch a particular model.\n\nGET Endpoint: `/models/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.Model\n    The requested model.\n\nRaises\n------\nHTTPException (404)\n    If the model datum doesn't exist.", "operationId": "get_model_models__model_name__get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Model"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Models"], "summary": "Delete Model", "description": "Delete a model from the database.\n\nDELETE Endpoint: `/models/{model_name}`\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.\nHTTPException (409)\n    If the model isn't in the correct state to be deleted.", "operationId": "delete_model_models__model_name__delete", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models/{model_name}/status": {"get": {"tags": ["Models"], "summary": "Get Model Status", "description": "Fetch the status of a model.\n\nParameters\n----------\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nenums.JobStatus\n    The requested state.\n\nRaises\n------\nHTTPException (404)\n    If the model doesn't exist.", "operationId": "get_model_status_models__model_name__status_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/JobStatus"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/models/{model_name}/datasets/{dataset_name}/finalize": {"put": {"tags": ["Models"], "summary": "Finalize Inferences", "description": "Finalize a model prior to evaluation.\n\nPUT Endpoint: `/models/{model_name}/datasets/{dataset_name}/finalize`\n\nParameters\n----------\ndataset_name : str\n    The name of the dataset.\nmodel_name : str\n    The name of the model.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\n\nRaises\n------\nHTTPException (400)\n    If the dataset or model are empty.\nHTTPException (404)\n    If the dataset or model do not exist.", "operationId": "finalize_inferences_models__model_name__datasets__dataset_name__finalize_put", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "dataset_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Dataset Name"}}, {"name": "model_name", "in": "path", "required": true, "schema": {"type": "string", "title": "Model Name"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/evaluations": {"post": {"tags": ["Evaluations"], "summary": "Create Evaluation", "description": "Create a new evaluation.\n\nPOST Endpoint: `/evaluations`\n\nParameters\n----------\njob_request: schemas.EvaluationJob\n    The job request for the evaluation.\nbackground_tasks: BackgroundTasks\n    A FastAPI `BackgroundTasks` object to process the creation asyncronously. This parameter is a FastAPI dependency and shouldn't be submitted by the user.\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nschemas.CreateClfMetricsResponse | schemas.CreateDetectionMetricsResponse | schemas.CreateSemanticSegmentationMetricsResponse\n    An evaluation response object.\n\nRaises\n------\nHTTPException (400)\n    If the task type of the evaluation job doesn't exist, or if another ValueError is thrown.\nHTTPException (404)\n    If the dataset or model does not exist.\nHTTPException (405)\n    If the dataset or model hasn't been finalized.\nHTTPException (409)\n    If there is a state exception when creating the evaluation.", "operationId": "create_evaluation_evaluations_post", "security": [{"OptionalHTTPBearer": []}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EvaluationJob"}}}}, "responses": {"202": {"description": "Successful Response", "content": {"application/json": {"schema": {"anyOf": [{"$ref": "#/components/schemas/CreateClfMetricsResponse"}, {"$ref": "#/components/schemas/CreateDetectionMetricsResponse"}, {"$ref": "#/components/schemas/CreateSemanticSegmentationMetricsResponse"}], "title": "Response Create Evaluation Evaluations Post"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "get": {"tags": ["Evaluations"], "summary": "Get Bulk Evaluations", "description": "Fetch all metrics associated with user-supplied dataset and model names. Users\nmay query using model names, dataset names, or both. All metrics for all specified\nmodels and datasets will be returned in a list of Evaluations.\n\nThis endpoint can handle multiple dataset and model names. For example, you can use\n`/evaluations?models=first_model,second_model&datasets=test_dataset` to get all evaluations\nrelated to `test_dataset` and either `first_model` or `second_model`.\n\nGET Endpoint: `/evaluations`\n\nParameters\n----------\ndatasets : str\n    An optional set of dataset names to return metrics for\nmodels : str\n    An optional set of model names to return metrics for\njob_ids : str\n    An optional set of job_ids to return metrics for\ndb : Session\n    The database session to use. This parameter is a sqlalchemy dependency and shouldn't be submitted by the user.\n\nReturns\n-------\nList[schemas.Evaluation]\n    A list of evaluations.\n\nRaises\n------\nHTTPException (400)\n    If a ValueError is thrown.\nHTTPException (404)\n    If the dataset or model doesn't exist.", "operationId": "get_bulk_evaluations_evaluations_get", "security": [{"OptionalHTTPBearer": []}], "parameters": [{"name": "datasets", "in": "query", "required": false, "schema": {"type": "string", "title": "Datasets"}}, {"name": "models", "in": "query", "required": false, "schema": {"type": "string", "title": "Models"}}, {"name": "job_ids", "in": "query", "required": false, "schema": {"type": "string", "title": "Job Ids"}}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Evaluation"}, "title": "Response Get Bulk Evaluations Evaluations Get"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/user": {"get": {"tags": ["Authentication"], "summary": "Get User", "description": "Verify a user and return their email address.\n\nGET Endpoint: `/user`\n\nParameters\n----------\ntoken: HTTPAuthorizationCredentials\n    The auth token for the user.\n\nReturns\n-------\nschemas.User\n    A response object containing information about the user.", "operationId": "get_user_user_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/User"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/api-version": {"get": {"tags": ["Info"], "summary": "Get Api Version", "description": "Return the API's version.\n\nGET Endpoint: `/api-version`\n\nReturns\n-------\nschemas.APIVersion\n    A response object containing the API's version number.", "operationId": "get_api_version_api_version_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/APIVersion"}}}}}, "security": [{"OptionalHTTPBearer": []}]}}, "/health": {"get": {"tags": ["Status"], "summary": "Health", "description": "Return 200 if the service is up.\n\nGET Endpoint: `/health`\n\nReturns\n-------\nschemas.Health\n    A response indicating that the service is up and running.", "operationId": "health_health_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}}}}, "/ready": {"get": {"tags": ["Status"], "summary": "Ready", "description": "Return 200 if the service is up and connected to the database.\n\nGET Endpoint: `/ready`\n\nReturns\n-------\nschemas.Readiness\n    A response indicating that the service is up and connected to the database.", "operationId": "ready_ready_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}}}}}, "components": {"schemas": {"APIVersion": {"properties": {"api_version": {"type": "string", "title": "Api Version"}}, "type": "object", "required": ["api_version"], "title": "APIVersion", "description": "Defines an API version string which is sent back to the user after their authentication is confirmed.\n\nAttributes\n----------\napi_version : str\n    The API version."}, "Annotation-Input": {"properties": {"task_type": {"$ref": "#/components/schemas/TaskType"}, "labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Labels"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}]}, "type": "object", "title": "Metadata"}, "bounding_box": {"anyOf": [{"$ref": "#/components/schemas/BoundingBox-Input"}, {"type": "null"}]}, "polygon": {"anyOf": [{"$ref": "#/components/schemas/Polygon-Input"}, {"type": "null"}]}, "multipolygon": {"anyOf": [{"$ref": "#/components/schemas/MultiPolygon-Input"}, {"type": "null"}]}, "raster": {"anyOf": [{"$ref": "#/components/schemas/Raster"}, {"type": "null"}]}, "jsonb": {"anyOf": [{"additionalProperties": {"type": "string"}, "type": "object"}, {"type": "null"}], "title": "Jsonb"}}, "additionalProperties": false, "type": "object", "required": ["task_type", "labels"], "title": "Annotation", "description": "A class used to annotate `GroundTruths` and `Predictions`.\n\nAttributes\n----------\ntask_type: TaskType\n    The task type associated with the `Annotation`.\nlabels: List[Label]\n    A list of labels to use for the `Annotation`.\nmetadata: Dict[str, Union[int, float, str]]\n    A dictionary of metadata that describes the `Annotation`.\nbounding_box: BoundingBox\n    A bounding box to assign to the `Annotation`.\npolygon: Polygon\n    A polygon to assign to the `Annotation`.\nmultipolygon: MultiPolygon\n    A multipolygon to assign to the `Annotation`.\nraster: Raster\n    A raster to assign to the `Annotation`.\njsonb: Dict\n    A jsonb to assign to the `Annotation`.\n\nRaises\n----------\nValueError\n    If no labels are passed.\n    If the same label appears in two annotations."}, "Annotation-Output": {"properties": {"task_type": {"$ref": "#/components/schemas/TaskType"}, "labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Labels"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}]}, "type": "object", "title": "Metadata"}, "bounding_box": {"anyOf": [{"$ref": "#/components/schemas/BoundingBox-Output"}, {"type": "null"}]}, "polygon": {"anyOf": [{"$ref": "#/components/schemas/Polygon-Output"}, {"type": "null"}]}, "multipolygon": {"anyOf": [{"$ref": "#/components/schemas/MultiPolygon-Output"}, {"type": "null"}]}, "raster": {"anyOf": [{"$ref": "#/components/schemas/Raster"}, {"type": "null"}]}, "jsonb": {"anyOf": [{"additionalProperties": {"type": "string"}, "type": "object"}, {"type": "null"}], "title": "Jsonb"}}, "additionalProperties": false, "type": "object", "required": ["task_type", "labels"], "title": "Annotation", "description": "A class used to annotate `GroundTruths` and `Predictions`.\n\nAttributes\n----------\ntask_type: TaskType\n    The task type associated with the `Annotation`.\nlabels: List[Label]\n    A list of labels to use for the `Annotation`.\nmetadata: Dict[str, Union[int, float, str]]\n    A dictionary of metadata that describes the `Annotation`.\nbounding_box: BoundingBox\n    A bounding box to assign to the `Annotation`.\npolygon: Polygon\n    A polygon to assign to the `Annotation`.\nmultipolygon: MultiPolygon\n    A multipolygon to assign to the `Annotation`.\nraster: Raster\n    A raster to assign to the `Annotation`.\njsonb: Dict\n    A jsonb to assign to the `Annotation`.\n\nRaises\n----------\nValueError\n    If no labels are passed.\n    If the same label appears in two annotations."}, "AnnotationType": {"type": "string", "enum": ["none", "json", "box", "polygon", "multipolygon", "raster"], "title": "AnnotationType"}, "BasicPolygon": {"properties": {"points": {"items": {"$ref": "#/components/schemas/Point"}, "type": "array", "title": "Points"}}, "type": "object", "required": ["points"], "title": "BasicPolygon", "description": "Describes a polygon in geometric space.\n\nAttributes\n----------\npoints: Tuple[Point, Point]\n    The coordinates of the polygon.\n\nRaises\n------\nValueError\n    If less than three points are passed."}, "BoundingBox-Input": {"properties": {"polygon": {"$ref": "#/components/schemas/BasicPolygon"}}, "type": "object", "required": ["polygon"], "title": "BoundingBox", "description": "Describes a bounding box in geometric space.\n\nAttributes\n----------\npolygons: BasicPolygon\n    A polygon describing the bounding box.\n\nRaises\n------\nValueError\n    If the number of points != 4."}, "BoundingBox-Output": {"properties": {"polygon": {"$ref": "#/components/schemas/BasicPolygon"}}, "type": "object", "required": ["polygon"], "title": "BoundingBox", "description": "Describes a bounding box in geometric space.\n\nAttributes\n----------\npolygons: BasicPolygon\n    A polygon describing the bounding box.\n\nRaises\n------\nValueError\n    If the number of points != 4."}, "ConfusionMatrixEntry": {"properties": {"prediction": {"type": "string", "title": "Prediction"}, "groundtruth": {"type": "string", "title": "Groundtruth"}, "count": {"type": "integer", "title": "Count"}}, "type": "object", "required": ["prediction", "groundtruth", "count"], "title": "ConfusionMatrixEntry", "description": "Describes one element in a confusion matrix.\n\nAttributes\n----------\nprediction : str\n    The prediction.\ngroundtruth : str\n    The groundtruth.\ncount : int\n    The value of the element in the matrix."}, "ConfusionMatrixResponse": {"properties": {"label_key": {"type": "string", "title": "Label Key"}, "entries": {"items": {"$ref": "#/components/schemas/ConfusionMatrixEntry"}, "type": "array", "title": "Entries"}}, "type": "object", "required": ["label_key", "entries"], "title": "ConfusionMatrixResponse", "description": "A response object used for HTTP responses since they won't contain matrix or label map attributes."}, "CreateClfMetricsResponse": {"properties": {"missing_pred_keys": {"items": {"type": "string"}, "type": "array", "title": "Missing Pred Keys"}, "ignored_pred_keys": {"items": {"type": "string"}, "type": "array", "title": "Ignored Pred Keys"}, "job_id": {"type": "integer", "title": "Job Id"}}, "type": "object", "required": ["missing_pred_keys", "ignored_pred_keys", "job_id"], "title": "CreateClfMetricsResponse", "description": "The response from a job that creates classification metrics.\n\nAttributes\n----------\nmissing_pred_keys: list[str]\n    A list of missing prediction keys.\nignored_pred_keys: list[str]\n    A list of ignored preiction keys.\njob_id: int\n    The job ID."}, "CreateDetectionMetricsResponse": {"properties": {"missing_pred_labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Missing Pred Labels"}, "ignored_pred_labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Ignored Pred Labels"}, "job_id": {"type": "integer", "title": "Job Id"}}, "type": "object", "required": ["missing_pred_labels", "ignored_pred_labels", "job_id"], "title": "CreateDetectionMetricsResponse", "description": "The response from a job that creates AP metrics.\n\nAttributes\n----------\nmissing_pred_labels: list[Label]\n    A list of missing prediction labels.\nignored_pred_labels: list[Label]\n    A list of ignored preiction labels.\njob_id: int\n    The job ID."}, "CreateSemanticSegmentationMetricsResponse": {"properties": {"missing_pred_labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Missing Pred Labels"}, "ignored_pred_labels": {"items": {"$ref": "#/components/schemas/Label"}, "type": "array", "title": "Ignored Pred Labels"}, "job_id": {"type": "integer", "title": "Job Id"}}, "type": "object", "required": ["missing_pred_labels", "ignored_pred_labels", "job_id"], "title": "CreateSemanticSegmentationMetricsResponse", "description": "The response from a job that creates segmentation metrics.\n\nAttributes\n----------\nmissing_pred_labels: list[Label]\n    A list of missing prediction labels.\nignored_pred_labels: list[Label]\n    A list of ignored preiction labels.\njob_id: int\n    The job ID."}, "Dataset": {"properties": {"id": {"anyOf": [{"type": "integer"}, {"type": "null"}], "title": "Id"}, "name": {"type": "string", "title": "Name"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}]}, "type": "object", "title": "Metadata"}, "geospatial": {"additionalProperties": {"anyOf": [{"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, {"type": "string"}]}, "type": "object", "title": "Geospatial"}}, "additionalProperties": false, "type": "object", "required": ["name"], "title": "Dataset", "description": "A class describing a given dataset.\n\nAttributes\n----------\nid : int\n    The ID of the dataset.\nname : str\n    The name of the dataset.\nmetadata :  dict\n    A dictionary of metadata that describes the dataset.\ngeospatial : dict\n    A GeoJSON-style dictionary describing the geospatial coordinates of the dataset.\n\nRaises\n----------\nValueError\n    If the name is invalid."}, "Datum": {"properties": {"uid": {"type": "string", "title": "Uid"}, "dataset": {"type": "string", "title": "Dataset"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}]}, "type": "object", "title": "Metadata"}, "geospatial": {"additionalProperties": {"anyOf": [{"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, {"type": "string"}]}, "type": "object", "title": "Geospatial"}}, "additionalProperties": false, "type": "object", "required": ["uid", "dataset"], "title": "Datum", "description": "A class used to store datum about `GroundTruths` and `Predictions`.\n\nAttributes\n----------\nuid : str\n    The UID of the `Datum`.\nmetadata : dict\n    A dictionary of metadata that describes the `Datum`.\ngeospatial :  dict\n    A GeoJSON-style dictionary describing the geospatial coordinates of the `Datum`.\ndataset : str\n    The name of the dataset to associate the `Datum` with.\n\nRaises\n----------\nValueError\n    If the dataset or UID is invalid."}, "DetectionParameters": {"properties": {"iou_thresholds_to_compute": {"items": {"type": "number"}, "type": "array", "title": "Iou Thresholds To Compute", "default": [0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95]}, "iou_thresholds_to_keep": {"anyOf": [{"items": {"type": "number"}, "type": "array"}, {"type": "null"}], "title": "Iou Thresholds To Keep", "default": [0.5, 0.75]}}, "additionalProperties": false, "type": "object", "title": "DetectionParameters", "description": "Defines important attributes to use when evaluating an object detection model.\n\nAttributes\n----------\niou_thresholds_to_compute : List[float]\n    A list of floats describing which Intersection over Unions (IoUs) to use when calculating metrics (i.e., mAP).\niou_thresholds_to_keep: List[float]\n    A list of floats describing which Intersection over Union (IoUs) thresholds to calculate a metric for. Must be a subset of `iou_thresholds_to_compute`."}, "Evaluation": {"properties": {"dataset": {"type": "string", "title": "Dataset"}, "model": {"type": "string", "title": "Model"}, "settings": {"$ref": "#/components/schemas/EvaluationSettings-Output"}, "job_id": {"type": "integer", "title": "Job Id"}, "status": {"$ref": "#/components/schemas/JobStatus"}, "metrics": {"items": {"$ref": "#/components/schemas/Metric"}, "type": "array", "title": "Metrics"}, "confusion_matrices": {"items": {"$ref": "#/components/schemas/ConfusionMatrixResponse"}, "type": "array", "title": "Confusion Matrices"}, "task_type": {"$ref": "#/components/schemas/TaskType"}}, "additionalProperties": false, "type": "object", "required": ["dataset", "model", "settings", "job_id", "status", "metrics", "confusion_matrices", "task_type"], "title": "Evaluation", "description": "An object for storing the returned results of a model evaluation (where groundtruths are compared with predictions to measure performance).\n\nAttributes\n----------\ndataset : str\n    The name of the dataset.\nmodel : str\n    The name of the model.\nsettings : EvaluationSettings\n    Settings for the evaluation.\njob_id : int\n    The ID of the evaluation job.\nstatus : str\n    The status of the evaluation.\nmetrics : List[Metric]\n    A list of metrics associated with the evaluation.\nconfusion_matrices: List[ConfusionMatrixResponse]\n    A list of confusion matrices associated with the evaluation."}, "EvaluationJob": {"properties": {"model": {"type": "string", "title": "Model"}, "dataset": {"type": "string", "title": "Dataset"}, "task_type": {"$ref": "#/components/schemas/TaskType"}, "settings": {"allOf": [{"$ref": "#/components/schemas/EvaluationSettings-Input"}], "default": {}}, "id": {"anyOf": [{"type": "integer"}, {"type": "null"}], "title": "Id"}}, "additionalProperties": false, "type": "object", "required": ["model", "dataset", "task_type"], "title": "EvaluationJob", "description": "Defines important attributes of an evaluation job.\n\nAttributes\n----------\nmodel : str\n    The name of the `Model` invoked during the evaluation.\ndataset : str\n    The name of the `Dataset` invoked during the evaluation.\ntask_type : TaskType\n    The task type of the evaluation.\nsettings : EvaluationSettings\n    The `EvaluationSettings` object used to configurate the `EvaluationJob`.\nid : int\n    The id of the job."}, "EvaluationSettings-Input": {"properties": {"parameters": {"anyOf": [{"$ref": "#/components/schemas/DetectionParameters"}, {"type": "null"}]}, "filters": {"anyOf": [{"$ref": "#/components/schemas/Filter-Input"}, {"type": "null"}]}}, "additionalProperties": false, "type": "object", "title": "EvaluationSettings", "description": "Defines important attributes of an evaluation's settings.\n\nAttributes\n----------\nparameters : DetectionParameters\n    The parameter object (e.g., `DetectionParameters) to use when creating an evaluation.\nfilters: Filter\n    The `Filter`object to use when creating an evaluation."}, "EvaluationSettings-Output": {"properties": {"parameters": {"anyOf": [{"$ref": "#/components/schemas/DetectionParameters"}, {"type": "null"}]}, "filters": {"anyOf": [{"$ref": "#/components/schemas/Filter-Output"}, {"type": "null"}]}}, "additionalProperties": false, "type": "object", "title": "EvaluationSettings", "description": "Defines important attributes of an evaluation's settings.\n\nAttributes\n----------\nparameters : DetectionParameters\n    The parameter object (e.g., `DetectionParameters) to use when creating an evaluation.\nfilters: Filter\n    The `Filter`object to use when creating an evaluation."}, "Filter-Input": {"properties": {"dataset_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Dataset Names"}, "dataset_metadata": {"anyOf": [{"additionalProperties": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}]}, "type": "object"}, {"type": "null"}], "title": "Dataset Metadata"}, "dataset_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter-Input"}, "type": "array"}, {"type": "null"}], "title": "Dataset Geospatial"}, "models_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Models Names"}, "models_metadata": {"anyOf": [{"additionalProperties": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}]}, "type": "object"}, {"type": "null"}], "title": "Models Metadata"}, "models_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter-Input"}, "type": "array"}, {"type": "null"}], "title": "Models Geospatial"}, "datum_ids": {"anyOf": [{"items": {"type": "integer"}, "type": "array"}, {"type": "null"}], "title": "Datum Ids"}, "datum_uids": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Datum Uids"}, "datum_metadata": {"anyOf": [{"additionalProperties": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}]}, "type": "object"}, {"type": "null"}], "title": "Datum Metadata"}, "datum_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter-Input"}, "type": "array"}, {"type": "null"}], "title": "Datum Geospatial"}, "task_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/TaskType"}, "type": "array"}, {"type": "null"}], "title": "Task Types"}, "annotation_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/AnnotationType"}, "type": "array"}, {"type": "null"}], "title": "Annotation Types"}, "annotation_geometric_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Annotation Geometric Area"}, "annotation_metadata": {"anyOf": [{"additionalProperties": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}]}, "type": "object"}, {"type": "null"}], "title": "Annotation Metadata"}, "annotation_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter-Input"}, "type": "array"}, {"type": "null"}], "title": "Annotation Geospatial"}, "prediction_scores": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Prediction Scores"}, "labels": {"anyOf": [{"items": {"additionalProperties": {"type": "string"}, "type": "object"}, "type": "array"}, {"type": "null"}], "title": "Labels"}, "label_ids": {"anyOf": [{"items": {"type": "integer"}, "type": "array"}, {"type": "null"}], "title": "Label Ids"}, "label_keys": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Label Keys"}}, "additionalProperties": false, "type": "object", "title": "Filter", "description": "Used to filter Evaluations according to specific, user-defined criteria.\n\nAttributes\n----------\ndataset_names: List[str]\n    A list of `Dataset` names to filter on.\ndataset_metadata: Dict[str, List[ValueFilter]]\n    A dictionary of `Dataset` metadata to filter on.\ndataset_geospatial: List[GeospatialFilter].\n    A list of `Dataset` geospatial filters to filter on.\nmodels_names: List[str]\n    A list of `Model` names to filter on.\nmodels_metadata: Dict[str, List[ValueFilter]]\n    A dictionary of `Model` metadata to filter on.\nmodels_geospatial: List[GeospatialFilter]\n    A list of `Model` geospatial filters to filter on.\ndatum_ids: List[str]\n    A list of `Datum` UIDs to filter on.\ndatum_metadata: Dict[str, List[ValueFilter]] = None\n    A dictionary of `Datum` metadata to filter on.\ndatum_geospatial: List[GeospatialFilter]\n    A list of `Datum` geospatial filters to filter on.\ntask_types: List[TaskType]\n    A list of task types to filter on.\nannotation_types: List[AnnotationType]\n    A list of `Annotation` types to filter on.\nannotation_geometric_area: List[ValueFilter]\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Annotation`'s geometric area.\nannotation_metadata: Dict[str, List[ValueFilter]]\n    A dictionary of `Annotation` metadata to filter on.\nannotation_geospatial: List[GeospatialFilter]\n    A list of `Annotation` geospatial filters to filter on.\nprediction_scores: List[ValueFilter]\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Model`'s prediction scores.\nlabels: List[Dict[str, str]]\n    A dictionary of `Labels' to filter on.\nlabel_ids: List[int]\n    A list of `Label` IDs to filter on.\nlabel_keys: List[str] = None\n    A list of `Label` keys to filter on."}, "Filter-Output": {"properties": {"dataset_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Dataset Names"}, "dataset_metadata": {"anyOf": [{"additionalProperties": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}]}, "type": "object"}, {"type": "null"}], "title": "Dataset Metadata"}, "dataset_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter-Output"}, "type": "array"}, {"type": "null"}], "title": "Dataset Geospatial"}, "models_names": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Models Names"}, "models_metadata": {"anyOf": [{"additionalProperties": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}]}, "type": "object"}, {"type": "null"}], "title": "Models Metadata"}, "models_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter-Output"}, "type": "array"}, {"type": "null"}], "title": "Models Geospatial"}, "datum_ids": {"anyOf": [{"items": {"type": "integer"}, "type": "array"}, {"type": "null"}], "title": "Datum Ids"}, "datum_uids": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Datum Uids"}, "datum_metadata": {"anyOf": [{"additionalProperties": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}]}, "type": "object"}, {"type": "null"}], "title": "Datum Metadata"}, "datum_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter-Output"}, "type": "array"}, {"type": "null"}], "title": "Datum Geospatial"}, "task_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/TaskType"}, "type": "array"}, {"type": "null"}], "title": "Task Types"}, "annotation_types": {"anyOf": [{"items": {"$ref": "#/components/schemas/AnnotationType"}, "type": "array"}, {"type": "null"}], "title": "Annotation Types"}, "annotation_geometric_area": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Annotation Geometric Area"}, "annotation_metadata": {"anyOf": [{"additionalProperties": {"anyOf": [{"$ref": "#/components/schemas/StringFilter"}, {"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}]}, "type": "object"}, {"type": "null"}], "title": "Annotation Metadata"}, "annotation_geospatial": {"anyOf": [{"items": {"$ref": "#/components/schemas/GeospatialFilter-Output"}, "type": "array"}, {"type": "null"}], "title": "Annotation Geospatial"}, "prediction_scores": {"anyOf": [{"items": {"$ref": "#/components/schemas/NumericFilter"}, "type": "array"}, {"type": "null"}], "title": "Prediction Scores"}, "labels": {"anyOf": [{"items": {"additionalProperties": {"type": "string"}, "type": "object"}, "type": "array"}, {"type": "null"}], "title": "Labels"}, "label_ids": {"anyOf": [{"items": {"type": "integer"}, "type": "array"}, {"type": "null"}], "title": "Label Ids"}, "label_keys": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "title": "Label Keys"}}, "additionalProperties": false, "type": "object", "title": "Filter", "description": "Used to filter Evaluations according to specific, user-defined criteria.\n\nAttributes\n----------\ndataset_names: List[str]\n    A list of `Dataset` names to filter on.\ndataset_metadata: Dict[str, List[ValueFilter]]\n    A dictionary of `Dataset` metadata to filter on.\ndataset_geospatial: List[GeospatialFilter].\n    A list of `Dataset` geospatial filters to filter on.\nmodels_names: List[str]\n    A list of `Model` names to filter on.\nmodels_metadata: Dict[str, List[ValueFilter]]\n    A dictionary of `Model` metadata to filter on.\nmodels_geospatial: List[GeospatialFilter]\n    A list of `Model` geospatial filters to filter on.\ndatum_ids: List[str]\n    A list of `Datum` UIDs to filter on.\ndatum_metadata: Dict[str, List[ValueFilter]] = None\n    A dictionary of `Datum` metadata to filter on.\ndatum_geospatial: List[GeospatialFilter]\n    A list of `Datum` geospatial filters to filter on.\ntask_types: List[TaskType]\n    A list of task types to filter on.\nannotation_types: List[AnnotationType]\n    A list of `Annotation` types to filter on.\nannotation_geometric_area: List[ValueFilter]\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Annotation`'s geometric area.\nannotation_metadata: Dict[str, List[ValueFilter]]\n    A dictionary of `Annotation` metadata to filter on.\nannotation_geospatial: List[GeospatialFilter]\n    A list of `Annotation` geospatial filters to filter on.\nprediction_scores: List[ValueFilter]\n    A list of `ValueFilters` which are used to filter `Evaluations` according to the `Model`'s prediction scores.\nlabels: List[Dict[str, str]]\n    A dictionary of `Labels' to filter on.\nlabel_ids: List[int]\n    A list of `Label` IDs to filter on.\nlabel_keys: List[str] = None\n    A list of `Label` keys to filter on."}, "GeoJSON": {"properties": {"geometry": {"anyOf": [{"$ref": "#/components/schemas/GeoJSONPoint"}, {"$ref": "#/components/schemas/GeoJSONPolygon"}, {"$ref": "#/components/schemas/GeoJSONMultiPolygon"}], "title": "Geometry"}}, "type": "object", "required": ["geometry"], "title": "GeoJSON", "description": "Wraps other GeoJSON types.\n\nAttributes\n----------\ngeometry : GeoJSONPoint | GeoJSONPolygon | GeoJSONMultiPolygon\n    The geometry type of the GeoJSON."}, "GeoJSONMultiPolygon": {"properties": {"type": {"type": "string", "title": "Type"}, "coordinates": {"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array", "title": "Coordinates"}}, "type": "object", "required": ["type", "coordinates"], "title": "GeoJSONMultiPolygon", "description": "Describes a multipolygon in geospatial coordinates.\n\nAttributes\n----------\ntypes : str\n    The type of GeoJSON. Should be \"MultiPolygon\" for this class.\ncoordinates : List[List[List[List[float | int]]]]\n    A list of coordinates describing where the `MultiPolygon` lies.\n\nRaises\n------\nValueError\n    If the type isn't correct."}, "GeoJSONPoint": {"properties": {"type": {"type": "string", "title": "Type"}, "coordinates": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array", "title": "Coordinates"}}, "type": "object", "required": ["type", "coordinates"], "title": "GeoJSONPoint", "description": "Describes a point in geospatial coordinates.\n\nAttributes\n----------\ntypes : str\n    The type of GeoJSON. Should be \"Point\" for this class.\ncoordinates : List[float | int]\n    A list of coordinates describing where the `Point` lies.\n\nRaises\n------\nValueError\n    If the type isn't correct.\n    If passed an incorrect number of coordinates."}, "GeoJSONPolygon": {"properties": {"type": {"type": "string", "title": "Type"}, "coordinates": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array", "title": "Coordinates"}}, "type": "object", "required": ["type", "coordinates"], "title": "GeoJSONPolygon", "description": "Describes a polygon in geospatial coordinates.\n\nAttributes\n----------\ntypes : str\n    The type of GeoJSON. Should be \"Polygon\" for this class.\ncoordinates : List[List[List[float | int]]]\n    A list of coordinates describing where the `Polygon` lies.\n\nRaises\n------\nValueError\n    If the type isn't correct."}, "GeospatialFilter-Input": {"properties": {"value": {"$ref": "#/components/schemas/GeoJSON"}, "operator": {"type": "string", "title": "Operator", "default": "intersect"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "GeospatialFilter", "description": "Used to filter on geospatial coordinates.\n\nAttributes\n----------\nvalue : GeoJSON\n    A dictionary containing a Point, Polygon, or MultiPolygon. Mirrors `shapely's` `GeoJSON` format.\noperator : str\n    The operator to use for comparison. Should be one of `intersect`, `inside`, or `outside`."}, "GeospatialFilter-Output": {"properties": {"value": {"$ref": "#/components/schemas/GeoJSON"}, "operator": {"type": "string", "title": "Operator", "default": "intersect"}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "GeospatialFilter", "description": "Used to filter on geospatial coordinates.\n\nAttributes\n----------\nvalue : GeoJSON\n    A dictionary containing a Point, Polygon, or MultiPolygon. Mirrors `shapely's` `GeoJSON` format.\noperator : str\n    The operator to use for comparison. Should be one of `intersect`, `inside`, or `outside`."}, "GroundTruth-Input": {"properties": {"datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Input"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["datum", "annotations"], "title": "GroundTruth", "description": "An object describing a groundtruth (e.g., a human-drawn bounding box on an image).\n\nAttributes\n----------\ndatum : Datum\n    The `Datum` associated with the `GroundTruth`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `GroundTruth`.\n\nRaises\n----------\nValueError\n    If the same label appears in two annotations.\n    If any rasters don't match their metadata."}, "GroundTruth-Output": {"properties": {"datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Output"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["datum", "annotations"], "title": "GroundTruth", "description": "An object describing a groundtruth (e.g., a human-drawn bounding box on an image).\n\nAttributes\n----------\ndatum : Datum\n    The `Datum` associated with the `GroundTruth`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `GroundTruth`.\n\nRaises\n----------\nValueError\n    If the same label appears in two annotations.\n    If any rasters don't match their metadata."}, "HTTPValidationError": {"properties": {"detail": {"items": {"$ref": "#/components/schemas/ValidationError"}, "type": "array", "title": "Detail"}}, "type": "object", "title": "HTTPValidationError"}, "JobStatus": {"type": "string", "enum": ["none", "pending", "creating", "processing", "deleting", "failed", "done"], "title": "JobStatus"}, "Label": {"properties": {"key": {"type": "string", "title": "Key"}, "value": {"type": "string", "title": "Value"}, "score": {"anyOf": [{"type": "number"}, {"type": "null"}], "title": "Score"}}, "type": "object", "required": ["key", "value"], "title": "Label", "description": "An object for labeling datasets, models, and annotations.\n\nAttributes\n----------\nkey : str\n    A key for the `Label`.\nvalue : str\n    A value for the `Label`.\nscore : float\n    The score associated with the `Label` (where applicable).\n\nAttributes\n----------\nid : int\n    A unique ID for the `Label`."}, "Metric": {"properties": {"type": {"type": "string", "title": "Type"}, "parameters": {"anyOf": [{"type": "object"}, {"type": "null"}], "title": "Parameters"}, "value": {"anyOf": [{"type": "number"}, {"type": "object"}, {"type": "null"}], "title": "Value"}, "label": {"anyOf": [{"$ref": "#/components/schemas/Label"}, {"type": "null"}]}}, "type": "object", "required": ["type"], "title": "Metric", "description": "A metric response from the API.\n\nAttributes\n----------\ntype : str\n    The type of metric.\nparameters : dict\n    The parameters of the metric.\nvalue : float\n    The value of the metric.\nlabel : Label\n    The `Label` for the metric."}, "Model": {"properties": {"id": {"anyOf": [{"type": "integer"}, {"type": "null"}], "title": "Id"}, "name": {"type": "string", "title": "Name"}, "metadata": {"additionalProperties": {"anyOf": [{"type": "number"}, {"type": "string"}]}, "type": "object", "title": "Metadata"}, "geospatial": {"additionalProperties": {"anyOf": [{"items": {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"items": {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, "type": "array"}, "type": "array"}, {"items": {"anyOf": [{"type": "number"}, {"type": "integer"}]}, "type": "array"}, {"type": "string"}]}, "type": "object", "title": "Geospatial"}}, "additionalProperties": false, "type": "object", "required": ["name"], "title": "Model", "description": "A class describing a model that was trained on a particular dataset.\n\nAttributes\n----------\nid : int\n    The ID of the model.\nname : str\n    The name of the model.\nmetadata :  dict\n    A dictionary of metadata that describes the model.\ngeospatial : dict\n    A GeoJSON-style dictionary describing the geospatial metadata of the model.\n\nRaises\n----------\nValueError\n    If the name is invalid."}, "MultiPolygon-Input": {"properties": {"polygons": {"items": {"$ref": "#/components/schemas/Polygon-Input"}, "type": "array", "title": "Polygons"}}, "type": "object", "required": ["polygons"], "title": "MultiPolygon", "description": "Describes a multipolygon in geometric space.\n\nAttributes\n----------\npolygons: List[Polygon]\n    A list of polygons that make up the `MultiPolygon`.\n\nRaises\n------\nValueError\n    If less than three points are passed."}, "MultiPolygon-Output": {"properties": {"polygons": {"items": {"$ref": "#/components/schemas/Polygon-Output"}, "type": "array", "title": "Polygons"}}, "type": "object", "required": ["polygons"], "title": "MultiPolygon", "description": "Describes a multipolygon in geometric space.\n\nAttributes\n----------\npolygons: List[Polygon]\n    A list of polygons that make up the `MultiPolygon`.\n\nRaises\n------\nValueError\n    If less than three points are passed."}, "NumericFilter": {"properties": {"value": {"type": "number", "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "NumericFilter", "description": "Used to filter on numeric values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : float\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\">\", \"<\", \">=\", \"<=\", \"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "Point": {"properties": {"x": {"type": "number", "title": "X"}, "y": {"type": "number", "title": "Y"}}, "type": "object", "required": ["x", "y"], "title": "Point", "description": "Describes a point in geometric space.\n\nAttributes\n----------\nx : float\n    The x-coordinate of the point.\ny : float\n    The y-coordinate of the point.\n\nRaises\n------\nValueError\n    If an x or y-coordinate isn't passed."}, "Polygon-Input": {"properties": {"boundary": {"$ref": "#/components/schemas/BasicPolygon"}, "holes": {"anyOf": [{"items": {"$ref": "#/components/schemas/BasicPolygon"}, "type": "array"}, {"type": "null"}], "title": "Holes"}}, "type": "object", "required": ["boundary"], "title": "Polygon", "description": "Describes a polygon in geometric space.\n\nAttributes\n----------\nboundary : BasicPolygon\n    The polygon itself.\nholes : List[BasicPolygon]\n    Any holes that exist within the polygon."}, "Polygon-Output": {"properties": {"boundary": {"$ref": "#/components/schemas/BasicPolygon"}, "holes": {"anyOf": [{"items": {"$ref": "#/components/schemas/BasicPolygon"}, "type": "array"}, {"type": "null"}], "title": "Holes"}}, "type": "object", "required": ["boundary"], "title": "Polygon", "description": "Describes a polygon in geometric space.\n\nAttributes\n----------\nboundary : BasicPolygon\n    The polygon itself.\nholes : List[BasicPolygon]\n    Any holes that exist within the polygon."}, "Prediction-Input": {"properties": {"model": {"type": "string", "title": "Model"}, "datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Input"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["model", "datum", "annotations"], "title": "Prediction", "description": "An object describing a prediction (e.g., a machine-drawn bounding box on an image).\n\nAttributes\n----------\nmodel : str\n    The name of the model that produced the `Prediction`.\ndatum : Datum\n    The `Datum` associated with the `Prediction`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `Prediction`.\n\nRaises\n----------\nValueError\n    If the model name is invalid.\n    If no annotations are passed.\n    If the same label appears in two annotations.\n    If we're missing scores for any label.\n    If semantic segmentations contain a score.\n    If label scores for any key sum to more than 1."}, "Prediction-Output": {"properties": {"model": {"type": "string", "title": "Model"}, "datum": {"$ref": "#/components/schemas/Datum"}, "annotations": {"items": {"$ref": "#/components/schemas/Annotation-Output"}, "type": "array", "title": "Annotations"}}, "additionalProperties": false, "type": "object", "required": ["model", "datum", "annotations"], "title": "Prediction", "description": "An object describing a prediction (e.g., a machine-drawn bounding box on an image).\n\nAttributes\n----------\nmodel : str\n    The name of the model that produced the `Prediction`.\ndatum : Datum\n    The `Datum` associated with the `Prediction`.\nannotations : List[Annotation]\n    The list of `Annotations` associated with the `Prediction`.\n\nRaises\n----------\nValueError\n    If the model name is invalid.\n    If no annotations are passed.\n    If the same label appears in two annotations.\n    If we're missing scores for any label.\n    If semantic segmentations contain a score.\n    If label scores for any key sum to more than 1."}, "Raster": {"properties": {"mask": {"type": "string", "title": "Mask"}}, "type": "object", "required": ["mask"], "title": "Raster", "description": "Describes a raster in geometric space.\n\nAttributes\n----------\nmask : str\n    The mask describing the raster.\n\nRaises\n------\nValueError\n    If the image format is not PNG.\n    If the image mode is not binary."}, "StringFilter": {"properties": {"value": {"type": "string", "title": "Value"}, "operator": {"type": "string", "title": "Operator", "default": "=="}}, "additionalProperties": false, "type": "object", "required": ["value"], "title": "StringFilter", "description": "Used to filter on string values that meet some user-defined condition.\n\nAttributes\n----------\nvalue : str\n    The value to compare the specific field against.\noperator : str\n    The operator to use for comparison. Should be one of `[\"==\", \"!=\"]`.\n\nRaises\n------\nValueError\n    If the `operator` doesn't match one of the allowed patterns."}, "TaskType": {"type": "string", "enum": ["classification", "object-detection", "semantic-segmentation"], "title": "TaskType"}, "User": {"properties": {"email": {"anyOf": [{"type": "string"}, {"type": "null"}], "title": "Email"}}, "type": "object", "title": "User", "description": "Defines an authorized user.\n\nAttributes\n----------\nemail : str\n    The user's email address."}, "ValidationError": {"properties": {"loc": {"items": {"anyOf": [{"type": "string"}, {"type": "integer"}]}, "type": "array", "title": "Location"}, "msg": {"type": "string", "title": "Message"}, "type": {"type": "string", "title": "Error Type"}}, "type": "object", "required": ["loc", "msg", "type"], "title": "ValidationError"}}, "securitySchemes": {"OptionalHTTPBearer": {"type": "http", "scheme": "bearer"}}}}